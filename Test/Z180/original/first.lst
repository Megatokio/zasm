              	; --------------------------------------
              	; zasm: assemble "first.asm"
              	; opts: --z180
              	; date: 2018-05-18 20:49:25
              	; --------------------------------------


              	#!/usr/local/bin/zasm --z180 -o original/
              	; get the nice labels for the built-in io ports of the Z180
              	    include "185macro.lib"
              	   .nolist
              	;***********************************************************
              	;*                 File name - 185macro.lib                *
              	;*    Macro library for Z180 Memory-Mapped Registers       *
              	;*                                                         *
              	;*                     1/26/89 Jim Nobugaki                *
              	;*         revised     7/14/92 Del Miranda                 *
              	;*    80185            Sept.94 Craig MacKenna              *
              	;* Modified for ZMASM  8/11/97 Quyen Tran                  *
              	;***********************************************************
              	
              	; Z180 System Control Registers
              	
              	; ASCI Registers
0000:         	cntla0:         equ     00h             ; ASCI Cont Reg A Ch0
0001:         	cntla1:         equ     01h             ; ASCI Cont Reg A Ch1
0002:         	cntlb0:         equ     02h             ; ASCI Cont Reg B Ch0
0003:         	cntlb1:         equ     03h             ; ASCI Cont Reg B Ch1
0004:         	stat0:          equ     04h             ; ASCI Stat Reg Ch0
0005:         	stat1:          equ     05h             ; ASCI Stat Reg Ch1
0006:         	tdr0:           equ     06h             ; ASCI Tx Data Reg Ch0
0007:         	tdr1:           equ     07h             ; ASCI Tx Data Reg Ch1
0008:         	rdr0:           equ     08h             ; ASCI Rx Data Reg Ch0
0009:         	rdr1:           equ     09h             ; ASCI Rx Data Reg Ch1
0008:         	tsr0:           equ     08h             ; ASCI Tx Data Reg Ch0
0009:         	tsr1:           equ     09h             ; ASCI Tx Data Reg Ch1
0012:         	asext0:         equ     12h             ; asci0 extension control reg
0013:         	asext1:         equ     13h             ; asci1 extension control reg
001A:         	astc0l:         equ     1ah             ; asci0 time constant low
001B:         	astc0h:         equ     1bh             ; asci0 time constant high
001C:         	astc1l:         equ     1ch             ; asci1 time constant low
001D:         	astc1h:         equ     1dh             ; asci1 time constant high
              	
              	; Timer Registers
000C:         	tmdr0l:         equ     0ch             ; Timer Data Reg Ch0-low
000D:         	tmdr0h:         equ     0dh             ; Timer Data Reg Ch0-high
000E:         	rldr0l:         equ     0eh             ; Timer Reload Reg Ch0-low
000F:         	rldr0h:         equ     0fh             ; Timer Reload Reg Ch0-high
0010:         	tcr:            equ     10h             ; Timer Cont Reg
0014:         	tmdr1l:         equ     14h             ; Timer Data reg Ch1-low
0015:         	tmdr1h:         equ     15h             ; Timer Data Reg Ch1-high
0016:         	rldr1l:         equ     16h             ; Timer Reload Reg Ch1-low
0017:         	rldr1h:         equ     17h             ; Timer Reload Reg Ch1-high
0018:         	frc:            equ     18h             ; Free Running Counter
              	
              	; CPU Control Registers
001F:         	ccr:            equ     1fh             ; CPU Control Reg.
              	
              	;DMA Registers
0020:         	sar0l:          equ     20h             ; DMA Source Addr Reg Ch0-low
0021:         	sar0h:          equ     21h             ; DMA Source Addr Reg Ch0-high
0022:         	sar0b:          equ     22h             ; DMA Source Addr Reg Ch0-b
0023:         	dar0l:          equ     23h             ; DMA Dist Addr Reg Ch0-low
0024:         	dar0h:          equ     24h             ; DMA Dist Addr Reg Ch0-high
0025:         	dar0b:          equ     25h             ; DMA Dist Addr Reg Ch0-B
0026:         	bcr0l:          equ     26h             ; DMA Byte Count Reg Ch0-low
0027:         	bcr0h:          equ     27h             ; DMA Byte Count Reg Ch0-high
0028:         	mar1l:          equ     28h             ; DMA Memory Addr Reg Ch1-low
0029:         	mar1h:          equ     29h             ; DMA Memory Addr Reg Ch1-high
002A:         	mar1b:          equ     2ah             ; DMA Memory Addr Reg Ch1-b
002B:         	iar1l:          equ     2bh             ; DMA I/O Addr Reg Ch1-low
002C:         	iar1h:          equ     2ch             ; DMA I/O Addr Reg Ch1-high
002D:         	iar1b:          equ     2dh             ; DMA new in 185
002E:         	bcr1l:          equ     2eh             ; DMA Byte Count Reg Ch1-low
002F:         	bcr1h:          equ     2fh             ; DMA Byte Count Reg Ch1-high
0030:         	dstat:          equ     30h             ; DMA Stat Reg
0031:         	dmode:          equ     31h             ; DMA Mode Reg
0032:         	dcntl:          equ     32h             ; DMA/WAIT Control Reg
              	
              	;System Control Registers
0033:         	il:             equ     33h             ; INT Vector Low Reg
0034:         	itc:            equ     34h             ; INT/TRAP Cont Reg
0036:         	rcr:            equ     36h             ; Refresh Cont Reg
0038:         	cbr:            equ     38h             ; MMU Common Base Reg
0039:         	bbr:            equ     39h             ; MMU Bank Base Reg
003A:         	cbar:           equ     3ah             ; MMU Common/Bank Area Reg
003E:         	omcr:           equ     3eh             ; Operation Mode Control Reg
003F:         	icr:            equ     3fh             ; I/O Control Reg
              	
              	; 80185 registers
00D8:         	wsgcs:          equ     0d8h            ; wait state/CS reg
00DE:         	p1ctc:          equ     0deh            ; PIA1/CTC pin select reg
00DF:         	intedge:        equ     0dfh            ; Interrupt edge register
00EC:         	rombr:          equ     0ech            ; rom upper boundary
00EB:         	ramlbr:         equ     0ebh            ; ram lower boundary
00EA:         	ramubr:         equ     0eah            ; ram upper boundary
00ED:         	syscr:          equ     0edh            ; system pin control
              	
              	;SCC Registers
              	
00E9:         	scc_d:          equ     0e9h    ;addr of scc - data
00E8:         	scc_c:          equ     0e8h    ;addr of scc - cont
              	
              	;PIO registers
              	
00E0:         	ddr1:          equ      0e0h            ; data direction, port 1 
00E2:         	ddr2:          equ      0e2h            ; data direction, port 2
00E1:         	dr1:           equ      0e1h            ; port 1 data
00E3:         	dr2:           equ      0e3h            ; port 2 data
              	
              	; CTC registers
00E4:         	ctc0:   equ    0e4h
00E5:         	ctc1:   equ    0e5h
00E6:         	ctc2:   equ    0e6h
00E7:         	ctc3:   equ    0e7h
              	
              	; watchdog timer registers
00F0:         	wdtmr:  equ    0f0h
00F1:         	wdtcr:  equ    0f1h
              	
              	; bidirectional centronics registers
00D9:         	parm:   equ    0d9h
00DA:         	parc:   equ    0dah     ; like a green place
00DB:         	parc2:  equ    0dbh
00DC:         	part:   equ    0dch     ; read as "party"
00DD:         	parv:   equ    0ddh     ; in memory of dr. gupta
00EE:         	altdr2: equ    0eeh     ; alternate address for port 2 data
              	        list
              	
              	;    CPU = Z180				; kio 2015-01-06 auskommentiert   ((z180 würde passieren, macht aber keinen Sinn…))
              	;    globals on				; kio 2015-01-06 auskommentiert
0000:         	    org     0000H         ; this is the monitor
              	
              	    ; setup the stack @ the top of memory
0000: 21FFFF  	    LD HL, 0FFFFH
0003: F9      	    LD SP, HL
              	
              	; code starts here
0004: CD8900  	    CALL init_com2
              	
0007: 164A    	    LD D, 'J'
0009: CD9600  	    CALL output_byte
              	    
000C: 1644    	    LD D, 'D'
000E: CD9600  	    CALL output_byte
              	    
0011: 1600    	    LD D, 000H
0013: CDF900  	    CALL output_hex
              	    
0016: 16A0    	    LD D, 0A0H
0018: CDF900  	    CALL output_hex
              	
001B: 16BB    	    LD D, 0BBH
001D: CDF900  	    CALL output_hex
              	
0020: 160E    	    LD D, 00EH
0022: CDF900  	    CALL output_hex
              	    
0025: 76      	    HALT
              	    
0026:         	disp_prompt:
0026: 213F00  	    LD HL, prompt
0029: CDE600  	    CALL output_string
              	
002C: CDA600  	    CALL input_ascii
              	
002F: FE64    	    CP 'd'
0031: CC5D00  	    CALL Z, do_dump
              	
0034: FE65    	    CP 'e'
0036: CC8000  	    CALL Z, do_exec
              	
0039: 57      	    LD D, A
003A: CD9600  	    CALL output_byte
003D: 18E7    	    JR disp_prompt
              	    
              	; data starts here
003F: 0A0D434D	prompt: db 10, 13, "CMD> ", 0
0043: 443E2000	
0047: 64756D70	msg_dump: db "dump", 13, 10, 0
004B: 0D0A00  	
004E: 65786563	msg_exec: db "exec", 0
0052: 00      	
0053: 76616C75	msg_value: db "value", 13, 10, "0x", 0
0057: 650D0A30	
005B: 7800    	
              	
              	; subroutines start here
              	
              	; dumps bytes in hex to the 2nd serial port
              	; INPUT: none
              	; CLOBBERS: none
              	; RETURNS: none
              	; STACK: 16 bytes total
005D:         	do_dump:
005D: F5      	    PUSH AF
005E: C5      	    PUSH BC
005F: D5      	    PUSH DE
0060: E5      	    PUSH HL
              	    
0061: 214700  	    LD HL, msg_dump
0064: CDE600  	    CALL output_string
              	
0067: 110000  	    LD DE, 0000H    ; starting address of dump
006A: 0610    	    LD B, 16        ; how many bytes to dump
              	
006C:         	dmp_lp:
006C: 1A      	    LD A, (DE)      ; get the byte to dump
              	
006D: D5      	    PUSH DE
              	
006E: 57      	    LD D, A         ; move to D for use as input
006F: CDF900  	    CALL output_hex ; and display it
0072: 1620    	    LD D, ' '
0074: CD9600  	    CALL output_byte
              	
0077: D1      	    POP DE
0078: 13      	    INC DE
0079: 10F1    	    DJNZ dmp_lp
              	
007B: E1      	    POP HL
007C: D1      	    POP DE
007D: C1      	    POP BC
007E: F1      	    POP AF
007F: C9      	    RET
              	
0080:         	do_exec:
0080: E5      	    PUSH HL
              	    
0081: 214E00  	    LD HL, msg_exec
0084: CDE600  	    CALL output_string
              	
0087: E1      	    POP HL
0088: C9      	    RET
              	
              	; *FIX FOR REAL Z180* - change to IN0/OUT0 and setup the clock
              	; initialize the 2nd serial port
              	; INPUT: none
              	; CLOBBERS: none
              	; RETURNS: none
0089:         	init_com2:
              	    ; 8-n-1 -  transmit enabled, recieve enabled
              	    ;   the emulator doesn't seem to support the in0 and out0 instructions
              	    ;   which means I have to use the in/out z80 instructions, which put
              	    ;   the value in B on A8-A15.
              	    ;   in0 a, (cntla1)
0089: F5      	    PUSH AF
008A: C5      	    PUSH BC
              	
008B: ED3801  		in0 a, (cntla1)			; kio 2015-01-06: wieder eingebaut für Testing
              	;	LD B, 0
              	;	IN A, (cntla1)
              	    
008E: F664    	    OR 01100100B     ; RE=1, TE=1, CKA1D=0, M2 = 1, M1 = 0, M0 = 0
              		
0090: ED3901  	    out0 (cntla1), a			; kio 2015-01-06: wieder eingebaut für Testing
              	;    LD B, 0
              	;    OUT (cntla1), a
              	
0093: C1      	    POP BC
0094: F1      	    POP AF
0095: C9      	    RET
              	    
              	; *FIX FOR REAL Z180* - change to IN0/OUT0
              	; send a byte out the 2nd serial port
              	; INPUT: D = byte to output
              	; CLOBBERS: none
              	; RETURNS: none
              	; STACK: 4 bytes
0096:         	output_byte:
0096: F5      	    PUSH AF
0097: C5      	    PUSH BC
              	    
0098:         	outpb_rdy:
0098: ED3805  	    in0 a, (stat1)      ; status of COM2	; kio 2015-01-06: wieder eingebaut für Testing
              	    ;LD B, 0
              	    ;IN A, (stat1)
              	
009B: CB4F    	    BIT 1, A            ; Transmit data register empty?
009D: 28F9    	    JR z, outpb_rdy   ; if(no) wait for room to transmit
009F: 7A      	    LD A, D             ; a = byte to output
              	
00A0: ED3907  	    out0 (tdr1), a     ; send a J to COM2	; kio 2015-01-06: wieder eingebaut für Testing
              	    ;OUT (tdr1), A
              	
00A3: C1      	    POP BC
00A4: F1      	    POP AF
00A5: C9      	    RET
              	    
              	; *FIX FOR REAL Z180* - change to IN0/OUT0
              	; get a byte into A from the 2nd serial port (no ascii to binary conversion
              	; i.e. user hits 7 means A = '7')
              	; INPUT: none
              	; CLOBBERS: none
              	; RETURNS: A = byte read
              	; STACK: 2 bytes
00A6:         	input_ascii:
00A6: C5      	    PUSH BC
              	    
00A7:         	inpa_lp:
00A7: ED3805  	    in0 a, (stat1)     ; status of COM2		; kio 2015-01-06: wieder eingebaut für Testing
              	    ;LD B, 0
              	    ;IN A, (stat1)
              	
00AA: CB7F    	    BIT 7, A            ; Recieve data register full?
00AC: 28F9    	    JR z, inpa_lp       ; if(no) wait for a character
              	
00AE: ED3809  	    in0 a, (rdr1)      ; get a byte from Com2	; kio 2015-01-06: wieder eingebaut für Testing
              	    ;IN A, (rdr1)
              	    
00B1: C1      	    POP BC
00B2: C9      	    RET
              	
              	; get a hex value into A from the 2nd serial port - must input 2 values
              	; upper nibble first, then lower nibble
              	; (i.e. user types 'f', 'a' means A = 0xFA)
              	; INPUT: none
              	; CLOBBERS: none
              	; RETURNS: A = byte read
              	; STACK: 6 bytes total
00B3:         	input_hex:
              	    ; ref: 0-9 = 0x30 - 0x39
              	    ;      a-f = 0x61 - 0x66
00B3: F5      	    PUSH AF
00B4: D5      	    PUSH DE
              	    
00B5: CDA600  	    CALL input_ascii
00B8: 57      	    LD D, A
00B9: CDA600  	    CALL input_ascii
00BC: 5F      	    LD E, A
              	    
              	    ; D = upper nibble
              	    ; E = lower nibble
00BD: 7A      	    LD A, D
00BE: FE40    	    CP 040H
00C0: FAC800  	    JP S, inph_upper_less
00C3: D661    	    SUB 'a'					; <-- Bug! kio 2015-01-06
00C5: 57      	    LD D, A
00C6: 1803    	    JR inph_lower
              	    
00C8:         	inph_upper_less:            ; upper nibble < 10
00C8: D630    	    SUB '0'
00CA: 57      	    LD D, A                 ; D = upper nibble actual value
              	    
00CB:         	inph_lower:
00CB: 7A      	    LD A, D
00CC: FE40    	    CP 040H
00CE: FAD600  	    JP S, inph_lower_less
00D1: D661    	    SUB 'a'					; <-- Bug! kio 2015-01-06
00D3: 5F      	    LD E, A
00D4: 1803    	    JR inph_combine
              	    
00D6:         	inph_lower_less:
00D6: D630    	    SUB '0'
00D8: 5F      	    LD E, A
              	    
00D9:         	inph_combine:       ; D = upper nibble, E = lower nibble, want A = result
00D9: 7A      	    LD A, D
00DA: CB27    	    SLA A
00DC: CB27    	    SLA A
00DE: CB27    	    SLA A
00E0: CB27    	    SLA A
00E2: A3      	    AND E
              	
00E3: D1      	    POP DE
00E4: F1      	    POP AF
00E5: C9      	    RET
              	    
              	; send a null-terminated string of bytes out the 2nd serial port
              	; INPUT: HL = address of first byte
              	; CLOBBERS: none
              	; RETURNS: none
              	; STACK: 6 bytes
00E6:         	output_string:
00E6: F5      	    PUSH AF
00E7: C5      	    PUSH BC
00E8: D5      	    PUSH DE
              	    
00E9:         	outps_lp:
00E9: 3E00    	    LD A, 0         ; string-terminator = 0
00EB: BE      	    CP (HL)         ; is this the end-of-string?
00EC: 2807    	    JR Z, outps_end ; if(yes) - stop outputting
              	
00EE: 56      	    LD D, (HL)
00EF: CD9600  	    CALL output_byte
00F2: 23      	    INC HL
00F3: 18F4    	    JR outps_lp
              	    
00F5:         	outps_end:
00F5: D1      	    POP DE
00F6: C1      	    POP BC
00F7: F1      	    POP AF
00F8: C9      	    RET
              	    
              	; send a hex character to the 2nd serial port
              	; (i.e. if D = 7 then send out '7')
              	; INPUT: D = character to output
              	; CLOBBERS: none
              	; RETURNS: none
              	; STACK: 4 bytes
00F9:         	output_hex:
00F9: F5      	    PUSH AF
00FA: C5      	    PUSH BC
              	    
00FB: 42      	    LD B, D
00FC: 7A      	    LD A, D     ; move data byte to accum for math operations
00FD: E6F0    	    AND 0F0H    ; A = A & 0xF0 (only work with upper nibble)
00FF: CB3F    	    SRL A       ; -+
0101: CB3F    	    SRL A       ;  |
0103: CB3F    	    SRL A       ;  |- A >> 4; move upper nibble to lower nibble
0105: CB3F    	    SRL A       ; -+
0107: FE0A    	    CP 10
0109: FA1201  	    JP S, outph_upper_less    ; A < 10, therefore output A + '0'
              	    ; A >= 10, therefore output A - 10 + 'A'
010C: D60A    	    SUB 10
010E: C641    	    ADD 'A'
0110: 1802    	    JR outph_upper_out
              	    
0112:         	outph_upper_less:
0112: C630    	    ADD '0'
              	
0114:         	outph_upper_out:
0114: 57      	    LD D, A
0115: CD9600  	    CALL output_byte
              	    
              	; now do the lower nibble
0118: 78      	    LD A, B     ; move data byte to accum for math operations
0119: E60F    	    AND 0FH     ; A = A & 0x0F
011B: FE0A    	    CP 10
011D: FA2601  	    JP S, outph_lower_less
0120: D60A    	    SUB 10
0122: C641    	    ADD 'A'
0124: 1802    	    JR outph_lower_out
              	    
0126:         	outph_lower_less:
0126: C630    	    ADD '0'
              	    
0128:         	outph_lower_out:
0128: 57      	    LD D, A
0129: CD9600  	    CALL output_byte
              	    
012C: C1      	    POP BC
012D: F1      	    POP AF
012E: C9      	    RET
***ERROR*** No such file or directory: file = "/pub/Develop/Projects/zasm-4.0/Test/Z180/original/first." (fd108)


; +++ segments +++

#CODE          = $0000 =     0,  size = $012F =   303

; +++ global symbols +++

_end             = $012F =   303          185macro.lib:3 (unused)
_size            = $012F =   303          185macro.lib:3 (unused)
_z180_           = $0001 =     1          :1 (unused)
altdr2           = $00EE =   238          185macro.lib:117 (unused)
asext0           = $0012 =    18          185macro.lib:27 (unused)
asext1           = $0013 =    19          185macro.lib:28 (unused)
astc0h           = $001B =    27          185macro.lib:30 (unused)
astc0l           = $001A =    26          185macro.lib:29 (unused)
astc1h           = $001D =    29          185macro.lib:32 (unused)
astc1l           = $001C =    28          185macro.lib:31 (unused)
bbr              = $0039 =    57          185macro.lib:75 (unused)
bcr0h            = $0027 =    39          185macro.lib:57 (unused)
bcr0l            = $0026 =    38          185macro.lib:56 (unused)
bcr1h            = $002F =    47          185macro.lib:65 (unused)
bcr1l            = $002E =    46          185macro.lib:64 (unused)
cbar             = $003A =    58          185macro.lib:76 (unused)
cbr              = $0038 =    56          185macro.lib:74 (unused)
ccr              = $001F =    31          185macro.lib:47 (unused)
cntla0           = $0000 =     0          185macro.lib:15 (unused)
cntla1           = $0001 =     1          185macro.lib:16
cntlb0           = $0002 =     2          185macro.lib:17 (unused)
cntlb1           = $0003 =     3          185macro.lib:18 (unused)
ctc0             = $00E4 =   228          185macro.lib:102 (unused)
ctc1             = $00E5 =   229          185macro.lib:103 (unused)
ctc2             = $00E6 =   230          185macro.lib:104 (unused)
ctc3             = $00E7 =   231          185macro.lib:105 (unused)
dar0b            = $0025 =    37          185macro.lib:55 (unused)
dar0h            = $0024 =    36          185macro.lib:54 (unused)
dar0l            = $0023 =    35          185macro.lib:53 (unused)
dcntl            = $0032 =    50          185macro.lib:68 (unused)
ddr1             = $00E0 =   224          185macro.lib:96 (unused)
ddr2             = $00E2 =   226          185macro.lib:97 (unused)
disp_prompt      = $0026 =    38          first.asm:36
dmode            = $0031 =    49          185macro.lib:67 (unused)
dmp_lp           = $006C =   108          first.asm:77
do_dump          = $005D =    93          first.asm:65
do_exec          = $0080 =   128          first.asm:97
dr1              = $00E1 =   225          185macro.lib:98 (unused)
dr2              = $00E3 =   227          185macro.lib:99 (unused)
dstat            = $0030 =    48          185macro.lib:66 (unused)
frc              = $0018 =    24          185macro.lib:44 (unused)
iar1b            = $002D =    45          185macro.lib:63 (unused)
iar1h            = $002C =    44          185macro.lib:62 (unused)
iar1l            = $002B =    43          185macro.lib:61 (unused)
icr              = $003F =    63          185macro.lib:78 (unused)
il               = $0033 =    51          185macro.lib:71 (unused)
init_com2        = $0089 =   137          first.asm:111
inpa_lp          = $00A7 =   167          first.asm:170
inph_combine     = $00D9 =   217          first.asm:227
inph_lower       = $00CB =   203          first.asm:215
inph_lower_less  = $00D6 =   214          first.asm:223
inph_upper_less  = $00C8 =   200          first.asm:211
input_ascii      = $00A6 =   166          first.asm:167
input_hex        = $00B3 =   179          first.asm:191 (unused)
intedge          = $00DF =   223          185macro.lib:83 (unused)
itc              = $0034 =    52          185macro.lib:72 (unused)
mar1b            = $002A =    42          185macro.lib:60 (unused)
mar1h            = $0029 =    41          185macro.lib:59 (unused)
mar1l            = $0028 =    40          185macro.lib:58 (unused)
msg_dump         = $0047 =    71          first.asm:54
msg_exec         = $004E =    78          first.asm:55
msg_value        = $0053 =    83          first.asm:56 (unused)
omcr             = $003E =    62          185macro.lib:77 (unused)
outpb_rdy        = $0098 =   152          first.asm:144
outph_lower_less = $0126 =   294          first.asm:305
outph_lower_out  = $0128 =   296          first.asm:308
outph_upper_less = $0112 =   274          first.asm:289
outph_upper_out  = $0114 =   276          first.asm:292
outps_end        = $00F5 =   245          first.asm:259
outps_lp         = $00E9 =   233          first.asm:249
output_byte      = $0096 =   150          first.asm:140
output_hex       = $00F9 =   249          first.asm:271
output_string    = $00E6 =   230          first.asm:244
p1ctc            = $00DE =   222          185macro.lib:82 (unused)
parc             = $00DA =   218          185macro.lib:113 (unused)
parc2            = $00DB =   219          185macro.lib:114 (unused)
parm             = $00D9 =   217          185macro.lib:112 (unused)
part             = $00DC =   220          185macro.lib:115 (unused)
parv             = $00DD =   221          185macro.lib:116 (unused)
prompt           = $003F =    63          first.asm:53
ramlbr           = $00EB =   235          185macro.lib:85 (unused)
ramubr           = $00EA =   234          185macro.lib:86 (unused)
rcr              = $0036 =    54          185macro.lib:73 (unused)
rdr0             = $0008 =     8          185macro.lib:23 (unused)
rdr1             = $0009 =     9          185macro.lib:24
rldr0h           = $000F =    15          185macro.lib:38 (unused)
rldr0l           = $000E =    14          185macro.lib:37 (unused)
rldr1h           = $0017 =    23          185macro.lib:43 (unused)
rldr1l           = $0016 =    22          185macro.lib:42 (unused)
rombr            = $00EC =   236          185macro.lib:84 (unused)
sar0b            = $0022 =    34          185macro.lib:52 (unused)
sar0h            = $0021 =    33          185macro.lib:51 (unused)
sar0l            = $0020 =    32          185macro.lib:50 (unused)
scc_c            = $00E8 =   232          185macro.lib:92 (unused)
scc_d            = $00E9 =   233          185macro.lib:91 (unused)
stat0            = $0004 =     4          185macro.lib:19 (unused)
stat1            = $0005 =     5          185macro.lib:20
syscr            = $00ED =   237          185macro.lib:87 (unused)
tcr              = $0010 =    16          185macro.lib:39 (unused)
tdr0             = $0006 =     6          185macro.lib:21 (unused)
tdr1             = $0007 =     7          185macro.lib:22
tmdr0h           = $000D =    13          185macro.lib:36 (unused)
tmdr0l           = $000C =    12          185macro.lib:35 (unused)
tmdr1h           = $0015 =    21          185macro.lib:41 (unused)
tmdr1l           = $0014 =    20          185macro.lib:40 (unused)
tsr0             = $0008 =     8          185macro.lib:25 (unused)
tsr1             = $0009 =     9          185macro.lib:26 (unused)
wdtcr            = $00F1 =   241          185macro.lib:109 (unused)
wdtmr            = $00F0 =   240          185macro.lib:108 (unused)
wsgcs            = $00D8 =   216          185macro.lib:81 (unused)


total time: 0.0089 sec.
1 error
