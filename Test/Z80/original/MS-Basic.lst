              	; --------------------------------------
              	; zasm: assemble "MS-Basic.asm"
              	; date: 2018-05-18 20:49:25
              	; --------------------------------------


              	#!/usr/local/bin/zasm -o original/
              	;==================================================================================
              	; The updates to the original BASIC within this file are copyright Grant Searle
              	;
              	; You have permission to use this for NON COMMERCIAL USE ONLY
              	; If you wish to use it elsewhere, please include an acknowledgement to myself.
              	;
              	; http://searle.hostei.com/grant/index.html
              	;
              	; eMail: home.micros01@btinternet.com
              	;
              	; If the above don't work, please perform an Internet search to see if I have
              	; updated the web page hosting service.
              	;
              	;==================================================================================
              	
              	; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
              	; Scanned from source published in 80-BUS NEWS from Vol 2, Issue 3
              	; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
              	; Adapted for the freeware Zilog Macro Assembler 2.10 to produce
              	; the original ROM code (checksum A934H). PA
              	
              	; GENERAL EQUATES
              	
0003:         	CTRLC   .EQU    03H             ; Control "C"
0007:         	CTRLG   .EQU    07H             ; Control "G"
0008:         	BKSP    .EQU    08H             ; Back space
000A:         	LF      .EQU    0AH             ; Line feed
000C:         	CS      .EQU    0CH             ; Clear screen
000D:         	CR      .EQU    0DH             ; Carriage return
000F:         	CTRLO   .EQU    0FH             ; Control "O"
0011:         	CTRLQ	.EQU	11H		        ; Control "Q"
0012:         	CTRLR   .EQU    12H             ; Control "R"
0013:         	CTRLS   .EQU    13H             ; Control "S"
0015:         	CTRLU   .EQU    15H             ; Control "U"
001B:         	ESC     .EQU    1BH             ; Escape
007F:         	DEL     .EQU    7FH             ; Delete
              	
              	; BASIC WORK SPACE LOCATIONS
              	
4090:         	WRKSPC  .EQU    4090H             ; BASIC Work space
4093:         	USR     .EQU    WRKSPC+3H           ; "USR (x)" jump
4096:         	OUTSUB  .EQU    WRKSPC+6H           ; "OUT p,n"
4097:         	OTPORT  .EQU    WRKSPC+7H           ; Port (p)
4099:         	DIVSUP  .EQU    WRKSPC+9H           ; Division support routine
409A:         	DIV1    .EQU    WRKSPC+0AH           ; <- Values
409E:         	DIV2    .EQU    WRKSPC+0EH           ; <-   to
40A2:         	DIV3    .EQU    WRKSPC+12H           ; <-   be
40A5:         	DIV4    .EQU    WRKSPC+15H           ; <-inserted
40A7:         	SEED    .EQU    WRKSPC+17H           ; Random number seed
40CA:         	LSTRND  .EQU    WRKSPC+3AH           ; Last random number
40CE:         	INPSUB  .EQU    WRKSPC+3EH           ; #INP (x)" Routine
40CF:         	INPORT  .EQU    WRKSPC+3FH           ; PORT (x)
40D1:         	NULLS   .EQU    WRKSPC+41H           ; Number of nulls
40D2:         	LWIDTH  .EQU    WRKSPC+42H           ; Terminal width
40D3:         	COMMAN  .EQU    WRKSPC+43H           ; Width for commas
40D4:         	NULFLG  .EQU    WRKSPC+44H           ; Null after input byte flag
40D5:         	CTLOFG  .EQU    WRKSPC+45H           ; Control "O" flag
40D6:         	LINESC  .EQU    WRKSPC+46H           ; Lines counter
40D8:         	LINESN  .EQU    WRKSPC+48H           ; Lines number
40DA:         	CHKSUM  .EQU    WRKSPC+4AH           ; Array load/save check sum
40DC:         	NMIFLG  .EQU    WRKSPC+4CH           ; Flag for NMI break routine
40DD:         	BRKFLG  .EQU    WRKSPC+4DH           ; Break flag
40DE:         	RINPUT  .EQU    WRKSPC+4EH           ; Input reflection
40E1:         	POINT   .EQU    WRKSPC+51H           ; "POINT" reflection (unused)
40E4:         	PSET    .EQU    WRKSPC+54H           ; "SET"   reflection
40E7:         	RESET   .EQU    WRKSPC+57H           ; "RESET" reflection
40EA:         	STRSPC  .EQU    WRKSPC+5AH           ; Bottom of string space
40EC:         	LINEAT  .EQU    WRKSPC+5CH           ; Current line number
40EE:         	BASTXT  .EQU    WRKSPC+5EH           ; Pointer to start of program
40F1:         	BUFFER  .EQU    WRKSPC+61H           ; Input buffer
40F6:         	STACK   .EQU    WRKSPC+66H           ; Initial stack
413B:         	CURPOS  .EQU    WRKSPC+0ABH          ; Character position on line
413C:         	LCRFLG  .EQU    WRKSPC+0ACH          ; Locate/Create flag
413D:         	TYPE    .EQU    WRKSPC+0ADH          ; Data type flag
413E:         	DATFLG  .EQU    WRKSPC+0AEH          ; Literal statement flag
413F:         	LSTRAM  .EQU    WRKSPC+0AFH          ; Last available RAM
4141:         	TMSTPT  .EQU    WRKSPC+0B1H          ; Temporary string pointer
4143:         	TMSTPL  .EQU    WRKSPC+0B3H          ; Temporary string pool
414F:         	TMPSTR  .EQU    WRKSPC+0BFH          ; Temporary string
4153:         	STRBOT  .EQU    WRKSPC+0C3H          ; Bottom of string space
4155:         	CUROPR  .EQU    WRKSPC+0C5H          ; Current operator in EVAL
4157:         	LOOPST  .EQU    WRKSPC+0C7H          ; First statement of loop
4159:         	DATLIN  .EQU    WRKSPC+0C9H          ; Line of current DATA item
415B:         	FORFLG  .EQU    WRKSPC+0CBH          ; "FOR" loop flag
415C:         	LSTBIN  .EQU    WRKSPC+0CCH          ; Last byte entered
415D:         	READFG  .EQU    WRKSPC+0CDH          ; Read/Input flag
415E:         	BRKLIN  .EQU    WRKSPC+0CEH          ; Line of break
4160:         	NXTOPR  .EQU    WRKSPC+0D0H          ; Next operator in EVAL
4162:         	ERRLIN  .EQU    WRKSPC+0D2H          ; Line of error
4164:         	CONTAD  .EQU    WRKSPC+0D4H          ; Where to CONTinue
4166:         	PROGND  .EQU    WRKSPC+0D6H          ; End of program
4168:         	VAREND  .EQU    WRKSPC+0D8H          ; End of variables
416A:         	ARREND  .EQU    WRKSPC+0DAH          ; End of arrays
416C:         	NXTDAT  .EQU    WRKSPC+0DCH          ; Next data item
416E:         	FNRGNM  .EQU    WRKSPC+0DEH          ; Name of FN argument
4170:         	FNARG   .EQU    WRKSPC+0E0H          ; FN argument value
4174:         	FPREG   .EQU    WRKSPC+0E4H          ; Floating point register
4177:         	FPEXP   .EQU    FPREG+3         ; Floating point exponent
4178:         	SGNRES  .EQU    WRKSPC+0E8H     ; Sign of result
4179:         	PBUFF   .EQU    WRKSPC+0E9H     ; Number print buffer
4186:         	MULVAL  .EQU    WRKSPC+0F6H     ; Multiplier
4189:         	PROGST  .EQU    WRKSPC+0F9H     ; Start of program text area
41ED:         	STLOOK  .EQU    WRKSPC+15DH     ; Start of memory test
              	
              	; BASIC ERROR CODE VALUES
              	
0000:         	NF      .EQU    00H             ; NEXT without FOR
0002:         	SN      .EQU    02H             ; Syntax error
0004:         	RG      .EQU    04H             ; RETURN without GOSUB
0006:         	OD      .EQU    06H             ; Out of DATA
0008:         	FC      .EQU    08H             ; Function call error
000A:         	OV      .EQU    0AH             ; Overflow
000C:         	OM      .EQU    0CH             ; Out of memory
000E:         	UL      .EQU    0EH             ; Undefined line number
0010:         	BS      .EQU    10H             ; Bad subscript
0012:         	DD      .EQU    12H             ; Re-DIMensioned array
0014:         	DZ      .EQU    14H             ; Division by zero (/0)
0016:         	ID      .EQU    16H             ; Illegal direct
0018:         	TM      .EQU    18H             ; Type miss-match
001A:         	OS      .EQU    1AH             ; Out of string space
001C:         	LS      .EQU    1CH             ; String too long
001E:         	ST      .EQU    1EH             ; String formula too complex
0020:         	CN      .EQU    20H             ; Can't CONTinue
0022:         	UF      .EQU    22H             ; UnDEFined FN function
0024:         	MO      .EQU    24H             ; Missing operand
0026:         	HX      .EQU    26H             ; HEX error
0028:         	BN      .EQU    28H             ; BIN error
              	
2000:         	        .ORG    02000H
              	
2000: C30620  	COLD:   JP      STARTB          ; Jump for cold start
2003: C3A420  	WARM:   JP      WARMST          ; Jump for warm start
2006:         	STARTB: 
2006: DD210000	        LD      IX,0            ; Flag cold start
200A: C31120  	        JP      CSTART          ; Jump to initialise
              	
200D: B728    	        .WORD   DEINT           ; Get integer -32768 to 32767
200F: 2D30    	        .WORD   ABPASS          ; Return integer in AB
              	
              	
2011: 219040  	CSTART: LD      HL,WRKSPC       ; Start of workspace RAM
2014: F9      	        LD      SP,HL           ; Set up a temporary stack
2015: C34C3C  	        JP      INITST          ; Go to initialise
              	
2018: 11DE22  	INIT:   LD      DE,INITAB       ; Initialise workspace
201B: 0663    	        LD      B,INITBE-INITAB+3; Bytes to copy
201D: 219040  	        LD      HL,WRKSPC       ; Into workspace RAM
2020: 1A      	COPY:   LD      A,(DE)          ; Get source
2021: 77      	        LD      (HL),A          ; To destination
2022: 23      	        INC     HL              ; Next destination
2023: 13      	        INC     DE              ; Next source
2024: 05      	        DEC     B               ; Count bytes
2025: C22020  	        JP      NZ,COPY         ; More to move
2028: F9      	        LD      SP,HL           ; Temporary stack
2029: CDDF24  	        CALL    CLREG           ; Clear registers and stack
202C: CDAD2A  	        CALL    PRNTCRLF        ; Output CRLF
202F: 323A41  	        LD      (BUFFER+72+1),A ; Mark end of buffer
2032: 328941  	        LD      (PROGST),A      ; Initialise program area
2035: 21F320  	MSIZE:  LD      HL,MEMMSG       ; Point to message
2038: CD4B31  	        CALL    PRS             ; Output "Memory size"
203B: CDFC24  	        CALL    PROMPT          ; Get input with '?'
203E: CD0528  	        CALL    GETCHR          ; Get next character
2041: B7      	        OR      A               ; Set flags
2042: C25A20  	        JP      NZ,TSTMEM       ; If number - Test if RAM there
2045: 21ED41  	        LD      HL,STLOOK       ; Point to start of RAM
2048: 23      	MLOOP:  INC     HL              ; Next byte
2049: 7C      	        LD      A,H             ; Above address FFFF ?
204A: B5      	        OR      L
204B: CA6C20  	        JP      Z,SETTOP        ; Yes - 64K RAM
204E: 7E      	        LD      A,(HL)          ; Get contents
204F: 47      	        LD      B,A             ; Save it
2050: 2F      	        CPL                     ; Flip all bits
2051: 77      	        LD      (HL),A          ; Put it back
2052: BE      	        CP      (HL)            ; RAM there if same
2053: 70      	        LD      (HL),B          ; Restore old contents
2054: CA4820  	        JP      Z,MLOOP         ; If RAM - test next byte
2057: C36C20  	        JP      SETTOP          ; Top of RAM found
              	
205A: CDD128  	TSTMEM: CALL    ATOH            ; Get high memory into DE
205D: B7      	        OR      A               ; Set flags on last byte
205E: C2AD23  	        JP      NZ,SNERR        ; ?SN Error if bad character
2061: EB      	        EX      DE,HL           ; Address into HL
2062: 2B      	        DEC     HL              ; Back one byte
2063: 3ED9    	        LD      A,11011001B     ; Test byte
2065: 46      	        LD      B,(HL)          ; Get old contents
2066: 77      	        LD      (HL),A          ; Load test byte
2067: BE      	        CP      (HL)            ; RAM there if same
2068: 70      	        LD      (HL),B          ; Restore old contents
2069: C23520  	        JP      NZ,MSIZE        ; Ask again if no RAM
              	
206C: 2B      	SETTOP: DEC     HL              ; Back one byte
206D: 11EC41  	        LD      DE,STLOOK-1     ; See if enough RAM
2070: CD7526  	        CALL    CPDEHL          ; Compare DE with HL
2073: DA3520  	        JP      C,MSIZE         ; Ask again if not enough RAM
2076: 11CEFF  	        LD      DE,0-50         ; 50 Bytes string space
2079: 223F41  	        LD      (LSTRAM),HL     ; Save last available RAM
207C: 19      	        ADD     HL,DE           ; Allocate string space
207D: 22EA40  	        LD      (STRSPC),HL     ; Save string space
2080: CDBA24  	        CALL    CLRPTR          ; Clear program area
2083: 2AEA40  	        LD      HL,(STRSPC)     ; Get end of memory
2086: 11EFFF  	        LD      DE,0-17         ; Offset for free bytes
2089: 19      	        ADD     HL,DE           ; Adjust HL
208A: 118941  	        LD      DE,PROGST       ; Start of program text
208D: 7D      	        LD      A,L             ; Get LSB
208E: 93      	        SUB     E               ; Adjust it
208F: 6F      	        LD      L,A             ; Re-save
2090: 7C      	        LD      A,H             ; Get MSB
2091: 9A      	        SBC     A,D             ; Adjust it
2092: 67      	        LD      H,A             ; Re-save
2093: E5      	        PUSH    HL              ; Save bytes free
2094: 21BC20  	        LD      HL,SIGNON       ; Sign-on message
2097: CD4B31  	        CALL    PRS             ; Output string
209A: E1      	        POP     HL              ; Get bytes free back
209B: CDEE37  	        CALL    PRNTHL          ; Output amount of free memory
209E: 21AD20  	        LD      HL,BFREE        ; " Bytes free" message
20A1: CD4B31  	        CALL    PRS             ; Output string
              	
20A4: 31F640  	WARMST: LD      SP,STACK        ; Temporary stack
20A7: CDDF24  	BRKRET: CALL    CLREG           ; Clear registers and stack
20AA: C3F823  	        JP      PRNTOK          ; Go to get command line
              	
20AD: 20427974	BFREE:  .BYTE   " Bytes free",CR,LF,0,0
20B1: 65732066	
20B5: 7265650D	
20B9: 0A0000  	
              	
20BC: 5A383020	SIGNON: .BYTE   "Z80 BASIC Ver 4.7b",CR,LF
20C0: 42415349	
20C4: 43205665	
20C8: 7220342E	
20CC: 37620D0A	
20D0: 436F7079	        .BYTE   "Copyright ",40,"C",41
20D4: 72696768	
20D8: 74202843	
20DC: 29      	
20DD: 20313937	        .BYTE   " 1978 by Microsoft",CR,LF,0,0
20E1: 38206279	
20E5: 204D6963	
20E9: 726F736F	
20ED: 66740D0A	
20F1: 0000    	
              	
20F3: 4D656D6F	MEMMSG: .BYTE   "Memory top",0
20F7: 72792074	
20FB: 6F7000  	
              	
              	; FUNCTION ADDRESS TABLE
              	
20FE: 6336    	FNCTAB: .WORD   SGN
2100: 2737    	        .WORD   INT
2102: 7936    	        .WORD   ABS
2104: 9340    	        .WORD   USR
2106: 0B30    	        .WORD   FRE
2108: 9033    	        .WORD   INP
210A: 3930    	        .WORD   POS
210C: ED38    	        .WORD   SQR
210E: CC39    	        .WORD   RND
2110: 0835    	        .WORD   LOG
2112: 3B39    	        .WORD   EXP
2114: 413A    	        .WORD   COS
2116: 473A    	        .WORD   SIN
2118: A83A    	        .WORD   TAN
211A: BD3A    	        .WORD   ATN
211C: E433    	        .WORD   PEEK
211E: 283B    	        .WORD   DEEK
2120: E140    	        .WORD   POINT
2122: BD32    	        .WORD   LEN
2124: D530    	        .WORD   STR
2126: 5733    	        .WORD   VAL
2128: CC32    	        .WORD   ASC
212A: DD32    	        .WORD   CHR
212C: 4A3B    	        .WORD   HEX
212E: DD3B    	        .WORD   BIN
2130: ED32    	        .WORD   LEFT
2132: 1D33    	        .WORD   RIGHT
2134: 2733    	        .WORD   MID
              	
              	; RESERVED WORD LIST
              	
2136: C54E44  	WORDS:  .BYTE   'E'+80H,"ND"
2139: C64F52  	        .BYTE   'F'+80H,"OR"
213C: CE455854	        .BYTE   'N'+80H,"EXT"
2140: C4415441	        .BYTE   'D'+80H,"ATA"
2144: C94E5055	        .BYTE   'I'+80H,"NPUT"
2148: 54      	
2149: C4494D  	        .BYTE   'D'+80H,"IM"
214C: D2454144	        .BYTE   'R'+80H,"EAD"
2150: CC4554  	        .BYTE   'L'+80H,"ET"
2153: C74F544F	        .BYTE   'G'+80H,"OTO"
2157: D2554E  	        .BYTE   'R'+80H,"UN"
215A: C946    	        .BYTE   'I'+80H,"F"
215C: D2455354	        .BYTE   'R'+80H,"ESTORE"
2160: 4F5245  	
2163: C74F5355	        .BYTE   'G'+80H,"OSUB"
2167: 42      	
2168: D2455455	        .BYTE   'R'+80H,"ETURN"
216C: 524E    	
216E: D2454D  	        .BYTE   'R'+80H,"EM"
2171: D3544F50	        .BYTE   'S'+80H,"TOP"
2175: CF5554  	        .BYTE   'O'+80H,"UT"
2178: CF4E    	        .BYTE   'O'+80H,"N"
217A: CE554C4C	        .BYTE   'N'+80H,"ULL"
217E: D7414954	        .BYTE   'W'+80H,"AIT"
2182: C44546  	        .BYTE   'D'+80H,"EF"
2185: D04F4B45	        .BYTE   'P'+80H,"OKE"
2189: C44F4B45	        .BYTE   'D'+80H,"OKE"
218D: D3435245	        .BYTE   'S'+80H,"CREEN"
2191: 454E    	
2193: CC494E45	        .BYTE   'L'+80H,"INES"
2197: 53      	
2198: C34C53  	        .BYTE   'C'+80H,"LS"
219B: D7494454	        .BYTE   'W'+80H,"IDTH"
219F: 48      	
21A0: CD4F4E49	        .BYTE   'M'+80H,"ONITOR"
21A4: 544F52  	
21A7: D34554  	        .BYTE   'S'+80H,"ET"
21AA: D2455345	        .BYTE   'R'+80H,"ESET"
21AE: 54      	
21AF: D052494E	        .BYTE   'P'+80H,"RINT"
21B3: 54      	
21B4: C34F4E54	        .BYTE   'C'+80H,"ONT"
21B8: CC495354	        .BYTE   'L'+80H,"IST"
21BC: C34C4541	        .BYTE   'C'+80H,"LEAR"
21C0: 52      	
21C1: C34C4F41	        .BYTE   'C'+80H,"LOAD"
21C5: 44      	
21C6: C3534156	        .BYTE   'C'+80H,"SAVE"
21CA: 45      	
21CB: CE4557  	        .BYTE   'N'+80H,"EW"
              	
21CE: D4414228	        .BYTE   'T'+80H,"AB("
21D2: D44F    	        .BYTE   'T'+80H,"O"
21D4: C64E    	        .BYTE   'F'+80H,"N"
21D6: D3504328	        .BYTE   'S'+80H,"PC("
21DA: D448454E	        .BYTE   'T'+80H,"HEN"
21DE: CE4F54  	        .BYTE   'N'+80H,"OT"
21E1: D3544550	        .BYTE   'S'+80H,"TEP"
              	
21E5: AB      	        .BYTE   '+'+80H
21E6: AD      	        .BYTE   '-'+80H
21E7: AA      	        .BYTE   '*'+80H
21E8: AF      	        .BYTE   '/'+80H
21E9: DE      	        .BYTE   '^'+80H
21EA: C14E44  	        .BYTE   'A'+80H,"ND"
21ED: CF52    	        .BYTE   'O'+80H,"R"
21EF: BE      	        .BYTE   '>'+80H
21F0: BD      	        .BYTE   '='+80H
21F1: BC      	        .BYTE   '<'+80H
              	
21F2: D3474E  	        .BYTE   'S'+80H,"GN"
21F5: C94E54  	        .BYTE   'I'+80H,"NT"
21F8: C14253  	        .BYTE   'A'+80H,"BS"
21FB: D55352  	        .BYTE   'U'+80H,"SR"
21FE: C65245  	        .BYTE   'F'+80H,"RE"
2201: C94E50  	        .BYTE   'I'+80H,"NP"
2204: D04F53  	        .BYTE   'P'+80H,"OS"
2207: D35152  	        .BYTE   'S'+80H,"QR"
220A: D24E44  	        .BYTE   'R'+80H,"ND"
220D: CC4F47  	        .BYTE   'L'+80H,"OG"
2210: C55850  	        .BYTE   'E'+80H,"XP"
2213: C34F53  	        .BYTE   'C'+80H,"OS"
2216: D3494E  	        .BYTE   'S'+80H,"IN"
2219: D4414E  	        .BYTE   'T'+80H,"AN"
221C: C1544E  	        .BYTE   'A'+80H,"TN"
221F: D045454B	        .BYTE   'P'+80H,"EEK"
2223: C445454B	        .BYTE   'D'+80H,"EEK"
2227: D04F494E	        .BYTE   'P'+80H,"OINT"
222B: 54      	
222C: CC454E  	        .BYTE   'L'+80H,"EN"
222F: D3545224	        .BYTE   'S'+80H,"TR$"
2233: D6414C  	        .BYTE   'V'+80H,"AL"
2236: C15343  	        .BYTE   'A'+80H,"SC"
2239: C3485224	        .BYTE   'C'+80H,"HR$"
223D: C8455824	        .BYTE   'H'+80H,"EX$"
2241: C2494E24	        .BYTE   'B'+80H,"IN$"
2245: CC454654	        .BYTE   'L'+80H,"EFT$"
2249: 24      	
224A: D2494748	        .BYTE   'R'+80H,"IGHT$"
224E: 5424    	
2250: CD494424	        .BYTE   'M'+80H,"ID$"
2254: 80      	        .BYTE   80H             ; End of list marker
              	
              	; KEYWORD ADDRESS TABLE
              	
2255: 4F28    	WORDTB: .WORD   PEND
2257: 4C27    	        .WORD   FOR
2259: 272C    	        .WORD   NEXT
225B: 9C29    	        .WORD   DATA
225D: 2E2B    	        .WORD   INPUT
225F: 632E    	        .WORD   DIM
2261: 5D2B    	        .WORD   READ
2263: B329    	        .WORD   LET
2265: 5929    	        .WORD   GOTO
2267: 3C29    	        .WORD   RUN
2269: 2B2A    	        .WORD   IF
226B: 1528    	        .WORD   RESTOR
226D: 4829    	        .WORD   GOSUB
226F: 7729    	        .WORD   RETURN
2271: 9E29    	        .WORD   REM
2273: 4D28    	        .WORD   STOP
2275: 9C33    	        .WORD   POUT
2277: 0D2A    	        .WORD   ON
2279: 8E28    	        .WORD   NULL
227B: A233    	        .WORD   WAIT
227D: 4130    	        .WORD   DEF
227F: EB33    	        .WORD   POKE
2281: 333B    	        .WORD   DOKE
2283: 9E29    	        .WORD   REM
2285: 193B    	        .WORD   LINES
2287: 0C3B    	        .WORD   CLS
2289: 113B    	        .WORD   WIDTH
228B: 493C    	        .WORD   MONITR
228D: E440    	        .WORD   PSET
228F: E740    	        .WORD   RESET
2291: 4F2A    	        .WORD   PRINT
2293: 7B28    	        .WORD   CONT
2295: C126    	        .WORD   LIST
2297: F628    	        .WORD   CLEAR
2299: 9E29    	        .WORD   REM
229B: 9E29    	        .WORD   REM
229D: B924    	        .WORD   NEW
              	
              	; RESERVED WORD TOKEN VALUES
              	
0080:         	ZEND    .EQU    080H            ; END
0081:         	ZFOR    .EQU    081H            ; FOR
0083:         	ZDATA   .EQU    083H            ; DATA
0088:         	ZGOTO   .EQU    088H            ; GOTO
008C:         	ZGOSUB  .EQU    08CH            ; GOSUB
008E:         	ZREM    .EQU    08EH            ; REM
009E:         	ZPRINT  .EQU    09EH            ; PRINT
00A4:         	ZNEW    .EQU    0A4H            ; NEW
              	
00A5:         	ZTAB    .EQU    0A5H            ; TAB
00A6:         	ZTO     .EQU    0A6H            ; TO
00A7:         	ZFN     .EQU    0A7H            ; FN
00A8:         	ZSPC    .EQU    0A8H            ; SPC
00A9:         	ZTHEN   .EQU    0A9H            ; THEN
00AA:         	ZNOT    .EQU    0AAH            ; NOT
00AB:         	ZSTEP   .EQU    0ABH            ; STEP
              	
00AC:         	ZPLUS   .EQU    0ACH            ; +
00AD:         	ZMINUS  .EQU    0ADH            ; -
00AE:         	ZTIMES  .EQU    0AEH            ; *
00AF:         	ZDIV    .EQU    0AFH            ; /
00B2:         	ZOR     .EQU    0B2H            ; OR
00B3:         	ZGTR    .EQU    0B3H            ; >
00B4:         	ZEQUAL  .EQU    0B4H            ; M
00B5:         	ZLTH    .EQU    0B5H            ; <
00B6:         	ZSGN    .EQU    0B6H            ; SGN
00C7:         	ZPOINT  .EQU    0C7H            ; POINT
00CF:         	ZLEFT   .EQU    0CDH +2         ; LEFT$
              	
              	; ARITHMETIC PRECEDENCE TABLE
              	
229F: 79      	PRITAB: .BYTE   79H             ; Precedence value
22A0: D537    	        .WORD   PADD            ; FPREG = <last> + FPREG
              	
22A2: 79      	        .BYTE   79H             ; Precedence value
22A3: 0934    	        .WORD   PSUB            ; FPREG = <last> - FPREG
              	
22A5: 7C      	        .BYTE   7CH             ; Precedence value
22A6: 4735    	        .WORD   MULT            ; PPREG = <last> * FPREG
              	
22A8: 7C      	        .BYTE   7CH             ; Precedence value
22A9: A835    	        .WORD   DIV             ; FPREG = <last> / FPREG
              	
22AB: 7F      	        .BYTE   7FH             ; Precedence value
22AC: F638    	        .WORD   POWER           ; FPREG = <last> ^ FPREG
              	
22AE: 50      	        .BYTE   50H             ; Precedence value
22AF: BC2D    	        .WORD   PAND            ; FPREG = <last> AND FPREG
              	
22B1: 46      	        .BYTE   46H             ; Precedence value
22B2: BB2D    	        .WORD   POR             ; FPREG = <last> OR FPREG
              	
              	; BASIC ERROR CODE LIST
              	
22B4: 4E46    	ERRORS: .BYTE   "NF"            ; NEXT without FOR
22B6: 534E    	        .BYTE   "SN"            ; Syntax error
22B8: 5247    	        .BYTE   "RG"            ; RETURN without GOSUB
22BA: 4F44    	        .BYTE   "OD"            ; Out of DATA
22BC: 4643    	        .BYTE   "FC"            ; Illegal function call
22BE: 4F56    	        .BYTE   "OV"            ; Overflow error
22C0: 4F4D    	        .BYTE   "OM"            ; Out of memory
22C2: 554C    	        .BYTE   "UL"            ; Undefined line
22C4: 4253    	        .BYTE   "BS"            ; Bad subscript
22C6: 4444    	        .BYTE   "DD"            ; Re-DIMensioned array
22C8: 2F30    	        .BYTE   "/0"            ; Division by zero
22CA: 4944    	        .BYTE   "ID"            ; Illegal direct
22CC: 544D    	        .BYTE   "TM"            ; Type mis-match
22CE: 4F53    	        .BYTE   "OS"            ; Out of string space
22D0: 4C53    	        .BYTE   "LS"            ; String too long
22D2: 5354    	        .BYTE   "ST"            ; String formula too complex
22D4: 434E    	        .BYTE   "CN"            ; Can't CONTinue
22D6: 5546    	        .BYTE   "UF"            ; Undefined FN function
22D8: 4D4F    	        .BYTE   "MO"            ; Missing operand
22DA: 4858    	        .BYTE   "HX"            ; HEX error
22DC: 424E    	        .BYTE   "BN"            ; BIN error
              	
              	; INITIALISATION TABLE -------------------------------------------------------
              	
22DE: C3A420  	INITAB: JP      WARMST          ; Warm start jump
22E1: C3CC28  	        JP      FCERR           ; "USR (X)" jump (Set to Error)
22E4: D300    	        OUT     (0),A           ; "OUT p,n" skeleton
22E6: C9      	        RET
22E7: D600    	        SUB     0               ; Division support routine
22E9: 6F      	        LD      L,A
22EA: 7C      	        LD      A,H
22EB: DE00    	        SBC     A,0
22ED: 67      	        LD      H,A
22EE: 78      	        LD      A,B
22EF: DE00    	        SBC     A,0
22F1: 47      	        LD      B,A
22F2: 3E00    	        LD      A,0
22F4: C9      	        RET
22F5: 000000  	        .BYTE   0,0,0                   ; Random number seed table used by RND
22F8: 354ACA99	        .BYTE   035H,04AH,0CAH,099H     ;-2.65145E+07
22FC: 391C7698	        .BYTE   039H,01CH,076H,098H     ; 1.61291E+07
2300: 2295B398	        .BYTE   022H,095H,0B3H,098H     ;-1.17691E+07
2304: 0ADD4798	        .BYTE   00AH,0DDH,047H,098H     ; 1.30983E+07
2308: 53D19999	        .BYTE   053H,0D1H,099H,099H     ;-2-01612E+07
230C: 0A1A9F98	        .BYTE   00AH,01AH,09FH,098H     ;-1.04269E+07
2310: 65BCCD98	        .BYTE   065H,0BCH,0CDH,098H     ;-1.34831E+07
2314: D6773E98	        .BYTE   0D6H,077H,03EH,098H     ; 1.24825E+07
2318: 52C74F80	        .BYTE   052H,0C7H,04FH,080H     ; Last random number
231C: DB00    	        IN      A,(0)           ; INP (x) skeleton
231E: C9      	        RET
231F: 01      	        .BYTE   1               ; POS (x) number (1)
2320: FF      	        .BYTE   255             ; Terminal width (255 = no auto CRLF)
2321: 1C      	        .BYTE   28              ; Width for commas (3 columns)
2322: 00      	        .BYTE   0               ; No nulls after input bytes
2323: 00      	        .BYTE   0               ; Output enabled (^O off)
2324: 1400    	        .WORD   20              ; Initial lines counter
2326: 1400    	        .WORD   20              ; Initial lines number
2328: 0000    	        .WORD   0               ; Array load/save check sum
232A: 00      	        .BYTE   0               ; Break not by NMI
232B: 00      	        .BYTE   0               ; Break flag
232C: C3F225  	        JP      TTYLIN          ; Input reflection (set to TTY)
232F: C30000  	        JP      $0000           ; POINT reflection unused
2332: C30000  	        JP      $0000           ; SET reflection
2335: C30000  	        JP      $0000          	; RESET reflection
2338: ED41    	        .WORD   STLOOK          ; Temp string space
233A: FEFF    	        .WORD   -2              ; Current line number (cold)
233C: 8A41    	        .WORD   PROGST+1        ; Start of program text
233E:         	INITBE:                         
              	
              	; END OF INITIALISATION TABLE ---------------------------------------------------
              	
233E: 20457272	ERRMSG: .BYTE   " Error",0
2342: 6F7200  	
2345: 20696E20	INMSG:  .BYTE   " in ",0
2349: 00      	
2349:         	ZERBYT  .EQU    $-1             ; A zero byte
234A: 4F6B0D0A	OKMSG:  .BYTE   "Ok",CR,LF,0,0
234E: 0000    	
2350: 42726561	BRKMSG: .BYTE   "Break",0
2354: 6B00    	
              	
2356: 210400  	BAKSTK: LD      HL,4            ; Look for "FOR" block with
2359: 39      	        ADD     HL,SP           ; same index as specified
235A: 7E      	LOKFOR: LD      A,(HL)          ; Get block ID
235B: 23      	        INC     HL              ; Point to index address
235C: FE81    	        CP      ZFOR            ; Is it a "FOR" token
235E: C0      	        RET     NZ              ; No - exit
235F: 4E      	        LD      C,(HL)          ; BC = Address of "FOR" index
2360: 23      	        INC     HL
2361: 46      	        LD      B,(HL)
2362: 23      	        INC     HL              ; Point to sign of STEP
2363: E5      	        PUSH    HL              ; Save pointer to sign
2364: 69      	        LD      L,C             ; HL = address of "FOR" index
2365: 60      	        LD      H,B
2366: 7A      	        LD      A,D             ; See if an index was specified
2367: B3      	        OR      E               ; DE = 0 if no index specified
2368: EB      	        EX      DE,HL           ; Specified index into HL
2369: CA7023  	        JP      Z,INDFND        ; Skip if no index given
236C: EB      	        EX      DE,HL           ; Index back into DE
236D: CD7526  	        CALL    CPDEHL          ; Compare index with one given
2370: 010D00  	INDFND: LD      BC,16-3         ; Offset to next block
2373: E1      	        POP     HL              ; Restore pointer to sign
2374: C8      	        RET     Z               ; Return if block found
2375: 09      	        ADD     HL,BC           ; Point to next block
2376: C35A23  	        JP      LOKFOR          ; Keep on looking
              	
2379: CD9323  	MOVUP:  CALL    ENFMEM          ; See if enough memory
237C: C5      	MOVSTR: PUSH    BC              ; Save end of source
237D: E3      	        EX      (SP),HL         ; Swap source and dest" end
237E: C1      	        POP     BC              ; Get end of destination
237F: CD7526  	MOVLP:  CALL    CPDEHL          ; See if list moved
2382: 7E      	        LD      A,(HL)          ; Get byte
2383: 02      	        LD      (BC),A          ; Move it
2384: C8      	        RET     Z               ; Exit if all done
2385: 0B      	        DEC     BC              ; Next byte to move to
2386: 2B      	        DEC     HL              ; Next byte to move
2387: C37F23  	        JP      MOVLP           ; Loop until all bytes moved
              	
238A: E5      	CHKSTK: PUSH    HL              ; Save code string address
238B: 2A6A41  	        LD      HL,(ARREND)     ; Lowest free memory
238E: 0600    	        LD      B,0             ; BC = Number of levels to test
2390: 09      	        ADD     HL,BC           ; 2 Bytes for each level
2391: 09      	        ADD     HL,BC
2392: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
2393: E5      	ENFMEM: PUSH    HL              ; Save code string address
2394: 3ED0    	        LD      A,0D0H ;LOW -48 ; 48 Bytes minimum RAM
2396: 95      	        SUB     L
2397: 6F      	        LD      L,A
2398: 3EFF    	        LD      A,0FFH; HIGH (-48) ; 48 Bytes minimum RAM
239A: 9C      	        SBC     A,H
239B: DAA223  	        JP      C,OMERR         ; Not enough - ?OM Error
239E: 67      	        LD      H,A
239F: 39      	        ADD     HL,SP           ; Test if stack is overflowed
23A0: E1      	        POP     HL              ; Restore code string address
23A1: D8      	        RET     C               ; Return if enough mmory
23A2: 1E0C    	OMERR:  LD      E,OM            ; ?OM Error
23A4: C3C123  	        JP      ERROR
              	
23A7: 2A5941  	DATSNR: LD      HL,(DATLIN)     ; Get line of current DATA item
23AA: 22EC40  	        LD      (LINEAT),HL     ; Save as current line
23AD: 1E02    	SNERR:  LD      E,SN            ; ?SN Error
23AF: 01      	        .BYTE   01H             ; Skip "LD E,DZ"
23B0: 1E14    	DZERR:  LD      E,DZ            ; ?/0 Error
23B2: 01      	        .BYTE   01H             ; Skip "LD E,NF"
23B3: 1E00    	NFERR:  LD      E,NF            ; ?NF Error
23B5: 01      	        .BYTE   01H             ; Skip "LD E,DD"
23B6: 1E12    	DDERR:  LD      E,DD            ; ?DD Error
23B8: 01      	        .BYTE   01H             ; Skip "LD E,UF"
23B9: 1E22    	UFERR:  LD      E,UF            ; ?UF Error
23BB: 01      	        .BYTE   01H             ; Skip "LD E,OV
23BC: 1E0A    	OVERR:  LD      E,OV            ; ?OV Error
23BE: 01      	        .BYTE   01H             ; Skip "LD E,TM"
23BF: 1E18    	TMERR:  LD      E,TM            ; ?TM Error
              	
23C1: CDDF24  	ERROR:  CALL    CLREG           ; Clear registers and stack
23C4: 32D540  	        LD      (CTLOFG),A      ; Enable output (A is 0)
23C7: CDA02A  	        CALL    STTLIN          ; Start new line
23CA: 21B422  	        LD      HL,ERRORS       ; Point to error codes
23CD: 57      	        LD      D,A             ; D = 0 (A is 0)
23CE: 3E3F    	        LD      A,'?'
23D0: CD8626  	        CALL    OUTC            ; Output '?'
23D3: 19      	        ADD     HL,DE           ; Offset to correct error code
23D4: 7E      	        LD      A,(HL)          ; First character
23D5: CD8626  	        CALL    OUTC            ; Output it
23D8: CD0528  	        CALL    GETCHR          ; Get next character
23DB: CD8626  	        CALL    OUTC            ; Output it
23DE: 213E23  	        LD      HL,ERRMSG       ; "Error" message
23E1: CD4B31  	ERRIN:  CALL    PRS             ; Output message
23E4: 2AEC40  	        LD      HL,(LINEAT)     ; Get line of error
23E7: 11FEFF  	        LD      DE,-2           ; Cold start error if -2
23EA: CD7526  	        CALL    CPDEHL          ; See if cold start error
23ED: CA1120  	        JP      Z,CSTART        ; Cold start error - Restart
23F0: 7C      	        LD      A,H             ; Was it a direct error?
23F1: A5      	        AND     L               ; Line = -1 if direct error
23F2: 3C      	        INC     A
23F3: C4E637  	        CALL    NZ,LINEIN       ; No - output line of error
23F6: 3E      	        .BYTE   3EH             ; Skip "POP BC"
23F7: C1      	POPNOK: POP     BC              ; Drop address in input buffer
              	
23F8: AF      	PRNTOK: XOR     A               ; Output "Ok" and get command
23F9: 32D540  	        LD      (CTLOFG),A      ; Enable output
23FC: CDA02A  	        CALL    STTLIN          ; Start new line
23FF: 214A23  	        LD      HL,OKMSG        ; "Ok" message
2402: CD4B31  	        CALL    PRS             ; Output "Ok"
2405: 21FFFF  	GETCMD: LD      HL,-1           ; Flag direct mode
2408: 22EC40  	        LD      (LINEAT),HL     ; Save as current line
240B: CDF225  	        CALL    GETLIN          ; Get an input line
240E: DA0524  	        JP      C,GETCMD        ; Get line again if break
2411: CD0528  	        CALL    GETCHR          ; Get first character
2414: 3C      	        INC     A               ; Test if end of line
2415: 3D      	        DEC     A               ; Without affecting Carry
2416: CA0524  	        JP      Z,GETCMD        ; Nothing entered - Get another
2419: F5      	        PUSH    AF              ; Save Carry status
241A: CDD128  	        CALL    ATOH            ; Get line number into DE
241D: D5      	        PUSH    DE              ; Save line number
241E: CD0925  	        CALL    CRUNCH          ; Tokenise rest of line
2421: 47      	        LD      B,A             ; Length of tokenised line
2422: D1      	        POP     DE              ; Restore line number
2423: F1      	        POP     AF              ; Restore Carry
2424: D2E527  	        JP      NC,EXCUTE       ; No line number - Direct mode
2427: D5      	        PUSH    DE              ; Save line number
2428: C5      	        PUSH    BC              ; Save length of tokenised line
2429: AF      	        XOR     A
242A: 325C41  	        LD      (LSTBIN),A      ; Clear last byte input
242D: CD0528  	        CALL    GETCHR          ; Get next character
2430: B7      	        OR      A               ; Set flags
2431: F5      	        PUSH    AF              ; And save them
2432: CD9924  	        CALL    SRCHLN          ; Search for line number in DE
2435: DA3E24  	        JP      C,LINFND        ; Jump if line found
2438: F1      	        POP     AF              ; Get status
2439: F5      	        PUSH    AF              ; And re-save
243A: CA7229  	        JP      Z,ULERR         ; Nothing after number - Error
243D: B7      	        OR      A               ; Clear Carry
243E: C5      	LINFND: PUSH    BC              ; Save address of line in prog
243F: D25524  	        JP      NC,INEWLN       ; Line not found - Insert new
2442: EB      	        EX      DE,HL           ; Next line address in DE
2443: 2A6641  	        LD      HL,(PROGND)     ; End of program
2446: 1A      	SFTPRG: LD      A,(DE)          ; Shift rest of program down
2447: 02      	        LD      (BC),A
2448: 03      	        INC     BC              ; Next destination
2449: 13      	        INC     DE              ; Next source
244A: CD7526  	        CALL    CPDEHL          ; All done?
244D: C24624  	        JP      NZ,SFTPRG       ; More to do
2450: 60      	        LD      H,B             ; HL - New end of program
2451: 69      	        LD      L,C
2452: 226641  	        LD      (PROGND),HL     ; Update end of program
              	
2455: D1      	INEWLN: POP     DE              ; Get address of line,
2456: F1      	        POP     AF              ; Get status
2457: CA7C24  	        JP      Z,SETPTR        ; No text - Set up pointers
245A: 2A6641  	        LD      HL,(PROGND)     ; Get end of program
245D: E3      	        EX      (SP),HL         ; Get length of input line
245E: C1      	        POP     BC              ; End of program to BC
245F: 09      	        ADD     HL,BC           ; Find new end
2460: E5      	        PUSH    HL              ; Save new end
2461: CD7923  	        CALL    MOVUP           ; Make space for line
2464: E1      	        POP     HL              ; Restore new end
2465: 226641  	        LD      (PROGND),HL     ; Update end of program pointer
2468: EB      	        EX      DE,HL           ; Get line to move up in HL
2469: 74      	        LD      (HL),H          ; Save MSB
246A: D1      	        POP     DE              ; Get new line number
246B: 23      	        INC     HL              ; Skip pointer
246C: 23      	        INC     HL
246D: 73      	        LD      (HL),E          ; Save LSB of line number
246E: 23      	        INC     HL
246F: 72      	        LD      (HL),D          ; Save MSB of line number
2470: 23      	        INC     HL              ; To first byte in line
2471: 11F140  	        LD      DE,BUFFER       ; Copy buffer to program
2474: 1A      	MOVBUF: LD      A,(DE)          ; Get source
2475: 77      	        LD      (HL),A          ; Save destinations
2476: 23      	        INC     HL              ; Next source
2477: 13      	        INC     DE              ; Next destination
2478: B7      	        OR      A               ; Done?
2479: C27424  	        JP      NZ,MOVBUF       ; No - Repeat
247C: CDC524  	SETPTR: CALL    RUNFST          ; Set line pointers
247F: 23      	        INC     HL              ; To LSB of pointer
2480: EB      	        EX      DE,HL           ; Address to DE
2481: 62      	PTRLP:  LD      H,D             ; Address to HL
2482: 6B      	        LD      L,E
2483: 7E      	        LD      A,(HL)          ; Get LSB of pointer
2484: 23      	        INC     HL              ; To MSB of pointer
2485: B6      	        OR      (HL)            ; Compare with MSB pointer
2486: CA0524  	        JP      Z,GETCMD        ; Get command line if end
2489: 23      	        INC     HL              ; To LSB of line number
248A: 23      	        INC     HL              ; Skip line number
248B: 23      	        INC     HL              ; Point to first byte in line
248C: AF      	        XOR     A               ; Looking for 00 byte
248D: BE      	FNDEND: CP      (HL)            ; Found end of line?
248E: 23      	        INC     HL              ; Move to next byte
248F: C28D24  	        JP      NZ,FNDEND       ; No - Keep looking
2492: EB      	        EX      DE,HL           ; Next line address to HL
2493: 73      	        LD      (HL),E          ; Save LSB of pointer
2494: 23      	        INC     HL
2495: 72      	        LD      (HL),D          ; Save MSB of pointer
2496: C38124  	        JP      PTRLP           ; Do next line
              	
2499: 2AEE40  	SRCHLN: LD      HL,(BASTXT)     ; Start of program text
249C: 44      	SRCHLP: LD      B,H             ; BC = Address to look at
249D: 4D      	        LD      C,L
249E: 7E      	        LD      A,(HL)          ; Get address of next line
249F: 23      	        INC     HL
24A0: B6      	        OR      (HL)            ; End of program found?
24A1: 2B      	        DEC     HL
24A2: C8      	        RET     Z               ; Yes - Line not found
24A3: 23      	        INC     HL
24A4: 23      	        INC     HL
24A5: 7E      	        LD      A,(HL)          ; Get LSB of line number
24A6: 23      	        INC     HL
24A7: 66      	        LD      H,(HL)          ; Get MSB of line number
24A8: 6F      	        LD      L,A
24A9: CD7526  	        CALL    CPDEHL          ; Compare with line in DE
24AC: 60      	        LD      H,B             ; HL = Start of this line
24AD: 69      	        LD      L,C
24AE: 7E      	        LD      A,(HL)          ; Get LSB of next line address
24AF: 23      	        INC     HL
24B0: 66      	        LD      H,(HL)          ; Get MSB of next line address
24B1: 6F      	        LD      L,A             ; Next line to HL
24B2: 3F      	        CCF
24B3: C8      	        RET     Z               ; Lines found - Exit
24B4: 3F      	        CCF
24B5: D0      	        RET     NC              ; Line not found,at line after
24B6: C39C24  	        JP      SRCHLP          ; Keep looking
              	
24B9: C0      	NEW:    RET     NZ              ; Return if any more on line
24BA: 2AEE40  	CLRPTR: LD      HL,(BASTXT)     ; Point to start of program
24BD: AF      	        XOR     A               ; Set program area to empty
24BE: 77      	        LD      (HL),A          ; Save LSB = 00
24BF: 23      	        INC     HL
24C0: 77      	        LD      (HL),A          ; Save MSB = 00
24C1: 23      	        INC     HL
24C2: 226641  	        LD      (PROGND),HL     ; Set program end
              	
24C5: 2AEE40  	RUNFST: LD      HL,(BASTXT)     ; Clear all variables
24C8: 2B      	        DEC     HL
              	
24C9: 225E41  	INTVAR: LD      (BRKLIN),HL     ; Initialise RUN variables
24CC: 2A3F41  	        LD      HL,(LSTRAM)     ; Get end of RAM
24CF: 225341  	        LD      (STRBOT),HL     ; Clear string space
24D2: AF      	        XOR     A
24D3: CD1528  	        CALL    RESTOR          ; Reset DATA pointers
24D6: 2A6641  	        LD      HL,(PROGND)     ; Get end of program
24D9: 226841  	        LD      (VAREND),HL     ; Clear variables
24DC: 226A41  	        LD      (ARREND),HL     ; Clear arrays
              	
24DF: C1      	CLREG:  POP     BC              ; Save return address
24E0: 2AEA40  	        LD      HL,(STRSPC)     ; Get end of working RAN
24E3: F9      	        LD      SP,HL           ; Set stack
24E4: 214341  	        LD      HL,TMSTPL       ; Temporary string pool
24E7: 224141  	        LD      (TMSTPT),HL     ; Reset temporary string ptr
24EA: AF      	        XOR     A               ; A = 00
24EB: 6F      	        LD      L,A             ; HL = 0000
24EC: 67      	        LD      H,A
24ED: 226441  	        LD      (CONTAD),HL     ; No CONTinue
24F0: 325B41  	        LD      (FORFLG),A      ; Clear FOR flag
24F3: 226E41  	        LD      (FNRGNM),HL     ; Clear FN argument
24F6: E5      	        PUSH    HL              ; HL = 0000
24F7: C5      	        PUSH    BC              ; Put back return
24F8: 2A5E41  	DOAGN:  LD      HL,(BRKLIN)     ; Get address of code to RUN
24FB: C9      	        RET                     ; Return to execution driver
              	
24FC: 3E3F    	PROMPT: LD      A,'?'           ; '?'
24FE: CD8626  	        CALL    OUTC            ; Output character
2501: 3E20    	        LD      A,' '           ; Space
2503: CD8626  	        CALL    OUTC            ; Output character
2506: C3DE40  	        JP      RINPUT          ; Get input line
              	
2509: AF      	CRUNCH: XOR     A               ; Tokenise line @ HL to BUFFER
250A: 323E41  	        LD      (DATFLG),A      ; Reset literal flag
250D: 0E05    	        LD      C,2+3           ; 2 byte number and 3 nulls
250F: 11F140  	        LD      DE,BUFFER       ; Start of input buffer
2512: 7E      	CRNCLP: LD      A,(HL)          ; Get byte
2513: FE20    	        CP      ' '             ; Is it a space?
2515: CA9125  	        JP      Z,MOVDIR        ; Yes - Copy direct
2518: 47      	        LD      B,A             ; Save character
2519: FE22    	        CP      '"'             ; Is it a quote?
251B: CAB125  	        JP      Z,CPYLIT        ; Yes - Copy literal string
251E: B7      	        OR      A               ; Is it end of buffer?
251F: CAB825  	        JP      Z,ENDBUF        ; Yes - End buffer
2522: 3A3E41  	        LD      A,(DATFLG)      ; Get data type
2525: B7      	        OR      A               ; Literal?
2526: 7E      	        LD      A,(HL)          ; Get byte to copy
2527: C29125  	        JP      NZ,MOVDIR       ; Literal - Copy direct
252A: FE3F    	        CP      '?'             ; Is it '?' short for PRINT
252C: 3E9E    	        LD      A,ZPRINT        ; "PRINT" token
252E: CA9125  	        JP      Z,MOVDIR        ; Yes - replace it
2531: 7E      	        LD      A,(HL)          ; Get byte again
2532: FE30    	        CP      '0'             ; Is it less than '0'
2534: DA3C25  	        JP      C,FNDWRD        ; Yes - Look for reserved words
2537: FE3C    	        CP      60; ";"+1           ; Is it "0123456789:;" ?
2539: DA9125  	        JP      C,MOVDIR        ; Yes - copy it direct
253C: D5      	FNDWRD: PUSH    DE              ; Look for reserved words
253D: 113521  	        LD      DE,WORDS-1      ; Point to table
2540: C5      	        PUSH    BC              ; Save count
2541: 018D25  	        LD      BC,RETNAD       ; Where to return to
2544: C5      	        PUSH    BC              ; Save return address
2545: 067F    	        LD      B,ZEND-1        ; First token value -1
2547: 7E      	        LD      A,(HL)          ; Get byte
2548: FE61    	        CP      'a'             ; Less than 'a' ?
254A: DA5525  	        JP      C,SEARCH        ; Yes - search for words
254D: FE7B    	        CP      'z'+1           ; Greater than 'z' ?
254F: D25525  	        JP      NC,SEARCH       ; Yes - search for words
2552: E65F    	        AND     01011111B       ; Force upper case
2554: 77      	        LD      (HL),A          ; Replace byte
2555: 4E      	SEARCH: LD      C,(HL)          ; Search for a word
2556: EB      	        EX      DE,HL
2557: 23      	GETNXT: INC     HL              ; Get next reserved word
2558: B6      	        OR      (HL)            ; Start of word?
2559: F25725  	        JP      P,GETNXT        ; No - move on
255C: 04      	        INC     B               ; Increment token value
255D: 7E      	        LD      A, (HL)         ; Get byte from table
255E: E67F    	        AND     01111111B       ; Strip bit 7
2560: C8      	        RET     Z               ; Return if end of list
2561: B9      	        CP      C               ; Same character as in buffer?
2562: C25725  	        JP      NZ,GETNXT       ; No - get next word
2565: EB      	        EX      DE,HL
2566: E5      	        PUSH    HL              ; Save start of word
              	
2567: 13      	NXTBYT: INC     DE              ; Look through rest of word
2568: 1A      	        LD      A,(DE)          ; Get byte from table
2569: B7      	        OR      A               ; End of word ?
256A: FA8925  	        JP      M,MATCH         ; Yes - Match found
256D: 4F      	        LD      C,A             ; Save it
256E: 78      	        LD      A,B             ; Get token value
256F: FE88    	        CP      ZGOTO           ; Is it "GOTO" token ?
2571: C27825  	        JP      NZ,NOSPC        ; No - Don't allow spaces
2574: CD0528  	        CALL    GETCHR          ; Get next character
2577: 2B      	        DEC     HL              ; Cancel increment from GETCHR
2578: 23      	NOSPC:  INC     HL              ; Next byte
2579: 7E      	        LD      A,(HL)          ; Get byte
257A: FE61    	        CP      'a'             ; Less than 'a' ?
257C: DA8125  	        JP      C,NOCHNG        ; Yes - don't change
257F: E65F    	        AND     01011111B       ; Make upper case
2581: B9      	NOCHNG: CP      C               ; Same as in buffer ?
2582: CA6725  	        JP      Z,NXTBYT        ; Yes - keep testing
2585: E1      	        POP     HL              ; Get back start of word
2586: C35525  	        JP      SEARCH          ; Look at next word
              	
2589: 48      	MATCH:  LD      C,B             ; Word found - Save token value
258A: F1      	        POP     AF              ; Throw away return
258B: EB      	        EX      DE,HL
258C: C9      	        RET                     ; Return to "RETNAD"
258D: EB      	RETNAD: EX      DE,HL           ; Get address in string
258E: 79      	        LD      A,C             ; Get token value
258F: C1      	        POP     BC              ; Restore buffer length
2590: D1      	        POP     DE              ; Get destination address
2591: 23      	MOVDIR: INC     HL              ; Next source in buffer
2592: 12      	        LD      (DE),A          ; Put byte in buffer
2593: 13      	        INC     DE              ; Move up buffer
2594: 0C      	        INC     C               ; Increment length of buffer
2595: D63A    	        SUB     ':'             ; End of statement?
2597: CA9F25  	        JP      Z,SETLIT        ; Jump if multi-statement line
259A: FE49    	        CP      ZDATA-3AH       ; Is it DATA statement ?
259C: C2A225  	        JP      NZ,TSTREM       ; No - see if REM
259F: 323E41  	SETLIT: LD      (DATFLG),A      ; Set literal flag
25A2: D654    	TSTREM: SUB     ZREM-3AH        ; Is it REM?
25A4: C21225  	        JP      NZ,CRNCLP       ; No - Leave flag
25A7: 47      	        LD      B,A             ; Copy rest of buffer
25A8: 7E      	NXTCHR: LD      A,(HL)          ; Get byte
25A9: B7      	        OR      A               ; End of line ?
25AA: CAB825  	        JP      Z,ENDBUF        ; Yes - Terminate buffer
25AD: B8      	        CP      B               ; End of statement ?
25AE: CA9125  	        JP      Z,MOVDIR        ; Yes - Get next one
25B1: 23      	CPYLIT: INC     HL              ; Move up source string
25B2: 12      	        LD      (DE),A          ; Save in destination
25B3: 0C      	        INC     C               ; Increment length
25B4: 13      	        INC     DE              ; Move up destination
25B5: C3A825  	        JP      NXTCHR          ; Repeat
              	
25B8: 21F040  	ENDBUF: LD      HL,BUFFER-1     ; Point to start of buffer
25BB: 12      	        LD      (DE),A          ; Mark end of buffer (A = 00)
25BC: 13      	        INC     DE
25BD: 12      	        LD      (DE),A          ; A = 00
25BE: 13      	        INC     DE
25BF: 12      	        LD      (DE),A          ; A = 00
25C0: C9      	        RET
              	
25C1: 3AD440  	DODEL:  LD      A,(NULFLG)      ; Get null flag status
25C4: B7      	        OR      A               ; Is it zero?
25C5: 3E00    	        LD      A,0             ; Zero A - Leave flags
25C7: 32D440  	        LD      (NULFLG),A      ; Zero null flag
25CA: C2D525  	        JP      NZ,ECHDEL       ; Set - Echo it
25CD: 05      	        DEC     B               ; Decrement length
25CE: CAF225  	        JP      Z,GETLIN        ; Get line again if empty
25D1: CD8626  	        CALL    OUTC            ; Output null character
25D4: 3E      	        .BYTE   3EH             ; Skip "DEC B"
25D5: 05      	ECHDEL: DEC     B               ; Count bytes in buffer
25D6: 2B      	        DEC     HL              ; Back space buffer
25D7: CAE925  	        JP      Z,OTKLN         ; No buffer - Try again
25DA: 7E      	        LD      A,(HL)          ; Get deleted byte
25DB: CD8626  	        CALL    OUTC            ; Echo it
25DE: C3FB25  	        JP      MORINP          ; Get more input
              	
25E1: 05      	DELCHR: DEC     B               ; Count bytes in buffer
25E2: 2B      	        DEC     HL              ; Back space buffer
25E3: CD8626  	        CALL    OUTC            ; Output character in A
25E6: C2FB25  	        JP      NZ,MORINP       ; Not end - Get more
25E9: CD8626  	OTKLN:  CALL    OUTC            ; Output character in A
25EC: CDAD2A  	KILIN:  CALL    PRNTCRLF        ; Output CRLF
25EF: C3F225  	        JP      TTYLIN          ; Get line again
              	
25F2:         	GETLIN:
25F2: 21F140  	TTYLIN: LD      HL,BUFFER       ; Get a line by character
25F5: 0601    	        LD      B,1             ; Set buffer as empty
25F7: AF      	        XOR     A
25F8: 32D440  	        LD      (NULFLG),A      ; Clear null flag
25FB: CDB026  	MORINP: CALL    CLOTST          ; Get character and test ^O
25FE: 4F      	        LD      C,A             ; Save character in C
25FF: FE7F    	        CP      DEL             ; Delete character?
2601: CAC125  	        JP      Z,DODEL         ; Yes - Process it
2604: 3AD440  	        LD      A,(NULFLG)      ; Get null flag
2607: B7      	        OR      A               ; Test null flag status
2608: CA1426  	        JP      Z,PROCES        ; Reset - Process character
260B: 3E00    	        LD      A,0             ; Set a null
260D: CD8626  	        CALL    OUTC            ; Output null
2610: AF      	        XOR     A               ; Clear A
2611: 32D440  	        LD      (NULFLG),A      ; Reset null flag
2614: 79      	PROCES: LD      A,C             ; Get character
2615: FE07    	        CP      CTRLG           ; Bell?
2617: CA5826  	        JP      Z,PUTCTL        ; Yes - Save it
261A: FE03    	        CP      CTRLC           ; Is it control "C"?
261C: CCAD2A  	        CALL    Z,PRNTCRLF      ; Yes - Output CRLF
261F: 37      	        SCF                     ; Flag break
2620: C8      	        RET     Z               ; Return if control "C"
2621: FE0D    	        CP      CR              ; Is it enter?
2623: CAA82A  	        JP      Z,ENDINP        ; Yes - Terminate input
2626: FE15    	        CP      CTRLU           ; Is it control "U"?
2628: CAEC25  	        JP      Z,KILIN         ; Yes - Get another line
262B: FE40    	        CP      '@'             ; Is it "kill line"?
262D: CAE925  	        JP      Z,OTKLN         ; Yes - Kill line
2630: FE5F    	        CP      '_'             ; Is it delete?
2632: CAE125  	        JP      Z,DELCHR        ; Yes - Delete character
2635: FE08    	        CP      BKSP            ; Is it backspace?
2637: CAE125  	        JP      Z,DELCHR        ; Yes - Delete character
263A: FE12    	        CP      CTRLR           ; Is it control "R"?
263C: C25326  	        JP      NZ,PUTBUF       ; No - Put in buffer
263F: C5      	        PUSH    BC              ; Save buffer length
2640: D5      	        PUSH    DE              ; Save DE
2641: E5      	        PUSH    HL              ; Save buffer address
2642: 3600    	        LD      (HL),0          ; Mark end of buffer
2644: CD5D3C  	        CALL    OUTNCR          ; Output and do CRLF
2647: 21F140  	        LD      HL,BUFFER       ; Point to buffer start
264A: CD4B31  	        CALL    PRS             ; Output buffer
264D: E1      	        POP     HL              ; Restore buffer address
264E: D1      	        POP     DE              ; Restore DE
264F: C1      	        POP     BC              ; Restore buffer length
2650: C3FB25  	        JP      MORINP          ; Get another character
              	
2653: FE20    	PUTBUF: CP      ' '             ; Is it a control code?
2655: DAFB25  	        JP      C,MORINP        ; Yes - Ignore
2658: 78      	PUTCTL: LD      A,B             ; Get number of bytes in buffer
2659: FE49    	        CP      72+1            ; Test for line overflow
265B: 3E07    	        LD      A,CTRLG         ; Set a bell
265D: D26D26  	        JP      NC,OUTNBS       ; Ring bell if buffer full
2660: 79      	        LD      A,C             ; Get character
2661: 71      	        LD      (HL),C          ; Save in buffer
2662: 325C41  	        LD      (LSTBIN),A      ; Save last input byte
2665: 23      	        INC     HL              ; Move up buffer
2666: 04      	        INC     B               ; Increment length
2667: CD8626  	OUTIT:  CALL    OUTC            ; Output the character entered
266A: C3FB25  	        JP      MORINP          ; Get another character
              	
266D: CD8626  	OUTNBS: CALL    OUTC            ; Output bell and back over it
2670: 3E08    	        LD      A,BKSP          ; Set back space
2672: C36726  	        JP      OUTIT           ; Output it and get more
              	
2675: 7C      	CPDEHL: LD      A,H             ; Get H
2676: 92      	        SUB     D               ; Compare with D
2677: C0      	        RET     NZ              ; Different - Exit
2678: 7D      	        LD      A,L             ; Get L
2679: 93      	        SUB     E               ; Compare with E
267A: C9      	        RET                     ; Return status
              	
267B: 7E      	CHKSYN: LD      A,(HL)          ; Check syntax of character
267C: E3      	        EX      (SP),HL         ; Address of test byte
267D: BE      	        CP      (HL)            ; Same as in code string?
267E: 23      	        INC     HL              ; Return address
267F: E3      	        EX      (SP),HL         ; Put it back
2680: CA0528  	        JP      Z,GETCHR        ; Yes - Get next character
2683: C3AD23  	        JP      SNERR           ; Different - ?SN Error
              	
2686: F5      	OUTC:   PUSH    AF              ; Save character
2687: 3AD540  	        LD      A,(CTLOFG)      ; Get control "O" flag
268A: B7      	        OR      A               ; Is it set?
268B: C28031  	        JP      NZ,POPAF        ; Yes - don't output
268E: F1      	        POP     AF              ; Restore character
268F: C5      	        PUSH    BC              ; Save buffer length
2690: F5      	        PUSH    AF              ; Save character
2691: FE20    	        CP      ' '             ; Is it a control code?
2693: DAAA26  	        JP      C,DINPOS        ; Yes - Don't INC POS(X)
2696: 3AD240  	        LD      A,(LWIDTH)      ; Get line width
2699: 47      	        LD      B,A             ; To B
269A: 3A3B41  	        LD      A,(CURPOS)      ; Get cursor position
269D: 04      	        INC     B               ; Width 255?
269E: CAA626  	        JP      Z,INCLEN        ; Yes - No width limit
26A1: 05      	        DEC     B               ; Restore width
26A2: B8      	        CP      B               ; At end of line?
26A3: CCAD2A  	        CALL    Z,PRNTCRLF      ; Yes - output CRLF
26A6: 3C      	INCLEN: INC     A               ; Move on one character
26A7: 323B41  	        LD      (CURPOS),A      ; Save new position
26AA: F1      	DINPOS: POP     AF              ; Restore character
26AB: C1      	        POP     BC              ; Restore buffer length
26AC: CD463C  	        CALL    MONOUT          ; Send it
26AF: C9      	        RET
              	
26B0: CD0A3B  	CLOTST: CALL    GETINP          ; Get input character
26B3: E67F    	        AND     01111111B       ; Strip bit 7
26B5: FE0F    	        CP      CTRLO           ; Is it control "O"?
26B7: C0      	        RET     NZ              ; No don't flip flag
26B8: 3AD540  	        LD      A,(CTLOFG)      ; Get flag
26BB: 2F      	        CPL                     ; Flip it
26BC: 32D540  	        LD      (CTLOFG),A      ; Put it back
26BF: AF      	        XOR     A               ; Null character
26C0: C9      	        RET
              	
26C1: CDD128  	LIST:   CALL    ATOH            ; ASCII number to DE
26C4: C0      	        RET     NZ              ; Return if anything extra
26C5: C1      	        POP     BC              ; Rubbish - Not needed
26C6: CD9924  	        CALL    SRCHLN          ; Search for line number in DE
26C9: C5      	        PUSH    BC              ; Save address of line
26CA: CD1727  	        CALL    SETLIN          ; Set up lines counter
26CD: E1      	LISTLP: POP     HL              ; Restore address of line
26CE: 4E      	        LD      C,(HL)          ; Get LSB of next line
26CF: 23      	        INC     HL
26D0: 46      	        LD      B,(HL)          ; Get MSB of next line
26D1: 23      	        INC     HL
26D2: 78      	        LD      A,B             ; BC = 0 (End of program)?
26D3: B1      	        OR      C
26D4: CAF823  	        JP      Z,PRNTOK        ; Yes - Go to command mode
26D7: CD2027  	        CALL    COUNT           ; Count lines
26DA: CD3028  	        CALL    TSTBRK          ; Test for break key
26DD: C5      	        PUSH    BC              ; Save address of next line
26DE: CDAD2A  	        CALL    PRNTCRLF        ; Output CRLF
26E1: 5E      	        LD      E,(HL)          ; Get LSB of line number
26E2: 23      	        INC     HL
26E3: 56      	        LD      D,(HL)          ; Get MSB of line number
26E4: 23      	        INC     HL
26E5: E5      	        PUSH    HL              ; Save address of line start
26E6: EB      	        EX      DE,HL           ; Line number to HL
26E7: CDEE37  	        CALL    PRNTHL          ; Output line number in decimal
26EA: 3E20    	        LD      A,' '           ; Space after line number
26EC: E1      	        POP     HL              ; Restore start of line address
26ED: CD8626  	LSTLP2: CALL    OUTC            ; Output character in A
26F0: 7E      	LSTLP3: LD      A,(HL)          ; Get next byte in line
26F1: B7      	        OR      A               ; End of line?
26F2: 23      	        INC     HL              ; To next byte in line
26F3: CACD26  	        JP      Z,LISTLP        ; Yes - get next line
26F6: F2ED26  	        JP      P,LSTLP2        ; No token - output it
26F9: D67F    	        SUB     ZEND-1          ; Find and output word
26FB: 4F      	        LD      C,A             ; Token offset+1 to C
26FC: 113621  	        LD      DE,WORDS        ; Reserved word list
26FF: 1A      	FNDTOK: LD      A,(DE)          ; Get character in list
2700: 13      	        INC     DE              ; Move on to next
2701: B7      	        OR      A               ; Is it start of word?
2702: F2FF26  	        JP      P,FNDTOK        ; No - Keep looking for word
2705: 0D      	        DEC     C               ; Count words
2706: C2FF26  	        JP      NZ,FNDTOK       ; Not there - keep looking
2709: E67F    	OUTWRD: AND     01111111B       ; Strip bit 7
270B: CD8626  	        CALL    OUTC            ; Output first character
270E: 1A      	        LD      A,(DE)          ; Get next character
270F: 13      	        INC     DE              ; Move on to next
2710: B7      	        OR      A               ; Is it end of word?
2711: F20927  	        JP      P,OUTWRD        ; No - output the rest
2714: C3F026  	        JP      LSTLP3          ; Next byte in line
              	
2717: E5      	SETLIN: PUSH    HL              ; Set up LINES counter
2718: 2AD840  	        LD      HL,(LINESN)     ; Get LINES number
271B: 22D640  	        LD      (LINESC),HL     ; Save in LINES counter
271E: E1      	        POP     HL
271F: C9      	        RET
              	
2720: E5      	COUNT:  PUSH    HL              ; Save code string address
2721: D5      	        PUSH    DE
2722: 2AD640  	        LD      HL,(LINESC)     ; Get LINES counter
2725: 11FFFF  	        LD      DE,-1
2728: ED5A    	        ADC     HL,DE           ; Decrement
272A: 22D640  	        LD      (LINESC),HL     ; Put it back
272D: D1      	        POP     DE
272E: E1      	        POP     HL              ; Restore code string address
272F: F0      	        RET     P               ; Return if more lines to go
2730: E5      	        PUSH    HL              ; Save code string address
2731: 2AD840  	        LD      HL,(LINESN)     ; Get LINES number
2734: 22D640  	        LD      (LINESC),HL     ; Reset LINES counter
2737: CD0A3B  	        CALL    GETINP          ; Get input character
273A: FE03    	        CP      CTRLC           ; Is it control "C"?
273C: CA4327  	        JP      Z,RSLNBK        ; Yes - Reset LINES and break
273F: E1      	        POP     HL              ; Restore code string address
2740: C32027  	        JP      COUNT           ; Keep on counting
              	
2743: 2AD840  	RSLNBK: LD      HL,(LINESN)     ; Get LINES number
2746: 22D640  	        LD      (LINESC),HL     ; Reset LINES counter
2749: C3A720  	        JP      BRKRET          ; Go and output "Break"
              	
274C: 3E64    	FOR:    LD      A,64H           ; Flag "FOR" assignment
274E: 325B41  	        LD      (FORFLG),A      ; Save "FOR" flag
2751: CDB329  	        CALL    LET             ; Set up initial index
2754: C1      	        POP     BC              ; Drop RETurn address
2755: E5      	        PUSH    HL              ; Save code string address
2756: CD9C29  	        CALL    DATA            ; Get next statement address
2759: 225741  	        LD      (LOOPST),HL     ; Save it for start of loop
275C: 210200  	        LD      HL,2            ; Offset for "FOR" block
275F: 39      	        ADD     HL,SP           ; Point to it
2760: CD5A23  	FORSLP: CALL    LOKFOR          ; Look for existing "FOR" block
2763: D1      	        POP     DE              ; Get code string address
2764: C27C27  	        JP      NZ,FORFND       ; No nesting found
2767: 09      	        ADD     HL,BC           ; Move into "FOR" block
2768: D5      	        PUSH    DE              ; Save code string address
2769: 2B      	        DEC     HL
276A: 56      	        LD      D,(HL)          ; Get MSB of loop statement
276B: 2B      	        DEC     HL
276C: 5E      	        LD      E,(HL)          ; Get LSB of loop statement
276D: 23      	        INC     HL
276E: 23      	        INC     HL
276F: E5      	        PUSH    HL              ; Save block address
2770: 2A5741  	        LD      HL,(LOOPST)     ; Get address of loop statement
2773: CD7526  	        CALL    CPDEHL          ; Compare the FOR loops
2776: E1      	        POP     HL              ; Restore block address
2777: C26027  	        JP      NZ,FORSLP       ; Different FORs - Find another
277A: D1      	        POP     DE              ; Restore code string address
277B: F9      	        LD      SP,HL           ; Remove all nested loops
              	
277C: EB      	FORFND: EX      DE,HL           ; Code string address to HL
277D: 0E08    	        LD      C,8
277F: CD8A23  	        CALL    CHKSTK          ; Check for 8 levels of stack
2782: E5      	        PUSH    HL              ; Save code string address
2783: 2A5741  	        LD      HL,(LOOPST)     ; Get first statement of loop
2786: E3      	        EX      (SP),HL         ; Save and restore code string
2787: E5      	        PUSH    HL              ; Re-save code string address
2788: 2AEC40  	        LD      HL,(LINEAT)     ; Get current line number
278B: E3      	        EX      (SP),HL         ; Save and restore code string
278C: CD752C  	        CALL    TSTNUM          ; Make sure it's a number
278F: CD7B26  	        CALL    CHKSYN          ; Make sure "TO" is next
2792: A6      	        .BYTE   ZTO          ; "TO" token
2793: CD722C  	        CALL    GETNUM          ; Get "TO" expression value
2796: E5      	        PUSH    HL              ; Save code string address
2797: CDA036  	        CALL    BCDEFP          ; Move "TO" value to BCDE
279A: E1      	        POP     HL              ; Restore code string address
279B: C5      	        PUSH    BC              ; Save "TO" value in block
279C: D5      	        PUSH    DE
279D: 010081  	        LD      BC,8100H        ; BCDE - 1 (default STEP)
27A0: 51      	        LD      D,C             ; C=0
27A1: 5A      	        LD      E,D             ; D=0
27A2: 7E      	        LD      A,(HL)          ; Get next byte in code string
27A3: FEAB    	        CP      ZSTEP           ; See if "STEP" is stated
27A5: 3E01    	        LD      A,1             ; Sign of step = 1
27A7: C2B827  	        JP      NZ,SAVSTP       ; No STEP given - Default to 1
27AA: CD0528  	        CALL    GETCHR          ; Jump over "STEP" token
27AD: CD722C  	        CALL    GETNUM          ; Get step value
27B0: E5      	        PUSH    HL              ; Save code string address
27B1: CDA036  	        CALL    BCDEFP          ; Move STEP to BCDE
27B4: CD5436  	        CALL    TSTSGN          ; Test sign of FPREG
27B7: E1      	        POP     HL              ; Restore code string address
27B8: C5      	SAVSTP: PUSH    BC              ; Save the STEP value in block
27B9: D5      	        PUSH    DE
27BA: F5      	        PUSH    AF              ; Save sign of STEP
27BB: 33      	        INC     SP              ; Don't save flags
27BC: E5      	        PUSH    HL              ; Save code string address
27BD: 2A5E41  	        LD      HL,(BRKLIN)     ; Get address of index variable
27C0: E3      	        EX      (SP),HL         ; Save and restore code string
27C1: 0681    	PUTFID: LD      B,ZFOR          ; "FOR" block marker
27C3: C5      	        PUSH    BC              ; Save it
27C4: 33      	        INC     SP              ; Don't save C
              	
27C5: CD3028  	RUNCNT: CALL    TSTBRK          ; Execution driver - Test break
27C8: 225E41  	        LD      (BRKLIN),HL     ; Save code address for break
27CB: 7E      	        LD      A,(HL)          ; Get next byte in code string
27CC: FE3A    	        CP      ':'             ; Multi statement line?
27CE: CAE527  	        JP      Z,EXCUTE        ; Yes - Execute it
27D1: B7      	        OR      A               ; End of line?
27D2: C2AD23  	        JP      NZ,SNERR        ; No - Syntax error
27D5: 23      	        INC     HL              ; Point to address of next line
27D6: 7E      	        LD      A,(HL)          ; Get LSB of line pointer
27D7: 23      	        INC     HL
27D8: B6      	        OR      (HL)            ; Is it zero (End of prog)?
27D9: CA5728  	        JP      Z,ENDPRG        ; Yes - Terminate execution
27DC: 23      	        INC     HL              ; Point to line number
27DD: 5E      	        LD      E,(HL)          ; Get LSB of line number
27DE: 23      	        INC     HL
27DF: 56      	        LD      D,(HL)          ; Get MSB of line number
27E0: EB      	        EX      DE,HL           ; Line number to HL
27E1: 22EC40  	        LD      (LINEAT),HL     ; Save as current line number
27E4: EB      	        EX      DE,HL           ; Line number back to DE
27E5: CD0528  	EXCUTE: CALL    GETCHR          ; Get key word
27E8: 11C527  	        LD      DE,RUNCNT       ; Where to RETurn to
27EB: D5      	        PUSH    DE              ; Save for RETurn
27EC: C8      	IFJMP:  RET     Z               ; Go to RUNCNT if end of STMT
27ED: D680    	ONJMP:  SUB     ZEND            ; Is it a token?
27EF: DAB329  	        JP      C,LET           ; No - try to assign it
27F2: FE25    	        CP      ZNEW+1-ZEND     ; END to NEW ?
27F4: D2AD23  	        JP      NC,SNERR        ; Not a key word - ?SN Error
27F7: 07      	        RLCA                    ; Double it
27F8: 4F      	        LD      C,A             ; BC = Offset into table
27F9: 0600    	        LD      B,0
27FB: EB      	        EX      DE,HL           ; Save code string address
27FC: 215522  	        LD      HL,WORDTB       ; Keyword address table
27FF: 09      	        ADD     HL,BC           ; Point to routine address
2800: 4E      	        LD      C,(HL)          ; Get LSB of routine address
2801: 23      	        INC     HL
2802: 46      	        LD      B,(HL)          ; Get MSB of routine address
2803: C5      	        PUSH    BC              ; Save routine address
2804: EB      	        EX      DE,HL           ; Restore code string address
              	
2805: 23      	GETCHR: INC     HL              ; Point to next character
2806: 7E      	        LD      A,(HL)          ; Get next code string byte
2807: FE3A    	        CP      ':'             ; Z if ':'
2809: D0      	        RET     NC              ; NC if > "9"
280A: FE20    	        CP      ' '
280C: CA0528  	        JP      Z,GETCHR        ; Skip over spaces
280F: FE30    	        CP      '0'
2811: 3F      	        CCF                     ; NC if < '0'
2812: 3C      	        INC     A               ; Test for zero - Leave carry
2813: 3D      	        DEC     A               ; Z if Null
2814: C9      	        RET
              	
2815: EB      	RESTOR: EX      DE,HL           ; Save code string address
2816: 2AEE40  	        LD      HL,(BASTXT)     ; Point to start of program
2819: CA2A28  	        JP      Z,RESTNL        ; Just RESTORE - reset pointer
281C: EB      	        EX      DE,HL           ; Restore code string address
281D: CDD128  	        CALL    ATOH            ; Get line number to DE
2820: E5      	        PUSH    HL              ; Save code string address
2821: CD9924  	        CALL    SRCHLN          ; Search for line number in DE
2824: 60      	        LD      H,B             ; HL = Address of line
2825: 69      	        LD      L,C
2826: D1      	        POP     DE              ; Restore code string address
2827: D27229  	        JP      NC,ULERR        ; ?UL Error if not found
282A: 2B      	RESTNL: DEC     HL              ; Byte before DATA statement
282B: 226C41  	UPDATA: LD      (NXTDAT),HL     ; Update DATA pointer
282E: EB      	        EX      DE,HL           ; Restore code string address
282F: C9      	        RET
              	
              	
2830: DF      	TSTBRK: RST     18H             ; Check input status
2831: C8      	        RET     Z               ; No key, go back
2832: D7      	        RST     10H             ; Get the key into A
2833: FE1B    	        CP      ESC             ; Escape key?
2835: 2811    	        JR      Z,BRK           ; Yes, break
2837: FE03    	        CP      CTRLC           ; <Ctrl-C>
2839: 280D    	        JR      Z,BRK           ; Yes, break
283B: FE13    	        CP      CTRLS           ; Stop scrolling?
283D: C0      	        RET     NZ              ; Other key, ignore
              	
              	
283E: D7      	STALL:  RST     10H             ; Wait for key
283F: FE11    	        CP      CTRLQ           ; Resume scrolling?
2841: C8      	        RET      Z              ; Release the chokehold
2842: FE03    	        CP      CTRLC           ; Second break?
2844: 2807    	        JR      Z,STOP          ; Break during hold exits prog
2846: 18F6    	        JR      STALL           ; Loop until <Ctrl-Q> or <brk>
              	
2848: 3EFF    	BRK     LD      A,$FF           ; Set BRKFLG
284A: 32DD40  	        LD      (BRKFLG),A      ; Store it
              	
              	
284D: C0      	STOP:   RET     NZ              ; Exit if anything else
284E: F6      	        .BYTE   0F6H            ; Flag "STOP"
284F: C0      	PEND:   RET     NZ              ; Exit if anything else
2850: 225E41  	        LD      (BRKLIN),HL     ; Save point of break
2853: 21      	        .BYTE   21H             ; Skip "OR 11111111B"
2854: F6FF    	INPBRK: OR      11111111B       ; Flag "Break" wanted
2856: C1      	        POP     BC              ; Return not needed and more
2857: 2AEC40  	ENDPRG: LD      HL,(LINEAT)     ; Get current line number
285A: F5      	        PUSH    AF              ; Save STOP / END status
285B: 7D      	        LD      A,L             ; Is it direct break?
285C: A4      	        AND     H
285D: 3C      	        INC     A               ; Line is -1 if direct break
285E: CA6A28  	        JP      Z,NOLIN         ; Yes - No line number
2861: 226241  	        LD      (ERRLIN),HL     ; Save line of break
2864: 2A5E41  	        LD      HL,(BRKLIN)     ; Get point of break
2867: 226441  	        LD      (CONTAD),HL     ; Save point to CONTinue
286A: AF      	NOLIN:  XOR     A
286B: 32D540  	        LD      (CTLOFG),A      ; Enable output
286E: CDA02A  	        CALL    STTLIN          ; Start a new line
2871: F1      	        POP     AF              ; Restore STOP / END status
2872: 215023  	        LD      HL,BRKMSG       ; "Break" message
2875: C2E123  	        JP      NZ,ERRIN        ; "in line" wanted?
2878: C3F823  	        JP      PRNTOK          ; Go to command mode
              	
287B: 2A6441  	CONT:   LD      HL,(CONTAD)     ; Get CONTinue address
287E: 7C      	        LD      A,H             ; Is it zero?
287F: B5      	        OR      L
2880: 1E20    	        LD      E,CN            ; ?CN Error
2882: CAC123  	        JP      Z,ERROR         ; Yes - output "?CN Error"
2885: EB      	        EX      DE,HL           ; Save code string address
2886: 2A6241  	        LD      HL,(ERRLIN)     ; Get line of last break
2889: 22EC40  	        LD      (LINEAT),HL     ; Set up current line number
288C: EB      	        EX      DE,HL           ; Restore code string address
288D: C9      	        RET                     ; CONTinue where left off
              	
288E: CDD333  	NULL:   CALL    GETINT          ; Get integer 0-255
2891: C0      	        RET     NZ              ; Return if bad value
2892: 32D140  	        LD      (NULLS),A       ; Set nulls number
2895: C9      	        RET
              	
              	
2896: E5      	ACCSUM: PUSH    HL              ; Save address in array
2897: 2ADA40  	        LD      HL,(CHKSUM)     ; Get check sum
289A: 0600    	        LD      B,0             ; BC - Value of byte
289C: 4F      	        LD      C,A
289D: 09      	        ADD     HL,BC           ; Add byte to check sum
289E: 22DA40  	        LD      (CHKSUM),HL     ; Re-save check sum
28A1: E1      	        POP     HL              ; Restore address in array
28A2: C9      	        RET
              	
28A3: 7E      	CHKLTR: LD      A,(HL)          ; Get byte
28A4: FE41    	        CP      'A'             ; < 'a' ?
28A6: D8      	        RET     C               ; Carry set if not letter
28A7: FE5B    	        CP      'Z'+1           ; > 'z' ?
28A9: 3F      	        CCF
28AA: C9      	        RET                     ; Carry set if not letter
              	
28AB: CD0528  	FPSINT: CALL    GETCHR          ; Get next character
28AE: CD722C  	POSINT: CALL    GETNUM          ; Get integer 0 to 32767
28B1: CD5436  	DEPINT: CALL    TSTSGN          ; Test sign of FPREG
28B4: FACC28  	        JP      M,FCERR         ; Negative - ?FC Error
28B7: 3A7741  	DEINT:  LD      A,(FPEXP)       ; Get integer value to DE
28BA: FE90    	        CP      80H+16          ; Exponent in range (16 bits)?
28BC: DAFC36  	        JP      C,FPINT         ; Yes - convert it
28BF: 018090  	        LD      BC,9080H        ; BCDE = -32768
28C2: 110000  	        LD      DE,0000
28C5: E5      	        PUSH    HL              ; Save code string address
28C6: CDCF36  	        CALL    CMPNUM          ; Compare FPREG with BCDE
28C9: E1      	        POP     HL              ; Restore code string address
28CA: 51      	        LD      D,C             ; MSB to D
28CB: C8      	        RET     Z               ; Return if in range
28CC: 1E08    	FCERR:  LD      E,FC            ; ?FC Error
28CE: C3C123  	        JP      ERROR           ; Output error-
              	
28D1: 2B      	ATOH:   DEC     HL              ; ASCII number to DE binary
28D2: 110000  	GETLN:  LD      DE,0            ; Get number to DE
28D5: CD0528  	GTLNLP: CALL    GETCHR          ; Get next character
28D8: D0      	        RET     NC              ; Exit if not a digit
28D9: E5      	        PUSH    HL              ; Save code string address
28DA: F5      	        PUSH    AF              ; Save digit
28DB: 219819  	        LD      HL,65529/10     ; Largest number 65529
28DE: CD7526  	        CALL    CPDEHL          ; Number in range?
28E1: DAAD23  	        JP      C,SNERR         ; No - ?SN Error
28E4: 62      	        LD      H,D             ; HL = Number
28E5: 6B      	        LD      L,E
28E6: 19      	        ADD     HL,DE           ; Times 2
28E7: 29      	        ADD     HL,HL           ; Times 4
28E8: 19      	        ADD     HL,DE           ; Times 5
28E9: 29      	        ADD     HL,HL           ; Times 10
28EA: F1      	        POP     AF              ; Restore digit
28EB: D630    	        SUB     '0'             ; Make it 0 to 9
28ED: 5F      	        LD      E,A             ; DE = Value of digit
28EE: 1600    	        LD      D,0
28F0: 19      	        ADD     HL,DE           ; Add to number
28F1: EB      	        EX      DE,HL           ; Number to DE
28F2: E1      	        POP     HL              ; Restore code string address
28F3: C3D528  	        JP      GTLNLP          ; Go to next character
              	
28F6: CAC924  	CLEAR:  JP      Z,INTVAR        ; Just "CLEAR" Keep parameters
28F9: CDAE28  	        CALL    POSINT          ; Get integer 0 to 32767 to DE
28FC: 2B      	        DEC     HL              ; Cancel increment
28FD: CD0528  	        CALL    GETCHR          ; Get next character
2900: E5      	        PUSH    HL              ; Save code string address
2901: 2A3F41  	        LD      HL,(LSTRAM)     ; Get end of RAM
2904: CA1929  	        JP      Z,STORED        ; No value given - Use stored
2907: E1      	        POP     HL              ; Restore code string address
2908: CD7B26  	        CALL    CHKSYN          ; Check for comma
290B: 2C      	        .BYTE      ','
290C: D5      	        PUSH    DE              ; Save number
290D: CDAE28  	        CALL    POSINT          ; Get integer 0 to 32767
2910: 2B      	        DEC     HL              ; Cancel increment
2911: CD0528  	        CALL    GETCHR          ; Get next character
2914: C2AD23  	        JP      NZ,SNERR        ; ?SN Error if more on line
2917: E3      	        EX      (SP),HL         ; Save code string address
2918: EB      	        EX      DE,HL           ; Number to DE
2919: 7D      	STORED: LD      A,L             ; Get LSB of new RAM top
291A: 93      	        SUB     E               ; Subtract LSB of string space
291B: 5F      	        LD      E,A             ; Save LSB
291C: 7C      	        LD      A,H             ; Get MSB of new RAM top
291D: 9A      	        SBC     A,D             ; Subtract MSB of string space
291E: 57      	        LD      D,A             ; Save MSB
291F: DAA223  	        JP      C,OMERR         ; ?OM Error if not enough mem
2922: E5      	        PUSH    HL              ; Save RAM top
2923: 2A6641  	        LD      HL,(PROGND)     ; Get program end
2926: 012800  	        LD      BC,40           ; 40 Bytes minimum working RAM
2929: 09      	        ADD     HL,BC           ; Get lowest address
292A: CD7526  	        CALL    CPDEHL          ; Enough memory?
292D: D2A223  	        JP      NC,OMERR        ; No - ?OM Error
2930: EB      	        EX      DE,HL           ; RAM top to HL
2931: 22EA40  	        LD      (STRSPC),HL     ; Set new string space
2934: E1      	        POP     HL              ; End of memory to use
2935: 223F41  	        LD      (LSTRAM),HL     ; Set new top of RAM
2938: E1      	        POP     HL              ; Restore code string address
2939: C3C924  	        JP      INTVAR          ; Initialise variables
              	
293C: CAC524  	RUN:    JP      Z,RUNFST        ; RUN from start if just RUN
293F: CDC924  	        CALL    INTVAR          ; Initialise variables
2942: 01C527  	        LD      BC,RUNCNT       ; Execution driver loop
2945: C35829  	        JP      RUNLIN          ; RUN from line number
              	
2948: 0E03    	GOSUB:  LD      C,3             ; 3 Levels of stack needed
294A: CD8A23  	        CALL    CHKSTK          ; Check for 3 levels of stack
294D: C1      	        POP     BC              ; Get return address
294E: E5      	        PUSH    HL              ; Save code string for RETURN
294F: E5      	        PUSH    HL              ; And for GOSUB routine
2950: 2AEC40  	        LD      HL,(LINEAT)     ; Get current line
2953: E3      	        EX      (SP),HL         ; Into stack - Code string out
2954: 3E8C    	        LD      A,ZGOSUB        ; "GOSUB" token
2956: F5      	        PUSH    AF              ; Save token
2957: 33      	        INC     SP              ; Don't save flags
              	
2958: C5      	RUNLIN: PUSH    BC              ; Save return address
2959: CDD128  	GOTO:   CALL    ATOH            ; ASCII number to DE binary
295C: CD9E29  	        CALL    REM             ; Get end of line
295F: E5      	        PUSH    HL              ; Save end of line
2960: 2AEC40  	        LD      HL,(LINEAT)     ; Get current line
2963: CD7526  	        CALL    CPDEHL          ; Line after current?
2966: E1      	        POP     HL              ; Restore end of line
2967: 23      	        INC     HL              ; Start of next line
2968: DC9C24  	        CALL    C,SRCHLP        ; Line is after current line
296B: D49924  	        CALL    NC,SRCHLN       ; Line is before current line
296E: 60      	        LD      H,B             ; Set up code string address
296F: 69      	        LD      L,C
2970: 2B      	        DEC     HL              ; Incremented after
2971: D8      	        RET     C               ; Line found
2972: 1E0E    	ULERR:  LD      E,UL            ; ?UL Error
2974: C3C123  	        JP      ERROR           ; Output error message
              	
2977: C0      	RETURN: RET     NZ              ; Return if not just RETURN
2978: 16FF    	        LD      D,-1            ; Flag "GOSUB" search
297A: CD5623  	        CALL    BAKSTK          ; Look "GOSUB" block
297D: F9      	        LD      SP,HL           ; Kill all FORs in subroutine
297E: FE8C    	        CP      ZGOSUB          ; Test for "GOSUB" token
2980: 1E04    	        LD      E,RG            ; ?RG Error
2982: C2C123  	        JP      NZ,ERROR        ; Error if no "GOSUB" found
2985: E1      	        POP     HL              ; Get RETURN line number
2986: 22EC40  	        LD      (LINEAT),HL     ; Save as current
2989: 23      	        INC     HL              ; Was it from direct statement?
298A: 7C      	        LD      A,H
298B: B5      	        OR      L               ; Return to line
298C: C29629  	        JP      NZ,RETLIN       ; No - Return to line
298F: 3A5C41  	        LD      A,(LSTBIN)      ; Any INPUT in subroutine?
2992: B7      	        OR      A               ; If so buffer is corrupted
2993: C2F723  	        JP      NZ,POPNOK       ; Yes - Go to command mode
2996: 21C527  	RETLIN: LD      HL,RUNCNT       ; Execution driver loop
2999: E3      	        EX      (SP),HL         ; Into stack - Code string out
299A: 3E      	        .BYTE      3EH             ; Skip "POP HL"
299B: E1      	NXTDTA: POP     HL              ; Restore code string address
              	
299C: 013A    	DATA:   .BYTE      01H,3AH         ; ':' End of statement
299E: 0E00    	REM:    LD      C,0             ; 00  End of statement
29A0: 0600    	        LD      B,0
29A2: 79      	NXTSTL: LD      A,C             ; Statement and byte
29A3: 48      	        LD      C,B
29A4: 47      	        LD      B,A             ; Statement end byte
29A5: 7E      	NXTSTT: LD      A,(HL)          ; Get byte
29A6: B7      	        OR      A               ; End of line?
29A7: C8      	        RET     Z               ; Yes - Exit
29A8: B8      	        CP      B               ; End of statement?
29A9: C8      	        RET     Z               ; Yes - Exit
29AA: 23      	        INC     HL              ; Next byte
29AB: FE22    	        CP      '"'             ; Literal string?
29AD: CAA229  	        JP      Z,NXTSTL        ; Yes - Look for another '"'
29B0: C3A529  	        JP      NXTSTT          ; Keep looking
              	
29B3: CD682E  	LET:    CALL    GETVAR          ; Get variable name
29B6: CD7B26  	        CALL    CHKSYN          ; Make sure "=" follows
29B9: B4      	        .BYTE      ZEQUAL          ; "=" token
29BA: D5      	        PUSH    DE              ; Save address of variable
29BB: 3A3D41  	        LD      A,(TYPE)        ; Get data type
29BE: F5      	        PUSH    AF              ; Save type
29BF: CD842C  	        CALL    EVAL            ; Evaluate expression
29C2: F1      	        POP     AF              ; Restore type
29C3: E3      	        EX      (SP),HL         ; Save code - Get var addr
29C4: 225E41  	        LD      (BRKLIN),HL     ; Save address of variable
29C7: 1F      	        RRA                     ; Adjust type
29C8: CD772C  	        CALL    CHKTYP          ; Check types are the same
29CB: CA062A  	        JP      Z,LETNUM        ; Numeric - Move value
29CE: E5      	LETSTR: PUSH    HL              ; Save address of string var
29CF: 2A7441  	        LD      HL,(FPREG)      ; Pointer to string entry
29D2: E5      	        PUSH    HL              ; Save it on stack
29D3: 23      	        INC     HL              ; Skip over length
29D4: 23      	        INC     HL
29D5: 5E      	        LD      E,(HL)          ; LSB of string address
29D6: 23      	        INC     HL
29D7: 56      	        LD      D,(HL)          ; MSB of string address
29D8: 2AEE40  	        LD      HL,(BASTXT)     ; Point to start of program
29DB: CD7526  	        CALL    CPDEHL          ; Is string before program?
29DE: D2F529  	        JP      NC,CRESTR       ; Yes - Create string entry
29E1: 2AEA40  	        LD      HL,(STRSPC)     ; Point to string space
29E4: CD7526  	        CALL    CPDEHL          ; Is string literal in program?
29E7: D1      	        POP     DE              ; Restore address of string
29E8: D2FD29  	        JP      NC,MVSTPT       ; Yes - Set up pointer
29EB: 214F41  	        LD      HL,TMPSTR       ; Temporary string pool
29EE: CD7526  	        CALL    CPDEHL          ; Is string in temporary pool?
29F1: D2FD29  	        JP      NC,MVSTPT       ; No - Set up pointer
29F4: 3E      	        .BYTE   3EH             ; Skip "POP DE"
29F5: D1      	CRESTR: POP     DE              ; Restore address of string
29F6: CDAC32  	        CALL    BAKTMP          ; Back to last tmp-str entry
29F9: EB      	        EX      DE,HL           ; Address of string entry
29FA: CDE530  	        CALL    SAVSTR          ; Save string in string area
29FD: CDAC32  	MVSTPT: CALL    BAKTMP          ; Back to last tmp-str entry
2A00: E1      	        POP     HL              ; Get string pointer
2A01: CDAF36  	        CALL    DETHL4          ; Move string pointer to var
2A04: E1      	        POP     HL              ; Restore code string address
2A05: C9      	        RET
              	
2A06: E5      	LETNUM: PUSH    HL              ; Save address of variable
2A07: CDAC36  	        CALL    FPTHL           ; Move value to variable
2A0A: D1      	        POP     DE              ; Restore address of variable
2A0B: E1      	        POP     HL              ; Restore code string address
2A0C: C9      	        RET
              	
2A0D: CDD333  	ON:     CALL    GETINT          ; Get integer 0-255
2A10: 7E      	        LD      A,(HL)          ; Get "GOTO" or "GOSUB" token
2A11: 47      	        LD      B,A             ; Save in B
2A12: FE8C    	        CP      ZGOSUB          ; "GOSUB" token?
2A14: CA1C2A  	        JP      Z,ONGO          ; Yes - Find line number
2A17: CD7B26  	        CALL    CHKSYN          ; Make sure it's "GOTO"
2A1A: 88      	        .BYTE   ZGOTO           ; "GOTO" token
2A1B: 2B      	        DEC     HL              ; Cancel increment
2A1C: 4B      	ONGO:   LD      C,E             ; Integer of branch value
2A1D: 0D      	ONGOLP: DEC     C               ; Count branches
2A1E: 78      	        LD      A,B             ; Get "GOTO" or "GOSUB" token
2A1F: CAED27  	        JP      Z,ONJMP         ; Go to that line if right one
2A22: CDD228  	        CALL    GETLN           ; Get line number to DE
2A25: FE2C    	        CP      ','             ; Another line number?
2A27: C0      	        RET     NZ              ; No - Drop through
2A28: C31D2A  	        JP      ONGOLP          ; Yes - loop
              	
2A2B: CD842C  	IF:     CALL    EVAL            ; Evaluate expression
2A2E: 7E      	        LD      A,(HL)          ; Get token
2A2F: FE88    	        CP      ZGOTO           ; "GOTO" token?
2A31: CA392A  	        JP      Z,IFGO          ; Yes - Get line
2A34: CD7B26  	        CALL    CHKSYN          ; Make sure it's "THEN"
2A37: A9      	        .BYTE      ZTHEN           ; "THEN" token
2A38: 2B      	        DEC     HL              ; Cancel increment
2A39: CD752C  	IFGO:   CALL    TSTNUM          ; Make sure it's numeric
2A3C: CD5436  	        CALL    TSTSGN          ; Test state of expression
2A3F: CA9E29  	        JP      Z,REM           ; False - Drop through
2A42: CD0528  	        CALL    GETCHR          ; Get next character
2A45: DA5929  	        JP      C,GOTO          ; Number - GOTO that line
2A48: C3EC27  	        JP      IFJMP           ; Otherwise do statement
              	
2A4B: 2B      	MRPRNT: DEC     HL              ; DEC 'cos GETCHR INCs
2A4C: CD0528  	        CALL    GETCHR          ; Get next character
2A4F: CAAD2A  	PRINT:  JP      Z,PRNTCRLF      ; CRLF if just PRINT
2A52: C8      	PRNTLP: RET     Z               ; End of list - Exit
2A53: FEA5    	        CP      ZTAB            ; "TAB(" token?
2A55: CAE02A  	        JP      Z,DOTAB         ; Yes - Do TAB routine
2A58: FEA8    	        CP      ZSPC            ; "SPC(" token?
2A5A: CAE02A  	        JP      Z,DOTAB         ; Yes - Do SPC routine
2A5D: E5      	        PUSH    HL              ; Save code string address
2A5E: FE2C    	        CP      ','             ; Comma?
2A60: CAC92A  	        JP      Z,DOCOM         ; Yes - Move to next zone
2A63: FE3B    	        CP      59 ;";"         ; Semi-colon?
2A65: CA032B  	        JP      Z,NEXITM        ; Do semi-colon routine
2A68: C1      	        POP     BC              ; Code string address to BC
2A69: CD842C  	        CALL    EVAL            ; Evaluate expression
2A6C: E5      	        PUSH    HL              ; Save code string address
2A6D: 3A3D41  	        LD      A,(TYPE)        ; Get variable type
2A70: B7      	        OR      A               ; Is it a string variable?
2A71: C2992A  	        JP      NZ,PRNTST       ; Yes - Output string contents
2A74: CDF937  	        CALL    NUMASC          ; Convert number to text
2A77: CD0931  	        CALL    CRTST           ; Create temporary string
2A7A: 3620    	        LD      (HL),' '        ; Followed by a space
2A7C: 2A7441  	        LD      HL,(FPREG)      ; Get length of output
2A7F: 34      	        INC     (HL)            ; Plus 1 for the space
2A80: 2A7441  	        LD      HL,(FPREG)      ; < Not needed >
2A83: 3AD240  	        LD      A,(LWIDTH)      ; Get width of line
2A86: 47      	        LD      B,A             ; To B
2A87: 04      	        INC     B               ; Width 255 (No limit)?
2A88: CA952A  	        JP      Z,PRNTNB        ; Yes - Output number string
2A8B: 04      	        INC     B               ; Adjust it
2A8C: 3A3B41  	        LD      A,(CURPOS)      ; Get cursor position
2A8F: 86      	        ADD     A,(HL)          ; Add length of string
2A90: 3D      	        DEC     A               ; Adjust it
2A91: B8      	        CP      B               ; Will output fit on this line?
2A92: D4AD2A  	        CALL    NC,PRNTCRLF     ; No - CRLF first
2A95: CD4E31  	PRNTNB: CALL    PRS1            ; Output string at (HL)
2A98: AF      	        XOR     A               ; Skip CALL by setting 'z' flag
2A99: C44E31  	PRNTST: CALL    NZ,PRS1         ; Output string at (HL)
2A9C: E1      	        POP     HL              ; Restore code string address
2A9D: C34B2A  	        JP      MRPRNT          ; See if more to PRINT
              	
2AA0: 3A3B41  	STTLIN: LD      A,(CURPOS)      ; Make sure on new line
2AA3: B7      	        OR      A               ; Already at start?
2AA4: C8      	        RET     Z               ; Yes - Do nothing
2AA5: C3AD2A  	        JP      PRNTCRLF        ; Start a new line
              	
2AA8: 3600    	ENDINP: LD      (HL),0          ; Mark end of buffer
2AAA: 21F040  	        LD      HL,BUFFER-1     ; Point to buffer
2AAD: 3E0D    	PRNTCRLF: LD    A,CR            ; Load a CR
2AAF: CD8626  	        CALL    OUTC            ; Output character
2AB2: 3E0A    	        LD      A,LF            ; Load a LF
2AB4: CD8626  	        CALL    OUTC            ; Output character
2AB7: AF      	DONULL: XOR     A               ; Set to position 0
2AB8: 323B41  	        LD      (CURPOS),A      ; Store it
2ABB: 3AD140  	        LD      A,(NULLS)       ; Get number of nulls
2ABE: 3D      	NULLP:  DEC     A               ; Count them
2ABF: C8      	        RET     Z               ; Return if done
2AC0: F5      	        PUSH    AF              ; Save count
2AC1: AF      	        XOR     A               ; Load a null
2AC2: CD8626  	        CALL    OUTC            ; Output it
2AC5: F1      	        POP     AF              ; Restore count
2AC6: C3BE2A  	        JP      NULLP           ; Keep counting
              	
2AC9: 3AD340  	DOCOM:  LD      A,(COMMAN)      ; Get comma width
2ACC: 47      	        LD      B,A             ; Save in B
2ACD: 3A3B41  	        LD      A,(CURPOS)      ; Get current position
2AD0: B8      	        CP      B               ; Within the limit?
2AD1: D4AD2A  	        CALL    NC,PRNTCRLF     ; No - output CRLF
2AD4: D2032B  	        JP      NC,NEXITM       ; Get next item
2AD7: D60E    	ZONELP: SUB     14              ; Next zone of 14 characters
2AD9: D2D72A  	        JP      NC,ZONELP       ; Repeat if more zones
2ADC: 2F      	        CPL                     ; Number of spaces to output
2ADD: C3F82A  	        JP      ASPCS           ; Output them
              	
2AE0: F5      	DOTAB:  PUSH    AF              ; Save token
2AE1: CDD033  	        CALL    FNDNUM          ; Evaluate expression
2AE4: CD7B26  	        CALL    CHKSYN          ; Make sure ")" follows
2AE7: 29      	        .BYTE   ")"
2AE8: 2B      	        DEC     HL              ; Back space on to ")"
2AE9: F1      	        POP     AF              ; Restore token
2AEA: D6A8    	        SUB     ZSPC            ; Was it "SPC(" ?
2AEC: E5      	        PUSH    HL              ; Save code string address
2AED: CAF32A  	        JP      Z,DOSPC         ; Yes - Do 'E' spaces
2AF0: 3A3B41  	        LD      A,(CURPOS)      ; Get current position
2AF3: 2F      	DOSPC:  CPL                     ; Number of spaces to print to
2AF4: 83      	        ADD     A,E             ; Total number to print
2AF5: D2032B  	        JP      NC,NEXITM       ; TAB < Current POS(X)
2AF8: 3C      	ASPCS:  INC     A               ; Output A spaces
2AF9: 47      	        LD      B,A             ; Save number to print
2AFA: 3E20    	        LD      A,' '           ; Space
2AFC: CD8626  	SPCLP:  CALL    OUTC            ; Output character in A
2AFF: 05      	        DEC     B               ; Count them
2B00: C2FC2A  	        JP      NZ,SPCLP        ; Repeat if more
2B03: E1      	NEXITM: POP     HL              ; Restore code string address
2B04: CD0528  	        CALL    GETCHR          ; Get next character
2B07: C3522A  	        JP      PRNTLP          ; More to print
              	
2B0A: 3F526564	REDO:   .BYTE   "?Redo from start",CR,LF,0
2B0E: 6F206672	
2B12: 6F6D2073	
2B16: 74617274	
2B1A: 0D0A00  	
              	
2B1D: 3A5D41  	BADINP: LD      A,(READFG)      ; READ or INPUT?
2B20: B7      	        OR      A
2B21: C2A723  	        JP      NZ,DATSNR       ; READ - ?SN Error
2B24: C1      	        POP     BC              ; Throw away code string addr
2B25: 210A2B  	        LD      HL,REDO         ; "Redo from start" message
2B28: CD4B31  	        CALL    PRS             ; Output string
2B2B: C3F824  	        JP      DOAGN           ; Do last INPUT again
              	
2B2E: CDB630  	INPUT:  CALL    IDTEST          ; Test for illegal direct
2B31: 7E      	        LD      A,(HL)          ; Get character after "INPUT"
2B32: FE22    	        CP      '"'             ; Is there a prompt string?
2B34: 3E00    	        LD      A,0             ; Clear A and leave flags
2B36: 32D540  	        LD      (CTLOFG),A      ; Enable output
2B39: C2482B  	        JP      NZ,NOPMPT       ; No prompt - get input
2B3C: CD0A31  	        CALL    QTSTR           ; Get string terminated by '"'
2B3F: CD7B26  	        CALL    CHKSYN          ; Check for ';' after prompt
2B42: 3B      	        .BYTE   ';'
2B43: E5      	        PUSH    HL              ; Save code string address
2B44: CD4E31  	        CALL    PRS1            ; Output prompt string
2B47: 3E      	        .BYTE   3EH             ; Skip "PUSH HL"
2B48: E5      	NOPMPT: PUSH    HL              ; Save code string address
2B49: CDFC24  	        CALL    PROMPT          ; Get input with "? " prompt
2B4C: C1      	        POP     BC              ; Restore code string address
2B4D: DA5428  	        JP      C,INPBRK        ; Break pressed - Exit
2B50: 23      	        INC     HL              ; Next byte
2B51: 7E      	        LD      A,(HL)          ; Get it
2B52: B7      	        OR      A               ; End of line?
2B53: 2B      	        DEC     HL              ; Back again
2B54: C5      	        PUSH    BC              ; Re-save code string address
2B55: CA9B29  	        JP      Z,NXTDTA        ; Yes - Find next DATA stmt
2B58: 362C    	        LD      (HL),','        ; Store comma as separator
2B5A: C3622B  	        JP      NXTITM          ; Get next item
              	
2B5D: E5      	READ:   PUSH    HL              ; Save code string address
2B5E: 2A6C41  	        LD      HL,(NXTDAT)     ; Next DATA statement
2B61: F6      	        .BYTE   0F6H            ; Flag "READ"
2B62: AF      	NXTITM: XOR     A               ; Flag "INPUT"
2B63: 325D41  	        LD      (READFG),A      ; Save "READ"/"INPUT" flag
2B66: E3      	        EX      (SP),HL         ; Get code str' , Save pointer
2B67: C36E2B  	        JP      GTVLUS          ; Get values
              	
2B6A: CD7B26  	NEDMOR: CALL    CHKSYN          ; Check for comma between items
2B6D: 2C      	        .BYTE      ','
2B6E: CD682E  	GTVLUS: CALL    GETVAR          ; Get variable name
2B71: E3      	        EX      (SP),HL         ; Save code str" , Get pointer
2B72: D5      	        PUSH    DE              ; Save variable address
2B73: 7E      	        LD      A,(HL)          ; Get next "INPUT"/"DATA" byte
2B74: FE2C    	        CP      ','             ; Comma?
2B76: CA962B  	        JP      Z,ANTVLU        ; Yes - Get another value
2B79: 3A5D41  	        LD      A,(READFG)      ; Is it READ?
2B7C: B7      	        OR      A
2B7D: C2032C  	        JP      NZ,FDTLP        ; Yes - Find next DATA stmt
2B80: 3E3F    	        LD      A,'?'           ; More INPUT needed
2B82: CD8626  	        CALL    OUTC            ; Output character
2B85: CDFC24  	        CALL    PROMPT          ; Get INPUT with prompt
2B88: D1      	        POP     DE              ; Variable address
2B89: C1      	        POP     BC              ; Code string address
2B8A: DA5428  	        JP      C,INPBRK        ; Break pressed
2B8D: 23      	        INC     HL              ; Point to next DATA byte
2B8E: 7E      	        LD      A,(HL)          ; Get byte
2B8F: B7      	        OR      A               ; Is it zero (No input) ?
2B90: 2B      	        DEC     HL              ; Back space INPUT pointer
2B91: C5      	        PUSH    BC              ; Save code string address
2B92: CA9B29  	        JP      Z,NXTDTA        ; Find end of buffer
2B95: D5      	        PUSH    DE              ; Save variable address
2B96: 3A3D41  	ANTVLU: LD      A,(TYPE)        ; Check data type
2B99: B7      	        OR      A               ; Is it numeric?
2B9A: CAC02B  	        JP      Z,INPBIN        ; Yes - Convert to binary
2B9D: CD0528  	        CALL    GETCHR          ; Get next character
2BA0: 57      	        LD      D,A             ; Save input character
2BA1: 47      	        LD      B,A             ; Again
2BA2: FE22    	        CP      '"'             ; Start of literal sting?
2BA4: CAB42B  	        JP      Z,STRENT        ; Yes - Create string entry
2BA7: 3A5D41  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
2BAA: B7      	        OR      A
2BAB: 57      	        LD      D,A             ; Save 00 if "INPUT"
2BAC: CAB12B  	        JP      Z,ITMSEP        ; "INPUT" - End with 00
2BAF: 163A    	        LD      D,':'           ; "DATA" - End with 00 or ':'
2BB1: 062C    	ITMSEP: LD      B,','           ; Item separator
2BB3: 2B      	        DEC     HL              ; Back space for DTSTR
2BB4: CD0D31  	STRENT: CALL    DTSTR           ; Get string terminated by D
2BB7: EB      	        EX      DE,HL           ; String address to DE
2BB8: 21CB2B  	        LD      HL,LTSTND       ; Where to go after LETSTR
2BBB: E3      	        EX      (SP),HL         ; Save HL , get input pointer
2BBC: D5      	        PUSH    DE              ; Save address of string
2BBD: C3CE29  	        JP      LETSTR          ; Assign string to variable
              	
2BC0: CD0528  	INPBIN: CALL    GETCHR          ; Get next character
2BC3: CD5B37  	        CALL    ASCTFP          ; Convert ASCII to FP number
2BC6: E3      	        EX      (SP),HL         ; Save input ptr, Get var addr
2BC7: CDAC36  	        CALL    FPTHL           ; Move FPREG to variable
2BCA: E1      	        POP     HL              ; Restore input pointer
2BCB: 2B      	LTSTND: DEC     HL              ; DEC 'cos GETCHR INCs
2BCC: CD0528  	        CALL    GETCHR          ; Get next character
2BCF: CAD72B  	        JP      Z,MORDT         ; End of line - More needed?
2BD2: FE2C    	        CP      ','             ; Another value?
2BD4: C21D2B  	        JP      NZ,BADINP       ; No - Bad input
2BD7: E3      	MORDT:  EX      (SP),HL         ; Get code string address
2BD8: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2BD9: CD0528  	        CALL    GETCHR          ; Get next character
2BDC: C26A2B  	        JP      NZ,NEDMOR       ; More needed - Get it
2BDF: D1      	        POP     DE              ; Restore DATA pointer
2BE0: 3A5D41  	        LD      A,(READFG)      ; "READ" or "INPUT" ?
2BE3: B7      	        OR      A
2BE4: EB      	        EX      DE,HL           ; DATA pointer to HL
2BE5: C22B28  	        JP      NZ,UPDATA       ; Update DATA pointer if "READ"
2BE8: D5      	        PUSH    DE              ; Save code string address
2BE9: B6      	        OR      (HL)            ; More input given?
2BEA: 21F22B  	        LD      HL,EXTIG        ; "?Extra ignored" message
2BED: C44B31  	        CALL    NZ,PRS          ; Output string if extra given
2BF0: E1      	        POP     HL              ; Restore code string address
2BF1: C9      	        RET
              	
2BF2: 3F457874	EXTIG:  .BYTE   "?Extra ignored",CR,LF,0
2BF6: 72612069	
2BFA: 676E6F72	
2BFE: 65640D0A	
2C02: 00      	
              	
2C03: CD9C29  	FDTLP:  CALL    DATA            ; Get next statement
2C06: B7      	        OR      A               ; End of line?
2C07: C21C2C  	        JP      NZ,FANDT        ; No - See if DATA statement
2C0A: 23      	        INC     HL
2C0B: 7E      	        LD      A,(HL)          ; End of program?
2C0C: 23      	        INC     HL
2C0D: B6      	        OR      (HL)            ; 00 00 Ends program
2C0E: 1E06    	        LD      E,OD            ; ?OD Error
2C10: CAC123  	        JP      Z,ERROR         ; Yes - Out of DATA
2C13: 23      	        INC     HL
2C14: 5E      	        LD      E,(HL)          ; LSB of line number
2C15: 23      	        INC     HL
2C16: 56      	        LD      D,(HL)          ; MSB of line number
2C17: EB      	        EX      DE,HL
2C18: 225941  	        LD      (DATLIN),HL     ; Set line of current DATA item
2C1B: EB      	        EX      DE,HL
2C1C: CD0528  	FANDT:  CALL    GETCHR          ; Get next character
2C1F: FE83    	        CP      ZDATA           ; "DATA" token
2C21: C2032C  	        JP      NZ,FDTLP        ; No "DATA" - Keep looking
2C24: C3962B  	        JP      ANTVLU          ; Found - Convert input
              	
2C27: 110000  	NEXT:   LD      DE,0            ; In case no index given
2C2A: C4682E  	NEXT1:  CALL    NZ,GETVAR       ; Get index address
2C2D: 225E41  	        LD      (BRKLIN),HL     ; Save code string address
2C30: CD5623  	        CALL    BAKSTK          ; Look for "FOR" block
2C33: C2B323  	        JP      NZ,NFERR        ; No "FOR" - ?NF Error
2C36: F9      	        LD      SP,HL           ; Clear nested loops
2C37: D5      	        PUSH    DE              ; Save index address
2C38: 7E      	        LD      A,(HL)          ; Get sign of STEP
2C39: 23      	        INC     HL
2C3A: F5      	        PUSH    AF              ; Save sign of STEP
2C3B: D5      	        PUSH    DE              ; Save index address
2C3C: CD9236  	        CALL    PHLTFP          ; Move index value to FPREG
2C3F: E3      	        EX      (SP),HL         ; Save address of TO value
2C40: E5      	        PUSH    HL              ; Save address of index
2C41: CDFF33  	        CALL    ADDPHL          ; Add STEP to index value
2C44: E1      	        POP     HL              ; Restore address of index
2C45: CDAC36  	        CALL    FPTHL           ; Move value to index variable
2C48: E1      	        POP     HL              ; Restore address of TO value
2C49: CDA336  	        CALL    LOADFP          ; Move TO value to BCDE
2C4C: E5      	        PUSH    HL              ; Save address of line of FOR
2C4D: CDCF36  	        CALL    CMPNUM          ; Compare index with TO value
2C50: E1      	        POP     HL              ; Restore address of line num
2C51: C1      	        POP     BC              ; Address of sign of STEP
2C52: 90      	        SUB     B               ; Compare with expected sign
2C53: CDA336  	        CALL    LOADFP          ; BC = Loop stmt,DE = Line num
2C56: CA622C  	        JP      Z,KILFOR        ; Loop finished - Terminate it
2C59: EB      	        EX      DE,HL           ; Loop statement line number
2C5A: 22EC40  	        LD      (LINEAT),HL     ; Set loop line number
2C5D: 69      	        LD      L,C             ; Set code string to loop
2C5E: 60      	        LD      H,B
2C5F: C3C127  	        JP      PUTFID          ; Put back "FOR" and continue
              	
2C62: F9      	KILFOR: LD      SP,HL           ; Remove "FOR" block
2C63: 2A5E41  	        LD      HL,(BRKLIN)     ; Code string after "NEXT"
2C66: 7E      	        LD      A,(HL)          ; Get next byte in code string
2C67: FE2C    	        CP      ','             ; More NEXTs ?
2C69: C2C527  	        JP      NZ,RUNCNT       ; No - Do next statement
2C6C: CD0528  	        CALL    GETCHR          ; Position to index name
2C6F: CD2A2C  	        CALL    NEXT1           ; Re-enter NEXT routine
              	; < will not RETurn to here , Exit to RUNCNT or Loop >
              	
2C72: CD842C  	GETNUM: CALL    EVAL            ; Get a numeric expression
2C75: F6      	TSTNUM: .BYTE      0F6H            ; Clear carry (numeric)
2C76: 37      	TSTSTR: SCF                     ; Set carry (string)
2C77: 3A3D41  	CHKTYP: LD      A,(TYPE)        ; Check types match
2C7A: 8F      	        ADC     A,A             ; Expected + actual
2C7B: B7      	        OR      A               ; Clear carry , set parity
2C7C: E8      	        RET     PE              ; Even parity - Types match
2C7D: C3BF23  	        JP      TMERR           ; Different types - Error
              	
2C80: CD7B26  	OPNPAR: CALL    CHKSYN          ; Make sure "(" follows
2C83: 28      	        .BYTE   "("
2C84: 2B      	EVAL:   DEC     HL              ; Evaluate expression & save
2C85: 1600    	        LD      D,0             ; Precedence value
2C87: D5      	EVAL1:  PUSH    DE              ; Save precedence
2C88: 0E01    	        LD      C,1
2C8A: CD8A23  	        CALL    CHKSTK          ; Check for 1 level of stack
2C8D: CDFB2C  	        CALL    OPRND           ; Get next expression value
2C90: 226041  	EVAL2:  LD      (NXTOPR),HL     ; Save address of next operator
2C93: 2A6041  	EVAL3:  LD      HL,(NXTOPR)     ; Restore address of next opr
2C96: C1      	        POP     BC              ; Precedence value and operator
2C97: 78      	        LD      A,B             ; Get precedence value
2C98: FE78    	        CP      78H             ; "AND" or "OR" ?
2C9A: D4752C  	        CALL    NC,TSTNUM       ; No - Make sure it's a number
2C9D: 7E      	        LD      A,(HL)          ; Get next operator / function
2C9E: 1600    	        LD      D,0             ; Clear Last relation
2CA0: D6B3    	RLTLP:  SUB     ZGTR            ; ">" Token
2CA2: DABC2C  	        JP      C,FOPRND        ; + - * / ^ AND OR - Test it
2CA5: FE03    	        CP      ZLTH+1-ZGTR     ; < = >
2CA7: D2BC2C  	        JP      NC,FOPRND       ; Function - Call it
2CAA: FE01    	        CP      ZEQUAL-ZGTR     ; "="
2CAC: 17      	        RLA                     ; <- Test for legal
2CAD: AA      	        XOR     D               ; <- combinations of < = >
2CAE: BA      	        CP      D               ; <- by combining last token
2CAF: 57      	        LD      D,A             ; <- with current one
2CB0: DAAD23  	        JP      C,SNERR         ; Error if "<<' '==" or ">>"
2CB3: 225541  	        LD      (CUROPR),HL     ; Save address of current token
2CB6: CD0528  	        CALL    GETCHR          ; Get next character
2CB9: C3A02C  	        JP      RLTLP           ; Treat the two as one
              	
2CBC: 7A      	FOPRND: LD      A,D             ; < = > found ?
2CBD: B7      	        OR      A
2CBE: C2E32D  	        JP      NZ,TSTRED       ; Yes - Test for reduction
2CC1: 7E      	        LD      A,(HL)          ; Get operator token
2CC2: 225541  	        LD      (CUROPR),HL     ; Save operator address
2CC5: D6AC    	        SUB     ZPLUS           ; Operator or function?
2CC7: D8      	        RET     C               ; Neither - Exit
2CC8: FE07    	        CP      ZOR+1-ZPLUS     ; Is it + - * / ^ AND OR ?
2CCA: D0      	        RET     NC              ; No - Exit
2CCB: 5F      	        LD      E,A             ; Coded operator
2CCC: 3A3D41  	        LD      A,(TYPE)        ; Get data type
2CCF: 3D      	        DEC     A               ; FF = numeric , 00 = string
2CD0: B3      	        OR      E               ; Combine with coded operator
2CD1: 7B      	        LD      A,E             ; Get coded operator
2CD2: CA4132  	        JP      Z,CONCAT        ; String concatenation
2CD5: 07      	        RLCA                    ; Times 2
2CD6: 83      	        ADD     A,E             ; Times 3
2CD7: 5F      	        LD      E,A             ; To DE (D is 0)
2CD8: 219F22  	        LD      HL,PRITAB       ; Precedence table
2CDB: 19      	        ADD     HL,DE           ; To the operator concerned
2CDC: 78      	        LD      A,B             ; Last operator precedence
2CDD: 56      	        LD      D,(HL)          ; Get evaluation precedence
2CDE: BA      	        CP      D               ; Compare with eval precedence
2CDF: D0      	        RET     NC              ; Exit if higher precedence
2CE0: 23      	        INC     HL              ; Point to routine address
2CE1: CD752C  	        CALL    TSTNUM          ; Make sure it's a number
              	
2CE4: C5      	STKTHS: PUSH    BC              ; Save last precedence & token
2CE5: 01932C  	        LD      BC,EVAL3        ; Where to go on prec' break
2CE8: C5      	        PUSH    BC              ; Save on stack for return
2CE9: 43      	        LD      B,E             ; Save operator
2CEA: 4A      	        LD      C,D             ; Save precedence
2CEB: CD8536  	        CALL    STAKFP          ; Move value to stack
2CEE: 58      	        LD      E,B             ; Restore operator
2CEF: 51      	        LD      D,C             ; Restore precedence
2CF0: 4E      	        LD      C,(HL)          ; Get LSB of routine address
2CF1: 23      	        INC     HL
2CF2: 46      	        LD      B,(HL)          ; Get MSB of routine address
2CF3: 23      	        INC     HL
2CF4: C5      	        PUSH    BC              ; Save routine address
2CF5: 2A5541  	        LD      HL,(CUROPR)     ; Address of current operator
2CF8: C3872C  	        JP      EVAL1           ; Loop until prec' break
              	
2CFB: AF      	OPRND:  XOR     A               ; Get operand routine
2CFC: 323D41  	        LD      (TYPE),A        ; Set numeric expected
2CFF: CD0528  	        CALL    GETCHR          ; Get next character
2D02: 1E24    	        LD      E,MO            ; ?MO Error
2D04: CAC123  	        JP      Z,ERROR         ; No operand - Error
2D07: DA5B37  	        JP      C,ASCTFP        ; Number - Get value
2D0A: CDA328  	        CALL    CHKLTR          ; See if a letter
2D0D: D2622D  	        JP      NC,CONVAR       ; Letter - Find variable
2D10: FE26    	        CP		'&'				; &H = HEX, &B = BINARY
2D12: 2012    	        JR		NZ, NOTAMP
2D14: CD0528  	        CALL    GETCHR          ; Get next character
2D17: FE48    	        CP      'H'             ; Hex number indicated? [function added]
2D19: CA9F3B  	        JP      Z,HEXTFP        ; Convert Hex to FPREG
2D1C: FE42    	        CP      'B'             ; Binary number indicated? [function added]
2D1E: CA0F3C  	        JP      Z,BINTFP        ; Convert Bin to FPREG
2D21: 1E02    	        LD      E,SN            ; If neither then a ?SN Error
2D23: CAC123  	        JP      Z,ERROR         ; 
2D26: FEAC    	NOTAMP: CP      ZPLUS           ; '+' Token ?
2D28: CAFB2C  	        JP      Z,OPRND         ; Yes - Look for operand
2D2B: FE2E    	        CP      '.'             ; '.' ?
2D2D: CA5B37  	        JP      Z,ASCTFP        ; Yes - Create FP number
2D30: FEAD    	        CP      ZMINUS          ; '-' Token ?
2D32: CA512D  	        JP      Z,MINUS         ; Yes - Do minus
2D35: FE22    	        CP      '"'             ; Literal string ?
2D37: CA0A31  	        JP      Z,QTSTR         ; Get string terminated by '"'
2D3A: FEAA    	        CP      ZNOT            ; "NOT" Token ?
2D3C: CA432E  	        JP      Z,EVNOT         ; Yes - Eval NOT expression
2D3F: FEA7    	        CP      ZFN             ; "FN" Token ?
2D41: CA6E30  	        JP      Z,DOFN          ; Yes - Do FN routine
2D44: D6B6    	        SUB     ZSGN            ; Is it a function?
2D46: D2732D  	        JP      NC,FNOFST       ; Yes - Evaluate function
2D49: CD802C  	EVLPAR: CALL    OPNPAR          ; Evaluate expression in "()"
2D4C: CD7B26  	        CALL    CHKSYN          ; Make sure ")" follows
2D4F: 29      	        .BYTE   ")"
2D50: C9      	        RET
              	
2D51: 167D    	MINUS:  LD      D,7DH           ; '-' precedence
2D53: CD872C  	        CALL    EVAL1           ; Evaluate until prec' break
2D56: 2A6041  	        LD      HL,(NXTOPR)     ; Get next operator address
2D59: E5      	        PUSH    HL              ; Save next operator address
2D5A: CD7D36  	        CALL    INVSGN          ; Negate value
2D5D: CD752C  	RETNUM: CALL    TSTNUM          ; Make sure it's a number
2D60: E1      	        POP     HL              ; Restore next operator address
2D61: C9      	        RET
              	
2D62: CD682E  	CONVAR: CALL    GETVAR          ; Get variable address to DE
2D65: E5      	FRMEVL: PUSH    HL              ; Save code string address
2D66: EB      	        EX      DE,HL           ; Variable address to HL
2D67: 227441  	        LD      (FPREG),HL      ; Save address of variable
2D6A: 3A3D41  	        LD      A,(TYPE)        ; Get type
2D6D: B7      	        OR      A               ; Numeric?
2D6E: CC9236  	        CALL    Z,PHLTFP        ; Yes - Move contents to FPREG
2D71: E1      	        POP     HL              ; Restore code string address
2D72: C9      	        RET
              	
2D73: 0600    	FNOFST: LD      B,0             ; Get address of function
2D75: 07      	        RLCA                    ; Double function offset
2D76: 4F      	        LD      C,A             ; BC = Offset in function table
2D77: C5      	        PUSH    BC              ; Save adjusted token value
2D78: CD0528  	        CALL    GETCHR          ; Get next character
2D7B: 79      	        LD      A,C             ; Get adjusted token value
2D7C: FE31    	        CP      2*(ZLEFT-ZSGN)-1; Adj' LEFT$,RIGHT$ or MID$ ?
2D7E: DA9A2D  	        JP      C,FNVAL         ; No - Do function
2D81: CD802C  	        CALL    OPNPAR          ; Evaluate expression  (X,...
2D84: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
2D87: 2C      	        .BYTE      ','
2D88: CD762C  	        CALL    TSTSTR          ; Make sure it's a string
2D8B: EB      	        EX      DE,HL           ; Save code string address
2D8C: 2A7441  	        LD      HL,(FPREG)      ; Get address of string
2D8F: E3      	        EX      (SP),HL         ; Save address of string
2D90: E5      	        PUSH    HL              ; Save adjusted token value
2D91: EB      	        EX      DE,HL           ; Restore code string address
2D92: CDD333  	        CALL    GETINT          ; Get integer 0-255
2D95: EB      	        EX      DE,HL           ; Save code string address
2D96: E3      	        EX      (SP),HL         ; Save integer,HL = adj' token
2D97: C3A22D  	        JP      GOFUNC          ; Jump to string function
              	
2D9A: CD492D  	FNVAL:  CALL    EVLPAR          ; Evaluate expression
2D9D: E3      	        EX      (SP),HL         ; HL = Adjusted token value
2D9E: 115D2D  	        LD      DE,RETNUM       ; Return number from function
2DA1: D5      	        PUSH    DE              ; Save on stack
2DA2: 01FE20  	GOFUNC: LD      BC,FNCTAB       ; Function routine addresses
2DA5: 09      	        ADD     HL,BC           ; Point to right address
2DA6: 4E      	        LD      C,(HL)          ; Get LSB of address
2DA7: 23      	        INC     HL              ;
2DA8: 66      	        LD      H,(HL)          ; Get MSB of address
2DA9: 69      	        LD      L,C             ; Address to HL
2DAA: E9      	        JP      (HL)            ; Jump to function
              	
2DAB: 15      	SGNEXP: DEC     D               ; Dee to flag negative exponent
2DAC: FEAD    	        CP      ZMINUS          ; '-' token ?
2DAE: C8      	        RET     Z               ; Yes - Return
2DAF: FE2D    	        CP      '-'             ; '-' ASCII ?
2DB1: C8      	        RET     Z               ; Yes - Return
2DB2: 14      	        INC     D               ; Inc to flag positive exponent
2DB3: FE2B    	        CP      '+'             ; '+' ASCII ?
2DB5: C8      	        RET     Z               ; Yes - Return
2DB6: FEAC    	        CP      ZPLUS           ; '+' token ?
2DB8: C8      	        RET     Z               ; Yes - Return
2DB9: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
2DBA: C9      	        RET                     ; Return "NZ"
              	
2DBB: F6      	POR:    .BYTE      0F6H            ; Flag "OR"
2DBC: AF      	PAND:   XOR     A               ; Flag "AND"
2DBD: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2DBE: CD752C  	        CALL    TSTNUM          ; Make sure it's a number
2DC1: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
2DC4: F1      	        POP     AF              ; Restore "AND" / "OR" flag
2DC5: EB      	        EX      DE,HL           ; <- Get last
2DC6: C1      	        POP     BC              ; <-  value
2DC7: E3      	        EX      (SP),HL         ; <-  from
2DC8: EB      	        EX      DE,HL           ; <-  stack
2DC9: CD9536  	        CALL    FPBCDE          ; Move last value to FPREG
2DCC: F5      	        PUSH    AF              ; Save "AND" / "OR" flag
2DCD: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
2DD0: F1      	        POP     AF              ; Restore "AND" / "OR" flag
2DD1: C1      	        POP     BC              ; Get value
2DD2: 79      	        LD      A,C             ; Get LSB
2DD3: 212C30  	        LD      HL,ACPASS       ; Address of save AC as current
2DD6: C2DE2D  	        JP      NZ,POR1         ; Jump if OR
2DD9: A3      	        AND     E               ; "AND" LSBs
2DDA: 4F      	        LD      C,A             ; Save LSB
2DDB: 78      	        LD      A,B             ; Get MBS
2DDC: A2      	        AND     D               ; "AND" MSBs
2DDD: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
2DDE: B3      	POR1:   OR      E               ; "OR" LSBs
2DDF: 4F      	        LD      C,A             ; Save LSB
2DE0: 78      	        LD      A,B             ; Get MSB
2DE1: B2      	        OR      D               ; "OR" MSBs
2DE2: E9      	        JP      (HL)            ; Save AC as current (ACPASS)
              	
2DE3: 21F52D  	TSTRED: LD      HL,CMPLOG       ; Logical compare routine
2DE6: 3A3D41  	        LD      A,(TYPE)        ; Get data type
2DE9: 1F      	        RRA                     ; Carry set = string
2DEA: 7A      	        LD      A,D             ; Get last precedence value
2DEB: 17      	        RLA                     ; Times 2 plus carry
2DEC: 5F      	        LD      E,A             ; To E
2DED: 1664    	        LD      D,64H           ; Relational precedence
2DEF: 78      	        LD      A,B             ; Get current precedence
2DF0: BA      	        CP      D               ; Compare with last
2DF1: D0      	        RET     NC              ; Eval if last was rel' or log'
2DF2: C3E42C  	        JP      STKTHS          ; Stack this one and get next
              	
2DF5: F72D    	CMPLOG: .WORD   CMPLG1          ; Compare two values / strings
2DF7: 79      	CMPLG1: LD      A,C             ; Get data type
2DF8: B7      	        OR      A
2DF9: 1F      	        RRA
2DFA: C1      	        POP     BC              ; Get last expression to BCDE
2DFB: D1      	        POP     DE
2DFC: F5      	        PUSH    AF              ; Save status
2DFD: CD772C  	        CALL    CHKTYP          ; Check that types match
2E00: 21392E  	        LD      HL,CMPRES       ; Result to comparison
2E03: E5      	        PUSH    HL              ; Save for RETurn
2E04: CACF36  	        JP      Z,CMPNUM        ; Compare values if numeric
2E07: AF      	        XOR     A               ; Compare two strings
2E08: 323D41  	        LD      (TYPE),A        ; Set type to numeric
2E0B: D5      	        PUSH    DE              ; Save string name
2E0C: CD8E32  	        CALL    GSTRCU          ; Get current string
2E0F: 7E      	        LD      A,(HL)          ; Get length of string
2E10: 23      	        INC     HL
2E11: 23      	        INC     HL
2E12: 4E      	        LD      C,(HL)          ; Get LSB of address
2E13: 23      	        INC     HL
2E14: 46      	        LD      B,(HL)          ; Get MSB of address
2E15: D1      	        POP     DE              ; Restore string name
2E16: C5      	        PUSH    BC              ; Save address of string
2E17: F5      	        PUSH    AF              ; Save length of string
2E18: CD9232  	        CALL    GSTRDE          ; Get second string
2E1B: CDA336  	        CALL    LOADFP          ; Get address of second string
2E1E: F1      	        POP     AF              ; Restore length of string 1
2E1F: 57      	        LD      D,A             ; Length to D
2E20: E1      	        POP     HL              ; Restore address of string 1
2E21: 7B      	CMPSTR: LD      A,E             ; Bytes of string 2 to do
2E22: B2      	        OR      D               ; Bytes of string 1 to do
2E23: C8      	        RET     Z               ; Exit if all bytes compared
2E24: 7A      	        LD      A,D             ; Get bytes of string 1 to do
2E25: D601    	        SUB     1
2E27: D8      	        RET     C               ; Exit if end of string 1
2E28: AF      	        XOR     A
2E29: BB      	        CP      E               ; Bytes of string 2 to do
2E2A: 3C      	        INC     A
2E2B: D0      	        RET     NC              ; Exit if end of string 2
2E2C: 15      	        DEC     D               ; Count bytes in string 1
2E2D: 1D      	        DEC     E               ; Count bytes in string 2
2E2E: 0A      	        LD      A,(BC)          ; Byte in string 2
2E2F: BE      	        CP      (HL)            ; Compare to byte in string 1
2E30: 23      	        INC     HL              ; Move up string 1
2E31: 03      	        INC     BC              ; Move up string 2
2E32: CA212E  	        JP      Z,CMPSTR        ; Same - Try next bytes
2E35: 3F      	        CCF                     ; Flag difference (">" or "<")
2E36: C35F36  	        JP      FLGDIF          ; "<" gives -1 , ">" gives +1
              	
2E39: 3C      	CMPRES: INC     A               ; Increment current value
2E3A: 8F      	        ADC     A,A             ; Double plus carry
2E3B: C1      	        POP     BC              ; Get other value
2E3C: A0      	        AND     B               ; Combine them
2E3D: C6FF    	        ADD     A,-1            ; Carry set if different
2E3F: 9F      	        SBC     A,A             ; 00 - Equal , FF - Different
2E40: C36636  	        JP      FLGREL          ; Set current value & continue
              	
2E43: 165A    	EVNOT:  LD      D,5AH           ; Precedence value for "NOT"
2E45: CD872C  	        CALL    EVAL1           ; Eval until precedence break
2E48: CD752C  	        CALL    TSTNUM          ; Make sure it's a number
2E4B: CDB728  	        CALL    DEINT           ; Get integer -32768 - 32767
2E4E: 7B      	        LD      A,E             ; Get LSB
2E4F: 2F      	        CPL                     ; Invert LSB
2E50: 4F      	        LD      C,A             ; Save "NOT" of LSB
2E51: 7A      	        LD      A,D             ; Get MSB
2E52: 2F      	        CPL                     ; Invert MSB
2E53: CD2C30  	        CALL    ACPASS          ; Save AC as current
2E56: C1      	        POP     BC              ; Clean up stack
2E57: C3932C  	        JP      EVAL3           ; Continue evaluation
              	
2E5A: 2B      	DIMRET: DEC     HL              ; DEC 'cos GETCHR INCs
2E5B: CD0528  	        CALL    GETCHR          ; Get next character
2E5E: C8      	        RET     Z               ; End of DIM statement
2E5F: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
2E62: 2C      	        .BYTE      ','
2E63: 015A2E  	DIM:    LD      BC,DIMRET       ; Return to "DIMRET"
2E66: C5      	        PUSH    BC              ; Save on stack
2E67: F6      	        .BYTE      0F6H            ; Flag "Create" variable
2E68: AF      	GETVAR: XOR     A               ; Find variable address,to DE
2E69: 323C41  	        LD      (LCRFLG),A      ; Set locate / create flag
2E6C: 46      	        LD      B,(HL)          ; Get First byte of name
2E6D: CDA328  	GTFNAM: CALL    CHKLTR          ; See if a letter
2E70: DAAD23  	        JP      C,SNERR         ; ?SN Error if not a letter
2E73: AF      	        XOR     A
2E74: 4F      	        LD      C,A             ; Clear second byte of name
2E75: 323D41  	        LD      (TYPE),A        ; Set type to numeric
2E78: CD0528  	        CALL    GETCHR          ; Get next character
2E7B: DA842E  	        JP      C,SVNAM2        ; Numeric - Save in name
2E7E: CDA328  	        CALL    CHKLTR          ; See if a letter
2E81: DA912E  	        JP      C,CHARTY        ; Not a letter - Check type
2E84: 4F      	SVNAM2: LD      C,A             ; Save second byte of name
2E85: CD0528  	ENDNAM: CALL    GETCHR          ; Get next character
2E88: DA852E  	        JP      C,ENDNAM        ; Numeric - Get another
2E8B: CDA328  	        CALL    CHKLTR          ; See if a letter
2E8E: D2852E  	        JP      NC,ENDNAM       ; Letter - Get another
2E91: D624    	CHARTY: SUB     '$'             ; String variable?
2E93: C2A02E  	        JP      NZ,NOTSTR       ; No - Numeric variable
2E96: 3C      	        INC     A               ; A = 1 (string type)
2E97: 323D41  	        LD      (TYPE),A        ; Set type to string
2E9A: 0F      	        RRCA                    ; A = 80H , Flag for string
2E9B: 81      	        ADD     A,C             ; 2nd byte of name has bit 7 on
2E9C: 4F      	        LD      C,A             ; Resave second byte on name
2E9D: CD0528  	        CALL    GETCHR          ; Get next character
2EA0: 3A5B41  	NOTSTR: LD      A,(FORFLG)      ; Array name needed ?
2EA3: 3D      	        DEC     A
2EA4: CA4D2F  	        JP      Z,ARLDSV        ; Yes - Get array name
2EA7: F2B02E  	        JP      P,NSCFOR        ; No array with "FOR" or "FN"
2EAA: 7E      	        LD      A,(HL)          ; Get byte again
2EAB: D628    	        SUB     '('             ; Subscripted variable?
2EAD: CA252F  	        JP      Z,SBSCPT        ; Yes - Sort out subscript
              	
2EB0: AF      	NSCFOR: XOR     A               ; Simple variable
2EB1: 325B41  	        LD      (FORFLG),A      ; Clear "FOR" flag
2EB4: E5      	        PUSH    HL              ; Save code string address
2EB5: 50      	        LD      D,B             ; DE = Variable name to find
2EB6: 59      	        LD      E,C
2EB7: 2A6E41  	        LD      HL,(FNRGNM)     ; FN argument name
2EBA: CD7526  	        CALL    CPDEHL          ; Is it the FN argument?
2EBD: 117041  	        LD      DE,FNARG        ; Point to argument value
2EC0: CA9535  	        JP      Z,POPHRT        ; Yes - Return FN argument value
2EC3: 2A6841  	        LD      HL,(VAREND)     ; End of variables
2EC6: EB      	        EX      DE,HL           ; Address of end of search
2EC7: 2A6641  	        LD      HL,(PROGND)     ; Start of variables address
2ECA: CD7526  	FNDVAR: CALL    CPDEHL          ; End of variable list table?
2ECD: CAE32E  	        JP      Z,CFEVAL        ; Yes - Called from EVAL?
2ED0: 79      	        LD      A,C             ; Get second byte of name
2ED1: 96      	        SUB     (HL)            ; Compare with name in list
2ED2: 23      	        INC     HL              ; Move on to first byte
2ED3: C2D82E  	        JP      NZ,FNTHR        ; Different - Find another
2ED6: 78      	        LD      A,B             ; Get first byte of name
2ED7: 96      	        SUB     (HL)            ; Compare with name in list
2ED8: 23      	FNTHR:  INC     HL              ; Move on to LSB of value
2ED9: CA172F  	        JP      Z,RETADR        ; Found - Return address
2EDC: 23      	        INC     HL              ; <- Skip
2EDD: 23      	        INC     HL              ; <- over
2EDE: 23      	        INC     HL              ; <- F.P.
2EDF: 23      	        INC     HL              ; <- value
2EE0: C3CA2E  	        JP      FNDVAR          ; Keep looking
              	
2EE3: E1      	CFEVAL: POP     HL              ; Restore code string address
2EE4: E3      	        EX      (SP),HL         ; Get return address
2EE5: D5      	        PUSH    DE              ; Save address of variable
2EE6: 11652D  	        LD      DE,FRMEVL       ; Return address in EVAL
2EE9: CD7526  	        CALL    CPDEHL          ; Called from EVAL ?
2EEC: D1      	        POP     DE              ; Restore address of variable
2EED: CA1A2F  	        JP      Z,RETNUL        ; Yes - Return null variable
2EF0: E3      	        EX      (SP),HL         ; Put back return
2EF1: E5      	        PUSH    HL              ; Save code string address
2EF2: C5      	        PUSH    BC              ; Save variable name
2EF3: 010600  	        LD      BC,6            ; 2 byte name plus 4 byte data
2EF6: 2A6A41  	        LD      HL,(ARREND)     ; End of arrays
2EF9: E5      	        PUSH    HL              ; Save end of arrays
2EFA: 09      	        ADD     HL,BC           ; Move up 6 bytes
2EFB: C1      	        POP     BC              ; Source address in BC
2EFC: E5      	        PUSH    HL              ; Save new end address
2EFD: CD7923  	        CALL    MOVUP           ; Move arrays up
2F00: E1      	        POP     HL              ; Restore new end address
2F01: 226A41  	        LD      (ARREND),HL     ; Set new end address
2F04: 60      	        LD      H,B             ; End of variables to HL
2F05: 69      	        LD      L,C
2F06: 226841  	        LD      (VAREND),HL     ; Set new end address
              	
2F09: 2B      	ZEROLP: DEC     HL              ; Back through to zero variable
2F0A: 3600    	        LD      (HL),0          ; Zero byte in variable
2F0C: CD7526  	        CALL    CPDEHL          ; Done them all?
2F0F: C2092F  	        JP      NZ,ZEROLP       ; No - Keep on going
2F12: D1      	        POP     DE              ; Get variable name
2F13: 73      	        LD      (HL),E          ; Store second character
2F14: 23      	        INC     HL
2F15: 72      	        LD      (HL),D          ; Store first character
2F16: 23      	        INC     HL
2F17: EB      	RETADR: EX      DE,HL           ; Address of variable in DE
2F18: E1      	        POP     HL              ; Restore code string address
2F19: C9      	        RET
              	
2F1A: 327741  	RETNUL: LD      (FPEXP),A       ; Set result to zero
2F1D: 214923  	        LD      HL,ZERBYT       ; Also set a null string
2F20: 227441  	        LD      (FPREG),HL      ; Save for EVAL
2F23: E1      	        POP     HL              ; Restore code string address
2F24: C9      	        RET
              	
2F25: E5      	SBSCPT: PUSH    HL              ; Save code string address
2F26: 2A3C41  	        LD      HL,(LCRFLG)     ; Locate/Create and Type
2F29: E3      	        EX      (SP),HL         ; Save and get code string
2F2A: 57      	        LD      D,A             ; Zero number of dimensions
2F2B: D5      	SCPTLP: PUSH    DE              ; Save number of dimensions
2F2C: C5      	        PUSH    BC              ; Save array name
2F2D: CDAB28  	        CALL    FPSINT          ; Get subscript (0-32767)
2F30: C1      	        POP     BC              ; Restore array name
2F31: F1      	        POP     AF              ; Get number of dimensions
2F32: EB      	        EX      DE,HL
2F33: E3      	        EX      (SP),HL         ; Save subscript value
2F34: E5      	        PUSH    HL              ; Save LCRFLG and TYPE
2F35: EB      	        EX      DE,HL
2F36: 3C      	        INC     A               ; Count dimensions
2F37: 57      	        LD      D,A             ; Save in D
2F38: 7E      	        LD      A,(HL)          ; Get next byte in code string
2F39: FE2C    	        CP      ','             ; Comma (more to come)?
2F3B: CA2B2F  	        JP      Z,SCPTLP        ; Yes - More subscripts
2F3E: CD7B26  	        CALL    CHKSYN          ; Make sure ")" follows
2F41: 29      	        .BYTE      ")"
2F42: 226041  	        LD      (NXTOPR),HL     ; Save code string address
2F45: E1      	        POP     HL              ; Get LCRFLG and TYPE
2F46: 223C41  	        LD      (LCRFLG),HL     ; Restore Locate/create & type
2F49: 1E00    	        LD      E,0             ; Flag not CSAVE* or CLOAD*
2F4B: D5      	        PUSH    DE              ; Save number of dimensions (D)
2F4C: 11      	        .BYTE      11H             ; Skip "PUSH HL" and "PUSH AF'
              	
2F4D: E5      	ARLDSV: PUSH    HL              ; Save code string address
2F4E: F5      	        PUSH    AF              ; A = 00 , Flags set = Z,N
2F4F: 2A6841  	        LD      HL,(VAREND)     ; Start of arrays
2F52: 3E      	        .BYTE      3EH             ; Skip "ADD HL,DE"
2F53: 19      	FNDARY: ADD     HL,DE           ; Move to next array start
2F54: EB      	        EX      DE,HL
2F55: 2A6A41  	        LD      HL,(ARREND)     ; End of arrays
2F58: EB      	        EX      DE,HL           ; Current array pointer
2F59: CD7526  	        CALL    CPDEHL          ; End of arrays found?
2F5C: CA852F  	        JP      Z,CREARY        ; Yes - Create array
2F5F: 7E      	        LD      A,(HL)          ; Get second byte of name
2F60: B9      	        CP      C               ; Compare with name given
2F61: 23      	        INC     HL              ; Move on
2F62: C2672F  	        JP      NZ,NXTARY       ; Different - Find next array
2F65: 7E      	        LD      A,(HL)          ; Get first byte of name
2F66: B8      	        CP      B               ; Compare with name given
2F67: 23      	NXTARY: INC     HL              ; Move on
2F68: 5E      	        LD      E,(HL)          ; Get LSB of next array address
2F69: 23      	        INC     HL
2F6A: 56      	        LD      D,(HL)          ; Get MSB of next array address
2F6B: 23      	        INC     HL
2F6C: C2532F  	        JP      NZ,FNDARY       ; Not found - Keep looking
2F6F: 3A3C41  	        LD      A,(LCRFLG)      ; Found Locate or Create it?
2F72: B7      	        OR      A
2F73: C2B623  	        JP      NZ,DDERR        ; Create - ?DD Error
2F76: F1      	        POP     AF              ; Locate - Get number of dim'ns
2F77: 44      	        LD      B,H             ; BC Points to array dim'ns
2F78: 4D      	        LD      C,L
2F79: CA9535  	        JP      Z,POPHRT        ; Jump if array load/save
2F7C: 96      	        SUB     (HL)            ; Same number of dimensions?
2F7D: CAE32F  	        JP      Z,FINDEL        ; Yes - Find element
2F80: 1E10    	BSERR:  LD      E,BS            ; ?BS Error
2F82: C3C123  	        JP      ERROR           ; Output error
              	
2F85: 110400  	CREARY: LD      DE,4            ; 4 Bytes per entry
2F88: F1      	        POP     AF              ; Array to save or 0 dim'ns?
2F89: CACC28  	        JP      Z,FCERR         ; Yes - ?FC Error
2F8C: 71      	        LD      (HL),C          ; Save second byte of name
2F8D: 23      	        INC     HL
2F8E: 70      	        LD      (HL),B          ; Save first byte of name
2F8F: 23      	        INC     HL
2F90: 4F      	        LD      C,A             ; Number of dimensions to C
2F91: CD8A23  	        CALL    CHKSTK          ; Check if enough memory
2F94: 23      	        INC     HL              ; Point to number of dimensions
2F95: 23      	        INC     HL
2F96: 225541  	        LD      (CUROPR),HL     ; Save address of pointer
2F99: 71      	        LD      (HL),C          ; Set number of dimensions
2F9A: 23      	        INC     HL
2F9B: 3A3C41  	        LD      A,(LCRFLG)      ; Locate of Create?
2F9E: 17      	        RLA                     ; Carry set = Create
2F9F: 79      	        LD      A,C             ; Get number of dimensions
2FA0: 010B00  	CRARLP: LD      BC,10+1         ; Default dimension size 10
2FA3: D2A82F  	        JP      NC,DEFSIZ       ; Locate - Set default size
2FA6: C1      	        POP     BC              ; Get specified dimension size
2FA7: 03      	        INC     BC              ; Include zero element
2FA8: 71      	DEFSIZ: LD      (HL),C          ; Save LSB of dimension size
2FA9: 23      	        INC     HL
2FAA: 70      	        LD      (HL),B          ; Save MSB of dimension size
2FAB: 23      	        INC     HL
2FAC: F5      	        PUSH    AF              ; Save num' of dim'ns an status
2FAD: E5      	        PUSH    HL              ; Save address of dim'n size
2FAE: CD4037  	        CALL    MLDEBC          ; Multiply DE by BC to find
2FB1: EB      	        EX      DE,HL           ; amount of mem needed (to DE)
2FB2: E1      	        POP     HL              ; Restore address of dimension
2FB3: F1      	        POP     AF              ; Restore number of dimensions
2FB4: 3D      	        DEC     A               ; Count them
2FB5: C2A02F  	        JP      NZ,CRARLP       ; Do next dimension if more
2FB8: F5      	        PUSH    AF              ; Save locate/create flag
2FB9: 42      	        LD      B,D             ; MSB of memory needed
2FBA: 4B      	        LD      C,E             ; LSB of memory needed
2FBB: EB      	        EX      DE,HL
2FBC: 19      	        ADD     HL,DE           ; Add bytes to array start
2FBD: DAA223  	        JP      C,OMERR         ; Too big - Error
2FC0: CD9323  	        CALL    ENFMEM          ; See if enough memory
2FC3: 226A41  	        LD      (ARREND),HL     ; Save new end of array
              	
2FC6: 2B      	ZERARY: DEC     HL              ; Back through array data
2FC7: 3600    	        LD      (HL),0          ; Set array element to zero
2FC9: CD7526  	        CALL    CPDEHL          ; All elements zeroed?
2FCC: C2C62F  	        JP      NZ,ZERARY       ; No - Keep on going
2FCF: 03      	        INC     BC              ; Number of bytes + 1
2FD0: 57      	        LD      D,A             ; A=0
2FD1: 2A5541  	        LD      HL,(CUROPR)     ; Get address of array
2FD4: 5E      	        LD      E,(HL)          ; Number of dimensions
2FD5: EB      	        EX      DE,HL           ; To HL
2FD6: 29      	        ADD     HL,HL           ; Two bytes per dimension size
2FD7: 09      	        ADD     HL,BC           ; Add number of bytes
2FD8: EB      	        EX      DE,HL           ; Bytes needed to DE
2FD9: 2B      	        DEC     HL
2FDA: 2B      	        DEC     HL
2FDB: 73      	        LD      (HL),E          ; Save LSB of bytes needed
2FDC: 23      	        INC     HL
2FDD: 72      	        LD      (HL),D          ; Save MSB of bytes needed
2FDE: 23      	        INC     HL
2FDF: F1      	        POP     AF              ; Locate / Create?
2FE0: DA0730  	        JP      C,ENDDIM        ; A is 0 , End if create
2FE3: 47      	FINDEL: LD      B,A             ; Find array element
2FE4: 4F      	        LD      C,A
2FE5: 7E      	        LD      A,(HL)          ; Number of dimensions
2FE6: 23      	        INC     HL
2FE7: 16      	        .BYTE      16H             ; Skip "POP HL"
2FE8: E1      	FNDELP: POP     HL              ; Address of next dim' size
2FE9: 5E      	        LD      E,(HL)          ; Get LSB of dim'n size
2FEA: 23      	        INC     HL
2FEB: 56      	        LD      D,(HL)          ; Get MSB of dim'n size
2FEC: 23      	        INC     HL
2FED: E3      	        EX      (SP),HL         ; Save address - Get index
2FEE: F5      	        PUSH    AF              ; Save number of dim'ns
2FEF: CD7526  	        CALL    CPDEHL          ; Dimension too large?
2FF2: D2802F  	        JP      NC,BSERR        ; Yes - ?BS Error
2FF5: E5      	        PUSH    HL              ; Save index
2FF6: CD4037  	        CALL    MLDEBC          ; Multiply previous by size
2FF9: D1      	        POP     DE              ; Index supplied to DE
2FFA: 19      	        ADD     HL,DE           ; Add index to pointer
2FFB: F1      	        POP     AF              ; Number of dimensions
2FFC: 3D      	        DEC     A               ; Count them
2FFD: 44      	        LD      B,H             ; MSB of pointer
2FFE: 4D      	        LD      C,L             ; LSB of pointer
2FFF: C2E82F  	        JP      NZ,FNDELP       ; More - Keep going
3002: 29      	        ADD     HL,HL           ; 4 Bytes per element
3003: 29      	        ADD     HL,HL
3004: C1      	        POP     BC              ; Start of array
3005: 09      	        ADD     HL,BC           ; Point to element
3006: EB      	        EX      DE,HL           ; Address of element to DE
3007: 2A6041  	ENDDIM: LD      HL,(NXTOPR)     ; Got code string address
300A: C9      	        RET
              	
300B: 2A6A41  	FRE:    LD      HL,(ARREND)     ; Start of free memory
300E: EB      	        EX      DE,HL           ; To DE
300F: 210000  	        LD      HL,0            ; End of free memory
3012: 39      	        ADD     HL,SP           ; Current stack value
3013: 3A3D41  	        LD      A,(TYPE)        ; Dummy argument type
3016: B7      	        OR      A
3017: CA2730  	        JP      Z,FRENUM        ; Numeric - Free variable space
301A: CD8E32  	        CALL    GSTRCU          ; Current string to pool
301D: CD8E31  	        CALL    GARBGE          ; Garbage collection
3020: 2AEA40  	        LD      HL,(STRSPC)     ; Bottom of string space in use
3023: EB      	        EX      DE,HL           ; To DE
3024: 2A5341  	        LD      HL,(STRBOT)     ; Bottom of string space
3027: 7D      	FRENUM: LD      A,L             ; Get LSB of end
3028: 93      	        SUB     E               ; Subtract LSB of beginning
3029: 4F      	        LD      C,A             ; Save difference if C
302A: 7C      	        LD      A,H             ; Get MSB of end
302B: 9A      	        SBC     A,D             ; Subtract MSB of beginning
302C: 41      	ACPASS: LD      B,C             ; Return integer AC
302D: 50      	ABPASS: LD      D,B             ; Return integer AB
302E: 1E00    	        LD      E,0
3030: 213D41  	        LD      HL,TYPE         ; Point to type
3033: 73      	        LD      (HL),E          ; Set type to numeric
3034: 0690    	        LD      B,80H+16        ; 16 bit integer
3036: C36B36  	        JP      RETINT          ; Return the integr
              	
3039: 3A3B41  	POS:    LD      A,(CURPOS)      ; Get cursor position
303C: 47      	PASSA:  LD      B,A             ; Put A into AB
303D: AF      	        XOR     A               ; Zero A
303E: C32D30  	        JP      ABPASS          ; Return integer AB
              	
3041: CDC430  	DEF:    CALL    CHEKFN          ; Get "FN" and name
3044: CDB630  	        CALL    IDTEST          ; Test for illegal direct
3047: 019C29  	        LD      BC,DATA         ; To get next statement
304A: C5      	        PUSH    BC              ; Save address for RETurn
304B: D5      	        PUSH    DE              ; Save address of function ptr
304C: CD7B26  	        CALL    CHKSYN          ; Make sure "(" follows
304F: 28      	        .BYTE      "("
3050: CD682E  	        CALL    GETVAR          ; Get argument variable name
3053: E5      	        PUSH    HL              ; Save code string address
3054: EB      	        EX      DE,HL           ; Argument address to HL
3055: 2B      	        DEC     HL
3056: 56      	        LD      D,(HL)          ; Get first byte of arg name
3057: 2B      	        DEC     HL
3058: 5E      	        LD      E,(HL)          ; Get second byte of arg name
3059: E1      	        POP     HL              ; Restore code string address
305A: CD752C  	        CALL    TSTNUM          ; Make sure numeric argument
305D: CD7B26  	        CALL    CHKSYN          ; Make sure ")" follows
3060: 29      	        .BYTE      ")"
3061: CD7B26  	        CALL    CHKSYN          ; Make sure "=" follows
3064: B4      	        .BYTE      ZEQUAL          ; "=" token
3065: 44      	        LD      B,H             ; Code string address to BC
3066: 4D      	        LD      C,L
3067: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
3068: 71      	        LD      (HL),C          ; Save LSB of FN code string
3069: 23      	        INC     HL
306A: 70      	        LD      (HL),B          ; Save MSB of FN code string
306B: C30331  	        JP      SVSTAD          ; Save address and do function
              	
306E: CDC430  	DOFN:   CALL    CHEKFN          ; Make sure FN follows
3071: D5      	        PUSH    DE              ; Save function pointer address
3072: CD492D  	        CALL    EVLPAR          ; Evaluate expression in "()"
3075: CD752C  	        CALL    TSTNUM          ; Make sure numeric result
3078: E3      	        EX      (SP),HL         ; Save code str , Get FN ptr
3079: 5E      	        LD      E,(HL)          ; Get LSB of FN code string
307A: 23      	        INC     HL
307B: 56      	        LD      D,(HL)          ; Get MSB of FN code string
307C: 23      	        INC     HL
307D: 7A      	        LD      A,D             ; And function DEFined?
307E: B3      	        OR      E
307F: CAB923  	        JP      Z,UFERR         ; No - ?UF Error
3082: 7E      	        LD      A,(HL)          ; Get LSB of argument address
3083: 23      	        INC     HL
3084: 66      	        LD      H,(HL)          ; Get MSB of argument address
3085: 6F      	        LD      L,A             ; HL = Arg variable address
3086: E5      	        PUSH    HL              ; Save it
3087: 2A6E41  	        LD      HL,(FNRGNM)     ; Get old argument name
308A: E3      	        EX      (SP),HL ;       ; Save old , Get new
308B: 226E41  	        LD      (FNRGNM),HL     ; Set new argument name
308E: 2A7241  	        LD      HL,(FNARG+2)    ; Get LSB,NLSB of old arg value
3091: E5      	        PUSH    HL              ; Save it
3092: 2A7041  	        LD      HL,(FNARG)      ; Get MSB,EXP of old arg value
3095: E5      	        PUSH    HL              ; Save it
3096: 217041  	        LD      HL,FNARG        ; HL = Value of argument
3099: D5      	        PUSH    DE              ; Save FN code string address
309A: CDAC36  	        CALL    FPTHL           ; Move FPREG to argument
309D: E1      	        POP     HL              ; Get FN code string address
309E: CD722C  	        CALL    GETNUM          ; Get value from function
30A1: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
30A2: CD0528  	        CALL    GETCHR          ; Get next character
30A5: C2AD23  	        JP      NZ,SNERR        ; Bad character in FN - Error
30A8: E1      	        POP     HL              ; Get MSB,EXP of old arg
30A9: 227041  	        LD      (FNARG),HL      ; Restore it
30AC: E1      	        POP     HL              ; Get LSB,NLSB of old arg
30AD: 227241  	        LD      (FNARG+2),HL    ; Restore it
30B0: E1      	        POP     HL              ; Get name of old arg
30B1: 226E41  	        LD      (FNRGNM),HL     ; Restore it
30B4: E1      	        POP     HL              ; Restore code string address
30B5: C9      	        RET
              	
30B6: E5      	IDTEST: PUSH    HL              ; Save code string address
30B7: 2AEC40  	        LD      HL,(LINEAT)     ; Get current line number
30BA: 23      	        INC     HL              ; -1 means direct statement
30BB: 7C      	        LD      A,H
30BC: B5      	        OR      L
30BD: E1      	        POP     HL              ; Restore code string address
30BE: C0      	        RET     NZ              ; Return if in program
30BF: 1E16    	        LD      E,ID            ; ?ID Error
30C1: C3C123  	        JP      ERROR
              	
30C4: CD7B26  	CHEKFN: CALL    CHKSYN          ; Make sure FN follows
30C7: A7      	        .BYTE      ZFN             ; "FN" token
30C8: 3E80    	        LD      A,80H
30CA: 325B41  	        LD      (FORFLG),A      ; Flag FN name to find
30CD: B6      	        OR      (HL)            ; FN name has bit 7 set
30CE: 47      	        LD      B,A             ; in first byte of name
30CF: CD6D2E  	        CALL    GTFNAM          ; Get FN name
30D2: C3752C  	        JP      TSTNUM          ; Make sure numeric function
              	
30D5: CD752C  	STR:    CALL    TSTNUM          ; Make sure it's a number
30D8: CDF937  	        CALL    NUMASC          ; Turn number into text
30DB: CD0931  	STR1:   CALL    CRTST           ; Create string entry for it
30DE: CD8E32  	        CALL    GSTRCU          ; Current string to pool
30E1: 01E932  	        LD      BC,TOPOOL       ; Save in string pool
30E4: C5      	        PUSH    BC              ; Save address on stack
              	
30E5: 7E      	SAVSTR: LD      A,(HL)          ; Get string length
30E6: 23      	        INC     HL
30E7: 23      	        INC     HL
30E8: E5      	        PUSH    HL              ; Save pointer to string
30E9: CD6431  	        CALL    TESTR           ; See if enough string space
30EC: E1      	        POP     HL              ; Restore pointer to string
30ED: 4E      	        LD      C,(HL)          ; Get LSB of address
30EE: 23      	        INC     HL
30EF: 46      	        LD      B,(HL)          ; Get MSB of address
30F0: CDFD30  	        CALL    CRTMST          ; Create string entry
30F3: E5      	        PUSH    HL              ; Save pointer to MSB of addr
30F4: 6F      	        LD      L,A             ; Length of string
30F5: CD8132  	        CALL    TOSTRA          ; Move to string area
30F8: D1      	        POP     DE              ; Restore pointer to MSB
30F9: C9      	        RET
              	
30FA: CD6431  	MKTMST: CALL    TESTR           ; See if enough string space
30FD: 214F41  	CRTMST: LD      HL,TMPSTR       ; Temporary string
3100: E5      	        PUSH    HL              ; Save it
3101: 77      	        LD      (HL),A          ; Save length of string
3102: 23      	        INC     HL
3103: 23      	SVSTAD: INC     HL
3104: 73      	        LD      (HL),E          ; Save LSB of address
3105: 23      	        INC     HL
3106: 72      	        LD      (HL),D          ; Save MSB of address
3107: E1      	        POP     HL              ; Restore pointer
3108: C9      	        RET
              	
3109: 2B      	CRTST:  DEC     HL              ; DEC - INCed after
310A: 0622    	QTSTR:  LD      B,'"'           ; Terminating quote
310C: 50      	        LD      D,B             ; Quote to D
310D: E5      	DTSTR:  PUSH    HL              ; Save start
310E: 0EFF    	        LD      C,-1            ; Set counter to -1
3110: 23      	QTSTLP: INC     HL              ; Move on
3111: 7E      	        LD      A,(HL)          ; Get byte
3112: 0C      	        INC     C               ; Count bytes
3113: B7      	        OR      A               ; End of line?
3114: CA1F31  	        JP      Z,CRTSTE        ; Yes - Create string entry
3117: BA      	        CP      D               ; Terminator D found?
3118: CA1F31  	        JP      Z,CRTSTE        ; Yes - Create string entry
311B: B8      	        CP      B               ; Terminator B found?
311C: C21031  	        JP      NZ,QTSTLP       ; No - Keep looking
311F: FE22    	CRTSTE: CP      '"'             ; End with '"'?
3121: CC0528  	        CALL    Z,GETCHR        ; Yes - Get next character
3124: E3      	        EX      (SP),HL         ; Starting quote
3125: 23      	        INC     HL              ; First byte of string
3126: EB      	        EX      DE,HL           ; To DE
3127: 79      	        LD      A,C             ; Get length
3128: CDFD30  	        CALL    CRTMST          ; Create string entry
312B: 114F41  	TSTOPL: LD      DE,TMPSTR       ; Temporary string
312E: 2A4141  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
3131: 227441  	        LD      (FPREG),HL      ; Save address of string ptr
3134: 3E01    	        LD      A,1
3136: 323D41  	        LD      (TYPE),A        ; Set type to string
3139: CDAF36  	        CALL    DETHL4          ; Move string to pool
313C: CD7526  	        CALL    CPDEHL          ; Out of string pool?
313F: 224141  	        LD      (TMSTPT),HL     ; Save new pointer
3142: E1      	        POP     HL              ; Restore code string address
3143: 7E      	        LD      A,(HL)          ; Get next code byte
3144: C0      	        RET     NZ              ; Return if pool OK
3145: 1E1E    	        LD      E,ST            ; ?ST Error
3147: C3C123  	        JP      ERROR           ; String pool overflow
              	
314A: 23      	PRNUMS: INC     HL              ; Skip leading space
314B: CD0931  	PRS:    CALL    CRTST           ; Create string entry for it
314E: CD8E32  	PRS1:   CALL    GSTRCU          ; Current string to pool
3151: CDA336  	        CALL    LOADFP          ; Move string block to BCDE
3154: 1C      	        INC     E               ; Length + 1
3155: 1D      	PRSLP:  DEC     E               ; Count characters
3156: C8      	        RET     Z               ; End of string
3157: 0A      	        LD      A,(BC)          ; Get byte to output
3158: CD8626  	        CALL    OUTC            ; Output character in A
315B: FE0D    	        CP      CR              ; Return?
315D: CCB72A  	        CALL    Z,DONULL        ; Yes - Do nulls
3160: 03      	        INC     BC              ; Next byte in string
3161: C35531  	        JP      PRSLP           ; More characters to output
              	
3164: B7      	TESTR:  OR      A               ; Test if enough room
3165: 0E      	        .BYTE      0EH             ; No garbage collection done
3166: F1      	GRBDON: POP     AF              ; Garbage collection done
3167: F5      	        PUSH    AF              ; Save status
3168: 2AEA40  	        LD      HL,(STRSPC)     ; Bottom of string space in use
316B: EB      	        EX      DE,HL           ; To DE
316C: 2A5341  	        LD      HL,(STRBOT)     ; Bottom of string area
316F: 2F      	        CPL                     ; Negate length (Top down)
3170: 4F      	        LD      C,A             ; -Length to BC
3171: 06FF    	        LD      B,-1            ; BC = -ve length of string
3173: 09      	        ADD     HL,BC           ; Add to bottom of space in use
3174: 23      	        INC     HL              ; Plus one for 2's complement
3175: CD7526  	        CALL    CPDEHL          ; Below string RAM area?
3178: DA8231  	        JP      C,TESTOS        ; Tidy up if not done else err
317B: 225341  	        LD      (STRBOT),HL     ; Save new bottom of area
317E: 23      	        INC     HL              ; Point to first byte of string
317F: EB      	        EX      DE,HL           ; Address to DE
3180: F1      	POPAF:  POP     AF              ; Throw away status push
3181: C9      	        RET
              	
3182: F1      	TESTOS: POP     AF              ; Garbage collect been done?
3183: 1E1A    	        LD      E,OS            ; ?OS Error
3185: CAC123  	        JP      Z,ERROR         ; Yes - Not enough string apace
3188: BF      	        CP      A               ; Flag garbage collect done
3189: F5      	        PUSH    AF              ; Save status
318A: 016631  	        LD      BC,GRBDON       ; Garbage collection done
318D: C5      	        PUSH    BC              ; Save for RETurn
318E: 2A3F41  	GARBGE: LD      HL,(LSTRAM)     ; Get end of RAM pointer
3191: 225341  	GARBLP: LD      (STRBOT),HL     ; Reset string pointer
3194: 210000  	        LD      HL,0
3197: E5      	        PUSH    HL              ; Flag no string found
3198: 2AEA40  	        LD      HL,(STRSPC)     ; Get bottom of string space
319B: E5      	        PUSH    HL              ; Save bottom of string space
319C: 214341  	        LD      HL,TMSTPL       ; Temporary string pool
319F: EB      	GRBLP:  EX      DE,HL
31A0: 2A4141  	        LD      HL,(TMSTPT)     ; Temporary string pool pointer
31A3: EB      	        EX      DE,HL
31A4: CD7526  	        CALL    CPDEHL          ; Temporary string pool done?
31A7: 019F31  	        LD      BC,GRBLP        ; Loop until string pool done
31AA: C2F331  	        JP      NZ,STPOOL       ; No - See if in string area
31AD: 2A6641  	        LD      HL,(PROGND)     ; Start of simple variables
31B0: EB      	SMPVAR: EX      DE,HL
31B1: 2A6841  	        LD      HL,(VAREND)     ; End of simple variables
31B4: EB      	        EX      DE,HL
31B5: CD7526  	        CALL    CPDEHL          ; All simple strings done?
31B8: CAC631  	        JP      Z,ARRLP         ; Yes - Do string arrays
31BB: 7E      	        LD      A,(HL)          ; Get type of variable
31BC: 23      	        INC     HL
31BD: 23      	        INC     HL
31BE: B7      	        OR      A               ; "S" flag set if string
31BF: CDF631  	        CALL    STRADD          ; See if string in string area
31C2: C3B031  	        JP      SMPVAR          ; Loop until simple ones done
              	
31C5: C1      	GNXARY: POP     BC              ; Scrap address of this array
31C6: EB      	ARRLP:  EX      DE,HL
31C7: 2A6A41  	        LD      HL,(ARREND)     ; End of string arrays
31CA: EB      	        EX      DE,HL
31CB: CD7526  	        CALL    CPDEHL          ; All string arrays done?
31CE: CA1C32  	        JP      Z,SCNEND        ; Yes - Move string if found
31D1: CDA336  	        CALL    LOADFP          ; Get array name to BCDE
31D4: 7B      	        LD      A,E             ; Get type of array     
31D5: E5      	        PUSH    HL              ; Save address of num of dim'ns
31D6: 09      	        ADD     HL,BC           ; Start of next array
31D7: B7      	        OR      A               ; Test type of array
31D8: F2C531  	        JP      P,GNXARY        ; Numeric array - Ignore it
31DB: 225541  	        LD      (CUROPR),HL     ; Save address of next array
31DE: E1      	        POP     HL              ; Get address of num of dim'ns
31DF: 4E      	        LD      C,(HL)          ; BC = Number of dimensions
31E0: 0600    	        LD      B,0
31E2: 09      	        ADD     HL,BC           ; Two bytes per dimension size
31E3: 09      	        ADD     HL,BC
31E4: 23      	        INC     HL              ; Plus one for number of dim'ns
31E5: EB      	GRBARY: EX      DE,HL
31E6: 2A5541  	        LD      HL,(CUROPR)     ; Get address of next array
31E9: EB      	        EX      DE,HL
31EA: CD7526  	        CALL    CPDEHL          ; Is this array finished?
31ED: CAC631  	        JP      Z,ARRLP         ; Yes - Get next one
31F0: 01E531  	        LD      BC,GRBARY       ; Loop until array all done
31F3: C5      	STPOOL: PUSH    BC              ; Save return address
31F4: F680    	        OR      80H             ; Flag string type
31F6: 7E      	STRADD: LD      A,(HL)          ; Get string length
31F7: 23      	        INC     HL
31F8: 23      	        INC     HL
31F9: 5E      	        LD      E,(HL)          ; Get LSB of string address
31FA: 23      	        INC     HL
31FB: 56      	        LD      D,(HL)          ; Get MSB of string address
31FC: 23      	        INC     HL
31FD: F0      	        RET     P               ; Not a string - Return
31FE: B7      	        OR      A               ; Set flags on string length
31FF: C8      	        RET     Z               ; Null string - Return
3200: 44      	        LD      B,H             ; Save variable pointer
3201: 4D      	        LD      C,L
3202: 2A5341  	        LD      HL,(STRBOT)     ; Bottom of new area
3205: CD7526  	        CALL    CPDEHL          ; String been done?
3208: 60      	        LD      H,B             ; Restore variable pointer
3209: 69      	        LD      L,C
320A: D8      	        RET     C               ; String done - Ignore
320B: E1      	        POP     HL              ; Return address
320C: E3      	        EX      (SP),HL         ; Lowest available string area
320D: CD7526  	        CALL    CPDEHL          ; String within string area?
3210: E3      	        EX      (SP),HL         ; Lowest available string area
3211: E5      	        PUSH    HL              ; Re-save return address
3212: 60      	        LD      H,B             ; Restore variable pointer
3213: 69      	        LD      L,C
3214: D0      	        RET     NC              ; Outside string area - Ignore
3215: C1      	        POP     BC              ; Get return , Throw 2 away
3216: F1      	        POP     AF              ; 
3217: F1      	        POP     AF              ; 
3218: E5      	        PUSH    HL              ; Save variable pointer
3219: D5      	        PUSH    DE              ; Save address of current
321A: C5      	        PUSH    BC              ; Put back return address
321B: C9      	        RET                     ; Go to it
              	
321C: D1      	SCNEND: POP     DE              ; Addresses of strings
321D: E1      	        POP     HL              ; 
321E: 7D      	        LD      A,L             ; HL = 0 if no more to do
321F: B4      	        OR      H
3220: C8      	        RET     Z               ; No more to do - Return
3221: 2B      	        DEC     HL
3222: 46      	        LD      B,(HL)          ; MSB of address of string
3223: 2B      	        DEC     HL
3224: 4E      	        LD      C,(HL)          ; LSB of address of string
3225: E5      	        PUSH    HL              ; Save variable address
3226: 2B      	        DEC     HL
3227: 2B      	        DEC     HL
3228: 6E      	        LD      L,(HL)          ; HL = Length of string
3229: 2600    	        LD      H,0
322B: 09      	        ADD     HL,BC           ; Address of end of string+1
322C: 50      	        LD      D,B             ; String address to DE
322D: 59      	        LD      E,C
322E: 2B      	        DEC     HL              ; Last byte in string
322F: 44      	        LD      B,H             ; Address to BC
3230: 4D      	        LD      C,L
3231: 2A5341  	        LD      HL,(STRBOT)     ; Current bottom of string area
3234: CD7C23  	        CALL    MOVSTR          ; Move string to new address
3237: E1      	        POP     HL              ; Restore variable address
3238: 71      	        LD      (HL),C          ; Save new LSB of address
3239: 23      	        INC     HL
323A: 70      	        LD      (HL),B          ; Save new MSB of address
323B: 69      	        LD      L,C             ; Next string area+1 to HL
323C: 60      	        LD      H,B
323D: 2B      	        DEC     HL              ; Next string area address
323E: C39131  	        JP      GARBLP          ; Look for more strings
              	
3241: C5      	CONCAT: PUSH    BC              ; Save prec' opr & code string
3242: E5      	        PUSH    HL              ; 
3243: 2A7441  	        LD      HL,(FPREG)      ; Get first string
3246: E3      	        EX      (SP),HL         ; Save first string
3247: CDFB2C  	        CALL    OPRND           ; Get second string
324A: E3      	        EX      (SP),HL         ; Restore first string
324B: CD762C  	        CALL    TSTSTR          ; Make sure it's a string
324E: 7E      	        LD      A,(HL)          ; Get length of second string
324F: E5      	        PUSH    HL              ; Save first string
3250: 2A7441  	        LD      HL,(FPREG)      ; Get second string
3253: E5      	        PUSH    HL              ; Save second string
3254: 86      	        ADD     A,(HL)          ; Add length of second string
3255: 1E1C    	        LD      E,LS            ; ?LS Error
3257: DAC123  	        JP      C,ERROR         ; String too long - Error
325A: CDFA30  	        CALL    MKTMST          ; Make temporary string
325D: D1      	        POP     DE              ; Get second string to DE
325E: CD9232  	        CALL    GSTRDE          ; Move to string pool if needed
3261: E3      	        EX      (SP),HL         ; Get first string
3262: CD9132  	        CALL    GSTRHL          ; Move to string pool if needed
3265: E5      	        PUSH    HL              ; Save first string
3266: 2A5141  	        LD      HL,(TMPSTR+2)   ; Temporary string address
3269: EB      	        EX      DE,HL           ; To DE
326A: CD7832  	        CALL    SSTSA           ; First string to string area
326D: CD7832  	        CALL    SSTSA           ; Second string to string area
3270: 21902C  	        LD      HL,EVAL2        ; Return to evaluation loop
3273: E3      	        EX      (SP),HL         ; Save return,get code string
3274: E5      	        PUSH    HL              ; Save code string address
3275: C32B31  	        JP      TSTOPL          ; To temporary string to pool
              	
3278: E1      	SSTSA:  POP     HL              ; Return address
3279: E3      	        EX      (SP),HL         ; Get string block,save return
327A: 7E      	        LD      A,(HL)          ; Get length of string
327B: 23      	        INC     HL
327C: 23      	        INC     HL
327D: 4E      	        LD      C,(HL)          ; Get LSB of string address
327E: 23      	        INC     HL
327F: 46      	        LD      B,(HL)          ; Get MSB of string address
3280: 6F      	        LD      L,A             ; Length to L
3281: 2C      	TOSTRA: INC     L               ; INC - DECed after
3282: 2D      	TSALP:  DEC     L               ; Count bytes moved
3283: C8      	        RET     Z               ; End of string - Return
3284: 0A      	        LD      A,(BC)          ; Get source
3285: 12      	        LD      (DE),A          ; Save destination
3286: 03      	        INC     BC              ; Next source
3287: 13      	        INC     DE              ; Next destination
3288: C38232  	        JP      TSALP           ; Loop until string moved
              	
328B: CD762C  	GETSTR: CALL    TSTSTR          ; Make sure it's a string
328E: 2A7441  	GSTRCU: LD      HL,(FPREG)      ; Get current string
3291: EB      	GSTRHL: EX      DE,HL           ; Save DE
3292: CDAC32  	GSTRDE: CALL    BAKTMP          ; Was it last tmp-str?
3295: EB      	        EX      DE,HL           ; Restore DE
3296: C0      	        RET     NZ              ; No - Return
3297: D5      	        PUSH    DE              ; Save string
3298: 50      	        LD      D,B             ; String block address to DE
3299: 59      	        LD      E,C
329A: 1B      	        DEC     DE              ; Point to length
329B: 4E      	        LD      C,(HL)          ; Get string length
329C: 2A5341  	        LD      HL,(STRBOT)     ; Current bottom of string area
329F: CD7526  	        CALL    CPDEHL          ; Last one in string area?
32A2: C2AA32  	        JP      NZ,POPHL        ; No - Return
32A5: 47      	        LD      B,A             ; Clear B (A=0)
32A6: 09      	        ADD     HL,BC           ; Remove string from str' area
32A7: 225341  	        LD      (STRBOT),HL     ; Save new bottom of str' area
32AA: E1      	POPHL:  POP     HL              ; Restore string
32AB: C9      	        RET
              	
32AC: 2A4141  	BAKTMP: LD      HL,(TMSTPT)     ; Get temporary string pool top
32AF: 2B      	        DEC     HL              ; Back
32B0: 46      	        LD      B,(HL)          ; Get MSB of address
32B1: 2B      	        DEC     HL              ; Back
32B2: 4E      	        LD      C,(HL)          ; Get LSB of address
32B3: 2B      	        DEC     HL              ; Back
32B4: 2B      	        DEC     HL              ; Back
32B5: CD7526  	        CALL    CPDEHL          ; String last in string pool?
32B8: C0      	        RET     NZ              ; Yes - Leave it
32B9: 224141  	        LD      (TMSTPT),HL     ; Save new string pool top
32BC: C9      	        RET
              	
32BD: 013C30  	LEN:    LD      BC,PASSA        ; To return integer A
32C0: C5      	        PUSH    BC              ; Save address
32C1: CD8B32  	GETLEN: CALL    GETSTR          ; Get string and its length
32C4: AF      	        XOR     A
32C5: 57      	        LD      D,A             ; Clear D
32C6: 323D41  	        LD      (TYPE),A        ; Set type to numeric
32C9: 7E      	        LD      A,(HL)          ; Get length of string
32CA: B7      	        OR      A               ; Set status flags
32CB: C9      	        RET
              	
32CC: 013C30  	ASC:    LD      BC,PASSA        ; To return integer A
32CF: C5      	        PUSH    BC              ; Save address
32D0: CDC132  	GTFLNM: CALL    GETLEN          ; Get length of string
32D3: CACC28  	        JP      Z,FCERR         ; Null string - Error
32D6: 23      	        INC     HL
32D7: 23      	        INC     HL
32D8: 5E      	        LD      E,(HL)          ; Get LSB of address
32D9: 23      	        INC     HL
32DA: 56      	        LD      D,(HL)          ; Get MSB of address
32DB: 1A      	        LD      A,(DE)          ; Get first byte of string
32DC: C9      	        RET
              	
32DD: 3E01    	CHR:    LD      A,1             ; One character string
32DF: CDFA30  	        CALL    MKTMST          ; Make a temporary string
32E2: CDD633  	        CALL    MAKINT          ; Make it integer A
32E5: 2A5141  	        LD      HL,(TMPSTR+2)   ; Get address of string
32E8: 73      	        LD      (HL),E          ; Save character
32E9: C1      	TOPOOL: POP     BC              ; Clean up stack
32EA: C32B31  	        JP      TSTOPL          ; Temporary string to pool
              	
32ED: CD8633  	LEFT:   CALL    LFRGNM          ; Get number and ending ")"
32F0: AF      	        XOR     A               ; Start at first byte in string
32F1: E3      	RIGHT1: EX      (SP),HL         ; Save code string,Get string
32F2: 4F      	        LD      C,A             ; Starting position in string
32F3: E5      	MID1:   PUSH    HL              ; Save string block address
32F4: 7E      	        LD      A,(HL)          ; Get length of string
32F5: B8      	        CP      B               ; Compare with number given
32F6: DAFB32  	        JP      C,ALLFOL        ; All following bytes required
32F9: 78      	        LD      A,B             ; Get new length
32FA: 11      	        .BYTE      11H             ; Skip "LD C,0"
32FB: 0E00    	ALLFOL: LD      C,0             ; First byte of string
32FD: C5      	        PUSH    BC              ; Save position in string
32FE: CD6431  	        CALL    TESTR           ; See if enough string space
3301: C1      	        POP     BC              ; Get position in string
3302: E1      	        POP     HL              ; Restore string block address
3303: E5      	        PUSH    HL              ; And re-save it
3304: 23      	        INC     HL
3305: 23      	        INC     HL
3306: 46      	        LD      B,(HL)          ; Get LSB of address
3307: 23      	        INC     HL
3308: 66      	        LD      H,(HL)          ; Get MSB of address
3309: 68      	        LD      L,B             ; HL = address of string
330A: 0600    	        LD      B,0             ; BC = starting address
330C: 09      	        ADD     HL,BC           ; Point to that byte
330D: 44      	        LD      B,H             ; BC = source string
330E: 4D      	        LD      C,L
330F: CDFD30  	        CALL    CRTMST          ; Create a string entry
3312: 6F      	        LD      L,A             ; Length of new string
3313: CD8132  	        CALL    TOSTRA          ; Move string to string area
3316: D1      	        POP     DE              ; Clear stack
3317: CD9232  	        CALL    GSTRDE          ; Move to string pool if needed
331A: C32B31  	        JP      TSTOPL          ; Temporary string to pool
              	
331D: CD8633  	RIGHT:  CALL    LFRGNM          ; Get number and ending ")"
3320: D1      	        POP     DE              ; Get string length
3321: D5      	        PUSH    DE              ; And re-save
3322: 1A      	        LD      A,(DE)          ; Get length
3323: 90      	        SUB     B               ; Move back N bytes
3324: C3F132  	        JP      RIGHT1          ; Go and get sub-string
              	
3327: EB      	MID:    EX      DE,HL           ; Get code string address
3328: 7E      	        LD      A,(HL)          ; Get next byte ',' or ")"
3329: CD8B33  	        CALL    MIDNUM          ; Get number supplied
332C: 04      	        INC     B               ; Is it character zero?
332D: 05      	        DEC     B
332E: CACC28  	        JP      Z,FCERR         ; Yes - Error
3331: C5      	        PUSH    BC              ; Save starting position
3332: 1EFF    	        LD      E,255           ; All of string
3334: FE29    	        CP      ')'             ; Any length given?
3336: CA4033  	        JP      Z,RSTSTR        ; No - Rest of string
3339: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
333C: 2C      	        .BYTE      ','
333D: CDD333  	        CALL    GETINT          ; Get integer 0-255
3340: CD7B26  	RSTSTR: CALL    CHKSYN          ; Make sure ")" follows
3343: 29      	        .BYTE      ")"
3344: F1      	        POP     AF              ; Restore starting position
3345: E3      	        EX      (SP),HL         ; Get string,8ave code string
3346: 01F332  	        LD      BC,MID1         ; Continuation of MID$ routine
3349: C5      	        PUSH    BC              ; Save for return
334A: 3D      	        DEC     A               ; Starting position-1
334B: BE      	        CP      (HL)            ; Compare with length
334C: 0600    	        LD      B,0             ; Zero bytes length
334E: D0      	        RET     NC              ; Null string if start past end
334F: 4F      	        LD      C,A             ; Save starting position-1
3350: 7E      	        LD      A,(HL)          ; Get length of string
3351: 91      	        SUB     C               ; Subtract start
3352: BB      	        CP      E               ; Enough string for it?
3353: 47      	        LD      B,A             ; Save maximum length available
3354: D8      	        RET     C               ; Truncate string if needed
3355: 43      	        LD      B,E             ; Set specified length
3356: C9      	        RET                     ; Go and create string
              	
3357: CDC132  	VAL:    CALL    GETLEN          ; Get length of string
335A: CA7434  	        JP      Z,RESZER        ; Result zero
335D: 5F      	        LD      E,A             ; Save length
335E: 23      	        INC     HL
335F: 23      	        INC     HL
3360: 7E      	        LD      A,(HL)          ; Get LSB of address
3361: 23      	        INC     HL
3362: 66      	        LD      H,(HL)          ; Get MSB of address
3363: 6F      	        LD      L,A             ; HL = String address
3364: E5      	        PUSH    HL              ; Save string address
3365: 19      	        ADD     HL,DE
3366: 46      	        LD      B,(HL)          ; Get end of string+1 byte
3367: 72      	        LD      (HL),D          ; Zero it to terminate
3368: E3      	        EX      (SP),HL         ; Save string end,get start
3369: C5      	        PUSH    BC              ; Save end+1 byte
336A: 7E      	        LD      A,(HL)          ; Get starting byte
336B: FE24    	    CP	'$'		; Hex number indicated? [function added]
336D: C27533  	    JP	NZ,VAL1
3370: CD9F3B  	    CALL	HEXTFP		; Convert Hex to FPREG
3373: 180D    	    JR	VAL3
3375: FE25    	VAL1:	CP	'%'		; Binary number indicated? [function added]
3377: C27F33  	    JP	NZ,VAL2
337A: CD0F3C  	    CALL	BINTFP		; Convert Bin to FPREG
337D: 1803    	    JR	VAL3
337F: CD5B37  	VAL2:   CALL    ASCTFP          ; Convert ASCII string to FP
3382: C1      	VAL3:   POP     BC              ; Restore end+1 byte
3383: E1      	        POP     HL              ; Restore end+1 address
3384: 70      	        LD      (HL),B          ; Put back original byte
3385: C9      	        RET
              	
3386: EB      	LFRGNM: EX      DE,HL           ; Code string address to HL
3387: CD7B26  	        CALL    CHKSYN          ; Make sure ")" follows
338A: 29      	        .BYTE      ")"
338B: C1      	MIDNUM: POP     BC              ; Get return address
338C: D1      	        POP     DE              ; Get number supplied
338D: C5      	        PUSH    BC              ; Re-save return address
338E: 43      	        LD      B,E             ; Number to B
338F: C9      	        RET
              	
3390: CDD633  	INP:    CALL    MAKINT          ; Make it integer A
3393: 32CF40  	        LD      (INPORT),A      ; Set input port
3396: CDCE40  	        CALL    INPSUB          ; Get input from port
3399: C33C30  	        JP      PASSA           ; Return integer A
              	
339C: CDC033  	POUT:   CALL    SETIO           ; Set up port number
339F: C39640  	        JP      OUTSUB          ; Output data and return
              	
33A2: CDC033  	WAIT:   CALL    SETIO           ; Set up port number
33A5: F5      	        PUSH    AF              ; Save AND mask
33A6: 1E00    	        LD      E,0             ; Assume zero if none given
33A8: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
33A9: CD0528  	        CALL    GETCHR          ; Get next character
33AC: CAB633  	        JP      Z,NOXOR         ; No XOR byte given
33AF: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
33B2: 2C      	        .BYTE      ','
33B3: CDD333  	        CALL    GETINT          ; Get integer 0-255 to XOR with
33B6: C1      	NOXOR:  POP     BC              ; Restore AND mask
33B7: CDCE40  	WAITLP: CALL    INPSUB          ; Get input
33BA: AB      	        XOR     E               ; Flip selected bits
33BB: A0      	        AND     B               ; Result non-zero?
33BC: CAB733  	        JP      Z,WAITLP        ; No = keep waiting
33BF: C9      	        RET
              	
33C0: CDD333  	SETIO:  CALL    GETINT          ; Get integer 0-255
33C3: 32CF40  	        LD      (INPORT),A      ; Set input port
33C6: 329740  	        LD      (OTPORT),A      ; Set output port
33C9: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
33CC: 2C      	        .BYTE      ','
33CD: C3D333  	        JP      GETINT          ; Get integer 0-255 and return
              	
33D0: CD0528  	FNDNUM: CALL    GETCHR          ; Get next character
33D3: CD722C  	GETINT: CALL    GETNUM          ; Get a number from 0 to 255
33D6: CDB128  	MAKINT: CALL    DEPINT          ; Make sure value 0 - 255
33D9: 7A      	        LD      A,D             ; Get MSB of number
33DA: B7      	        OR      A               ; Zero?
33DB: C2CC28  	        JP      NZ,FCERR        ; No - Error
33DE: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
33DF: CD0528  	        CALL    GETCHR          ; Get next character
33E2: 7B      	        LD      A,E             ; Get number to A
33E3: C9      	        RET
              	
33E4: CDB728  	PEEK:   CALL    DEINT           ; Get memory address
33E7: 1A      	        LD      A,(DE)          ; Get byte in memory
33E8: C33C30  	        JP      PASSA           ; Return integer A
              	
33EB: CD722C  	POKE:   CALL    GETNUM          ; Get memory address
33EE: CDB728  	        CALL    DEINT           ; Get integer -32768 to 3276
33F1: D5      	        PUSH    DE              ; Save memory address
33F2: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
33F5: 2C      	        .BYTE      ','
33F6: CDD333  	        CALL    GETINT          ; Get integer 0-255
33F9: D1      	        POP     DE              ; Restore memory address
33FA: 12      	        LD      (DE),A          ; Load it into memory
33FB: C9      	        RET
              	
33FC: 21D238  	ROUND:  LD      HL,HALF         ; Add 0.5 to FPREG
33FF: CDA336  	ADDPHL: CALL    LOADFP          ; Load FP at (HL) to BCDE
3402: C30E34  	        JP      FPADD           ; Add BCDE to FPREG
              	
3405: CDA336  	SUBPHL: CALL    LOADFP          ; FPREG = -FPREG + number at HL
3408: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
3409: C1      	PSUB:   POP     BC              ; Get FP number from stack
340A: D1      	        POP     DE
340B: CD7D36  	SUBCDE: CALL    INVSGN          ; Negate FPREG
340E: 78      	FPADD:  LD      A,B             ; Get FP exponent
340F: B7      	        OR      A               ; Is number zero?
3410: C8      	        RET     Z               ; Yes - Nothing to add
3411: 3A7741  	        LD      A,(FPEXP)       ; Get FPREG exponent
3414: B7      	        OR      A               ; Is this number zero?
3415: CA9536  	        JP      Z,FPBCDE        ; Yes - Move BCDE to FPREG
3418: 90      	        SUB     B               ; BCDE number larger?
3419: D22834  	        JP      NC,NOSWAP       ; No - Don't swap them
341C: 2F      	        CPL                     ; Two's complement
341D: 3C      	        INC     A               ;  FP exponent
341E: EB      	        EX      DE,HL
341F: CD8536  	        CALL    STAKFP          ; Put FPREG on stack
3422: EB      	        EX      DE,HL
3423: CD9536  	        CALL    FPBCDE          ; Move BCDE to FPREG
3426: C1      	        POP     BC              ; Restore number from stack
3427: D1      	        POP     DE
3428: FE19    	NOSWAP: CP      24+1            ; Second number insignificant?
342A: D0      	        RET     NC              ; Yes - First number is result
342B: F5      	        PUSH    AF              ; Save number of bits to scale
342C: CDBA36  	        CALL    SIGNS           ; Set MSBs & sign of result
342F: 67      	        LD      H,A             ; Save sign of result
3430: F1      	        POP     AF              ; Restore scaling factor
3431: CDD334  	        CALL    SCALE           ; Scale BCDE to same exponent
3434: B4      	        OR      H               ; Result to be positive?
3435: 217441  	        LD      HL,FPREG        ; Point to FPREG
3438: F24E34  	        JP      P,MINCDE        ; No - Subtract FPREG from CDE
343B: CDB334  	        CALL    PLUCDE          ; Add FPREG to CDE
343E: D29434  	        JP      NC,RONDUP       ; No overflow - Round it up
3441: 23      	        INC     HL              ; Point to exponent
3442: 34      	        INC     (HL)            ; Increment it
3443: CABC23  	        JP      Z,OVERR         ; Number overflowed - Error
3446: 2E01    	        LD      L,1             ; 1 bit to shift right
3448: CDE934  	        CALL    SHRT1           ; Shift result right
344B: C39434  	        JP      RONDUP          ; Round it up
              	
344E: AF      	MINCDE: XOR     A               ; Clear A and carry
344F: 90      	        SUB     B               ; Negate exponent
3450: 47      	        LD      B,A             ; Re-save exponent
3451: 7E      	        LD      A,(HL)          ; Get LSB of FPREG
3452: 9B      	        SBC     A, E            ; Subtract LSB of BCDE
3453: 5F      	        LD      E,A             ; Save LSB of BCDE
3454: 23      	        INC     HL
3455: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
3456: 9A      	        SBC     A,D             ; Subtract NMSB of BCDE
3457: 57      	        LD      D,A             ; Save NMSB of BCDE
3458: 23      	        INC     HL
3459: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
345A: 99      	        SBC     A,C             ; Subtract MSB of BCDE
345B: 4F      	        LD      C,A             ; Save MSB of BCDE
345C: DCBF34  	CONPOS: CALL    C,COMPL         ; Overflow - Make it positive
              	
345F: 68      	BNORM:  LD      L,B             ; L = Exponent
3460: 63      	        LD      H,E             ; H = LSB
3461: AF      	        XOR     A
3462: 47      	BNRMLP: LD      B,A             ; Save bit count
3463: 79      	        LD      A,C             ; Get MSB
3464: B7      	        OR      A               ; Is it zero?
3465: C28134  	        JP      NZ,PNORM        ; No - Do it bit at a time
3468: 4A      	        LD      C,D             ; MSB = NMSB
3469: 54      	        LD      D,H             ; NMSB= LSB
346A: 65      	        LD      H,L             ; LSB = VLSB
346B: 6F      	        LD      L,A             ; VLSB= 0
346C: 78      	        LD      A,B             ; Get exponent
346D: D608    	        SUB     8               ; Count 8 bits
346F: FEE0    	        CP      -24-8           ; Was number zero?
3471: C26234  	        JP      NZ,BNRMLP       ; No - Keep normalising
3474: AF      	RESZER: XOR     A               ; Result is zero
3475: 327741  	SAVEXP: LD      (FPEXP),A       ; Save result as zero
3478: C9      	        RET
              	
3479: 05      	NORMAL: DEC     B               ; Count bits
347A: 29      	        ADD     HL,HL           ; Shift HL left
347B: 7A      	        LD      A,D             ; Get NMSB
347C: 17      	        RLA                     ; Shift left with last bit
347D: 57      	        LD      D,A             ; Save NMSB
347E: 79      	        LD      A,C             ; Get MSB
347F: 8F      	        ADC     A,A             ; Shift left with last bit
3480: 4F      	        LD      C,A             ; Save MSB
3481: F27934  	PNORM:  JP      P,NORMAL        ; Not done - Keep going
3484: 78      	        LD      A,B             ; Number of bits shifted
3485: 5C      	        LD      E,H             ; Save HL in EB
3486: 45      	        LD      B,L
3487: B7      	        OR      A               ; Any shifting done?
3488: CA9434  	        JP      Z,RONDUP        ; No - Round it up
348B: 217741  	        LD      HL,FPEXP        ; Point to exponent
348E: 86      	        ADD     A,(HL)          ; Add shifted bits
348F: 77      	        LD      (HL),A          ; Re-save exponent
3490: D27434  	        JP      NC,RESZER       ; Underflow - Result is zero
3493: C8      	        RET     Z               ; Result is zero
3494: 78      	RONDUP: LD      A,B             ; Get VLSB of number
3495: 217741  	RONDB:  LD      HL,FPEXP        ; Point to exponent
3498: B7      	        OR      A               ; Any rounding?
3499: FCA634  	        CALL    M,FPROND        ; Yes - Round number up
349C: 46      	        LD      B,(HL)          ; B = Exponent
349D: 23      	        INC     HL
349E: 7E      	        LD      A,(HL)          ; Get sign of result
349F: E680    	        AND     10000000B       ; Only bit 7 needed
34A1: A9      	        XOR     C               ; Set correct sign
34A2: 4F      	        LD      C,A             ; Save correct sign in number
34A3: C39536  	        JP      FPBCDE          ; Move BCDE to FPREG
              	
34A6: 1C      	FPROND: INC     E               ; Round LSB
34A7: C0      	        RET     NZ              ; Return if ok
34A8: 14      	        INC     D               ; Round NMSB
34A9: C0      	        RET     NZ              ; Return if ok
34AA: 0C      	        INC     C               ; Round MSB
34AB: C0      	        RET     NZ              ; Return if ok
34AC: 0E80    	        LD      C,80H           ; Set normal value
34AE: 34      	        INC     (HL)            ; Increment exponent
34AF: C0      	        RET     NZ              ; Return if ok
34B0: C3BC23  	        JP      OVERR           ; Overflow error
              	
34B3: 7E      	PLUCDE: LD      A,(HL)          ; Get LSB of FPREG
34B4: 83      	        ADD     A,E             ; Add LSB of BCDE
34B5: 5F      	        LD      E,A             ; Save LSB of BCDE
34B6: 23      	        INC     HL
34B7: 7E      	        LD      A,(HL)          ; Get NMSB of FPREG
34B8: 8A      	        ADC     A,D             ; Add NMSB of BCDE
34B9: 57      	        LD      D,A             ; Save NMSB of BCDE
34BA: 23      	        INC     HL
34BB: 7E      	        LD      A,(HL)          ; Get MSB of FPREG
34BC: 89      	        ADC     A,C             ; Add MSB of BCDE
34BD: 4F      	        LD      C,A             ; Save MSB of BCDE
34BE: C9      	        RET
              	
34BF: 217841  	COMPL:  LD      HL,SGNRES       ; Sign of result
34C2: 7E      	        LD      A,(HL)          ; Get sign of result
34C3: 2F      	        CPL                     ; Negate it
34C4: 77      	        LD      (HL),A          ; Put it back
34C5: AF      	        XOR     A
34C6: 6F      	        LD      L,A             ; Set L to zero
34C7: 90      	        SUB     B               ; Negate exponent,set carry
34C8: 47      	        LD      B,A             ; Re-save exponent
34C9: 7D      	        LD      A,L             ; Load zero
34CA: 9B      	        SBC     A,E             ; Negate LSB
34CB: 5F      	        LD      E,A             ; Re-save LSB
34CC: 7D      	        LD      A,L             ; Load zero
34CD: 9A      	        SBC     A,D             ; Negate NMSB
34CE: 57      	        LD      D,A             ; Re-save NMSB
34CF: 7D      	        LD      A,L             ; Load zero
34D0: 99      	        SBC     A,C             ; Negate MSB
34D1: 4F      	        LD      C,A             ; Re-save MSB
34D2: C9      	        RET
              	
34D3: 0600    	SCALE:  LD      B,0             ; Clear underflow
34D5: D608    	SCALLP: SUB     8               ; 8 bits (a whole byte)?
34D7: DAE234  	        JP      C,SHRITE        ; No - Shift right A bits
34DA: 43      	        LD      B,E             ; <- Shift
34DB: 5A      	        LD      E,D             ; <- right
34DC: 51      	        LD      D,C             ; <- eight
34DD: 0E00    	        LD      C,0             ; <- bits
34DF: C3D534  	        JP      SCALLP          ; More bits to shift
              	
34E2: C609    	SHRITE: ADD     A,8+1           ; Adjust count
34E4: 6F      	        LD      L,A             ; Save bits to shift
34E5: AF      	SHRLP:  XOR     A               ; Flag for all done
34E6: 2D      	        DEC     L               ; All shifting done?
34E7: C8      	        RET     Z               ; Yes - Return
34E8: 79      	        LD      A,C             ; Get MSB
34E9: 1F      	SHRT1:  RRA                     ; Shift it right
34EA: 4F      	        LD      C,A             ; Re-save
34EB: 7A      	        LD      A,D             ; Get NMSB
34EC: 1F      	        RRA                     ; Shift right with last bit
34ED: 57      	        LD      D,A             ; Re-save it
34EE: 7B      	        LD      A,E             ; Get LSB
34EF: 1F      	        RRA                     ; Shift right with last bit
34F0: 5F      	        LD      E,A             ; Re-save it
34F1: 78      	        LD      A,B             ; Get underflow
34F2: 1F      	        RRA                     ; Shift right with last bit
34F3: 47      	        LD      B,A             ; Re-save underflow
34F4: C3E534  	        JP      SHRLP           ; More bits to do
              	
34F7: 00000081	UNITY:  .BYTE       000H,000H,000H,081H    ; 1.00000
              	
34FB: 03      	LOGTAB: .BYTE      3                       ; Table used by LOG
34FC: AA561980	        .BYTE      0AAH,056H,019H,080H     ; 0.59898
3500: F1227680	        .BYTE      0F1H,022H,076H,080H     ; 0.96147
3504: 45AA3882	        .BYTE      045H,0AAH,038H,082H     ; 2.88539
              	
3508: CD5436  	LOG:    CALL    TSTSGN          ; Test sign of value
350B: B7      	        OR      A
350C: EACC28  	        JP      PE,FCERR        ; ?FC Error if <= zero
350F: 217741  	        LD      HL,FPEXP        ; Point to exponent
3512: 7E      	        LD      A,(HL)          ; Get exponent
3513: 013580  	        LD      BC,8035H        ; BCDE = SQR(1/2)
3516: 11F304  	        LD      DE,04F3H
3519: 90      	        SUB     B               ; Scale value to be < 1
351A: F5      	        PUSH    AF              ; Save scale factor
351B: 70      	        LD      (HL),B          ; Save new exponent
351C: D5      	        PUSH    DE              ; Save SQR(1/2)
351D: C5      	        PUSH    BC
351E: CD0E34  	        CALL    FPADD           ; Add SQR(1/2) to value
3521: C1      	        POP     BC              ; Restore SQR(1/2)
3522: D1      	        POP     DE
3523: 04      	        INC     B               ; Make it SQR(2)
3524: CDAA35  	        CALL    DVBCDE          ; Divide by SQR(2)
3527: 21F734  	        LD      HL,UNITY        ; Point to 1.
352A: CD0534  	        CALL    SUBPHL          ; Subtract FPREG from 1
352D: 21FB34  	        LD      HL,LOGTAB       ; Coefficient table
3530: CD9C39  	        CALL    SUMSER          ; Evaluate sum of series
3533: 018080  	        LD      BC,8080H        ; BCDE = -0.5
3536: 110000  	        LD      DE,0000H
3539: CD0E34  	        CALL    FPADD           ; Subtract 0.5 from FPREG
353C: F1      	        POP     AF              ; Restore scale factor
353D: CDCF37  	        CALL    RSCALE          ; Re-scale number
3540: 013180  	MULLN2: LD      BC,8031H        ; BCDE = Ln(2)
3543: 111872  	        LD      DE,7218H
3546: 21      	        .BYTE      21H             ; Skip "POP BC" and "POP DE"
              	
3547: C1      	MULT:   POP     BC              ; Get number from stack
3548: D1      	        POP     DE
3549: CD5436  	FPMULT: CALL    TSTSGN          ; Test sign of FPREG
354C: C8      	        RET     Z               ; Return zero if zero
354D: 2E00    	        LD      L,0             ; Flag add exponents
354F: CD1236  	        CALL    ADDEXP          ; Add exponents
3552: 79      	        LD      A,C             ; Get MSB of multiplier
3553: 328641  	        LD      (MULVAL),A      ; Save MSB of multiplier
3556: EB      	        EX      DE,HL
3557: 228741  	        LD      (MULVAL+1),HL   ; Save rest of multiplier
355A: 010000  	        LD      BC,0            ; Partial product (BCDE) = zero
355D: 50      	        LD      D,B
355E: 58      	        LD      E,B
355F: 215F34  	        LD      HL,BNORM        ; Address of normalise
3562: E5      	        PUSH    HL              ; Save for return
3563: 216B35  	        LD      HL,MULT8        ; Address of 8 bit multiply
3566: E5      	        PUSH    HL              ; Save for NMSB,MSB
3567: E5      	        PUSH    HL              ; 
3568: 217441  	        LD      HL,FPREG        ; Point to number
356B: 7E      	MULT8:  LD      A,(HL)          ; Get LSB of number
356C: 23      	        INC     HL              ; Point to NMSB
356D: B7      	        OR      A               ; Test LSB
356E: CA9735  	        JP      Z,BYTSFT        ; Zero - shift to next byte
3571: E5      	        PUSH    HL              ; Save address of number
3572: 2E08    	        LD      L,8             ; 8 bits to multiply by
3574: 1F      	MUL8LP: RRA                     ; Shift LSB right
3575: 67      	        LD      H,A             ; Save LSB
3576: 79      	        LD      A,C             ; Get MSB
3577: D28535  	        JP      NC,NOMADD       ; Bit was zero - Don't add
357A: E5      	        PUSH    HL              ; Save LSB and count
357B: 2A8741  	        LD      HL,(MULVAL+1)   ; Get LSB and NMSB
357E: 19      	        ADD     HL,DE           ; Add NMSB and LSB
357F: EB      	        EX      DE,HL           ; Leave sum in DE
3580: E1      	        POP     HL              ; Restore MSB and count
3581: 3A8641  	        LD      A,(MULVAL)      ; Get MSB of multiplier
3584: 89      	        ADC     A,C             ; Add MSB
3585: 1F      	NOMADD: RRA                     ; Shift MSB right
3586: 4F      	        LD      C,A             ; Re-save MSB
3587: 7A      	        LD      A,D             ; Get NMSB
3588: 1F      	        RRA                     ; Shift NMSB right
3589: 57      	        LD      D,A             ; Re-save NMSB
358A: 7B      	        LD      A,E             ; Get LSB
358B: 1F      	        RRA                     ; Shift LSB right
358C: 5F      	        LD      E,A             ; Re-save LSB
358D: 78      	        LD      A,B             ; Get VLSB
358E: 1F      	        RRA                     ; Shift VLSB right
358F: 47      	        LD      B,A             ; Re-save VLSB
3590: 2D      	        DEC     L               ; Count bits multiplied
3591: 7C      	        LD      A,H             ; Get LSB of multiplier
3592: C27435  	        JP      NZ,MUL8LP       ; More - Do it
3595: E1      	POPHRT: POP     HL              ; Restore address of number
3596: C9      	        RET
              	
3597: 43      	BYTSFT: LD      B,E             ; Shift partial product left
3598: 5A      	        LD      E,D
3599: 51      	        LD      D,C
359A: 4F      	        LD      C,A
359B: C9      	        RET
              	
359C: CD8536  	DIV10:  CALL    STAKFP          ; Save FPREG on stack
359F: 012084  	        LD      BC,8420H        ; BCDE = 10.
35A2: 110000  	        LD      DE,0000H
35A5: CD9536  	        CALL    FPBCDE          ; Move 10 to FPREG
              	
35A8: C1      	DIV:    POP     BC              ; Get number from stack
35A9: D1      	        POP     DE
35AA: CD5436  	DVBCDE: CALL    TSTSGN          ; Test sign of FPREG
35AD: CAB023  	        JP      Z,DZERR         ; Error if division by zero
35B0: 2EFF    	        LD      L,-1            ; Flag subtract exponents
35B2: CD1236  	        CALL    ADDEXP          ; Subtract exponents
35B5: 34      	        INC     (HL)            ; Add 2 to exponent to adjust
35B6: 34      	        INC     (HL)
35B7: 2B      	        DEC     HL              ; Point to MSB
35B8: 7E      	        LD      A,(HL)          ; Get MSB of dividend
35B9: 32A240  	        LD      (DIV3),A        ; Save for subtraction
35BC: 2B      	        DEC     HL
35BD: 7E      	        LD      A,(HL)          ; Get NMSB of dividend
35BE: 329E40  	        LD      (DIV2),A        ; Save for subtraction
35C1: 2B      	        DEC     HL
35C2: 7E      	        LD      A,(HL)          ; Get MSB of dividend
35C3: 329A40  	        LD      (DIV1),A        ; Save for subtraction
35C6: 41      	        LD      B,C             ; Get MSB
35C7: EB      	        EX      DE,HL           ; NMSB,LSB to HL
35C8: AF      	        XOR     A
35C9: 4F      	        LD      C,A             ; Clear MSB of quotient
35CA: 57      	        LD      D,A             ; Clear NMSB of quotient
35CB: 5F      	        LD      E,A             ; Clear LSB of quotient
35CC: 32A540  	        LD      (DIV4),A        ; Clear overflow count
35CF: E5      	DIVLP:  PUSH    HL              ; Save divisor
35D0: C5      	        PUSH    BC
35D1: 7D      	        LD      A,L             ; Get LSB of number
35D2: CD9940  	        CALL    DIVSUP          ; Subt' divisor from dividend
35D5: DE00    	        SBC     A,0             ; Count for overflows
35D7: 3F      	        CCF
35D8: D2E235  	        JP      NC,RESDIV       ; Restore divisor if borrow
35DB: 32A540  	        LD      (DIV4),A        ; Re-save overflow count
35DE: F1      	        POP     AF              ; Scrap divisor
35DF: F1      	        POP     AF
35E0: 37      	        SCF                     ; Set carry to
35E1: D2      	        .BYTE      0D2H            ; Skip "POP BC" and "POP HL"
              	
35E2: C1      	RESDIV: POP     BC              ; Restore divisor
35E3: E1      	        POP     HL
35E4: 79      	        LD      A,C             ; Get MSB of quotient
35E5: 3C      	        INC     A
35E6: 3D      	        DEC     A
35E7: 1F      	        RRA                     ; Bit 0 to bit 7
35E8: FA9534  	        JP      M,RONDB         ; Done - Normalise result
35EB: 17      	        RLA                     ; Restore carry
35EC: 7B      	        LD      A,E             ; Get LSB of quotient
35ED: 17      	        RLA                     ; Double it
35EE: 5F      	        LD      E,A             ; Put it back
35EF: 7A      	        LD      A,D             ; Get NMSB of quotient
35F0: 17      	        RLA                     ; Double it
35F1: 57      	        LD      D,A             ; Put it back
35F2: 79      	        LD      A,C             ; Get MSB of quotient
35F3: 17      	        RLA                     ; Double it
35F4: 4F      	        LD      C,A             ; Put it back
35F5: 29      	        ADD     HL,HL           ; Double NMSB,LSB of divisor
35F6: 78      	        LD      A,B             ; Get MSB of divisor
35F7: 17      	        RLA                     ; Double it
35F8: 47      	        LD      B,A             ; Put it back
35F9: 3AA540  	        LD      A,(DIV4)        ; Get VLSB of quotient
35FC: 17      	        RLA                     ; Double it
35FD: 32A540  	        LD      (DIV4),A        ; Put it back
3600: 79      	        LD      A,C             ; Get MSB of quotient
3601: B2      	        OR      D               ; Merge NMSB
3602: B3      	        OR      E               ; Merge LSB
3603: C2CF35  	        JP      NZ,DIVLP        ; Not done - Keep dividing
3606: E5      	        PUSH    HL              ; Save divisor
3607: 217741  	        LD      HL,FPEXP        ; Point to exponent
360A: 35      	        DEC     (HL)            ; Divide by 2
360B: E1      	        POP     HL              ; Restore divisor
360C: C2CF35  	        JP      NZ,DIVLP        ; Ok - Keep going
360F: C3BC23  	        JP      OVERR           ; Overflow error
              	
3612: 78      	ADDEXP: LD      A,B             ; Get exponent of dividend
3613: B7      	        OR      A               ; Test it
3614: CA3636  	        JP      Z,OVTST3        ; Zero - Result zero
3617: 7D      	        LD      A,L             ; Get add/subtract flag
3618: 217741  	        LD      HL,FPEXP        ; Point to exponent
361B: AE      	        XOR     (HL)            ; Add or subtract it
361C: 80      	        ADD     A,B             ; Add the other exponent
361D: 47      	        LD      B,A             ; Save new exponent
361E: 1F      	        RRA                     ; Test exponent for overflow
361F: A8      	        XOR     B
3620: 78      	        LD      A,B             ; Get exponent
3621: F23536  	        JP      P,OVTST2        ; Positive - Test for overflow
3624: C680    	        ADD     A,80H           ; Add excess 128
3626: 77      	        LD      (HL),A          ; Save new exponent
3627: CA9535  	        JP      Z,POPHRT        ; Zero - Result zero
362A: CDBA36  	        CALL    SIGNS           ; Set MSBs and sign of result
362D: 77      	        LD      (HL),A          ; Save new exponent
362E: 2B      	        DEC     HL              ; Point to MSB
362F: C9      	        RET
              	
3630: CD5436  	OVTST1: CALL    TSTSGN          ; Test sign of FPREG
3633: 2F      	        CPL                     ; Invert sign
3634: E1      	        POP     HL              ; Clean up stack
3635: B7      	OVTST2: OR      A               ; Test if new exponent zero
3636: E1      	OVTST3: POP     HL              ; Clear off return address
3637: F27434  	        JP      P,RESZER        ; Result zero
363A: C3BC23  	        JP      OVERR           ; Overflow error
              	
363D: CDA036  	MLSP10: CALL    BCDEFP          ; Move FPREG to BCDE
3640: 78      	        LD      A,B             ; Get exponent
3641: B7      	        OR      A               ; Is it zero?
3642: C8      	        RET     Z               ; Yes - Result is zero
3643: C602    	        ADD     A,2             ; Multiply by 4
3645: DABC23  	        JP      C,OVERR         ; Overflow - ?OV Error
3648: 47      	        LD      B,A             ; Re-save exponent
3649: CD0E34  	        CALL    FPADD           ; Add BCDE to FPREG (Times 5)
364C: 217741  	        LD      HL,FPEXP        ; Point to exponent
364F: 34      	        INC     (HL)            ; Double number (Times 10)
3650: C0      	        RET     NZ              ; Ok - Return
3651: C3BC23  	        JP      OVERR           ; Overflow error
              	
3654: 3A7741  	TSTSGN: LD      A,(FPEXP)       ; Get sign of FPREG
3657: B7      	        OR      A
3658: C8      	        RET     Z               ; RETurn if number is zero
3659: 3A7641  	        LD      A,(FPREG+2)     ; Get MSB of FPREG
365C: FE      	        .BYTE      0FEH            ; Test sign
365D: 2F      	RETREL: CPL                     ; Invert sign
365E: 17      	        RLA                     ; Sign bit to carry
365F: 9F      	FLGDIF: SBC     A,A             ; Carry to all bits of A
3660: C0      	        RET     NZ              ; Return -1 if negative
3661: 3C      	        INC     A               ; Bump to +1
3662: C9      	        RET                     ; Positive - Return +1
              	
3663: CD5436  	SGN:    CALL    TSTSGN          ; Test sign of FPREG
3666: 0688    	FLGREL: LD      B,80H+8         ; 8 bit integer in exponent
3668: 110000  	        LD      DE,0            ; Zero NMSB and LSB
366B: 217741  	RETINT: LD      HL,FPEXP        ; Point to exponent
366E: 4F      	        LD      C,A             ; CDE = MSB,NMSB and LSB
366F: 70      	        LD      (HL),B          ; Save exponent
3670: 0600    	        LD      B,0             ; CDE = integer to normalise
3672: 23      	        INC     HL              ; Point to sign of result
3673: 3680    	        LD      (HL),80H        ; Set sign of result
3675: 17      	        RLA                     ; Carry = sign of integer
3676: C35C34  	        JP      CONPOS          ; Set sign of result
              	
3679: CD5436  	ABS:    CALL    TSTSGN          ; Test sign of FPREG
367C: F0      	        RET     P               ; Return if positive
367D: 217641  	INVSGN: LD      HL,FPREG+2      ; Point to MSB
3680: 7E      	        LD      A,(HL)          ; Get sign of mantissa
3681: EE80    	        XOR     80H             ; Invert sign of mantissa
3683: 77      	        LD      (HL),A          ; Re-save sign of mantissa
3684: C9      	        RET
              	
3685: EB      	STAKFP: EX      DE,HL           ; Save code string address
3686: 2A7441  	        LD      HL,(FPREG)      ; LSB,NLSB of FPREG
3689: E3      	        EX      (SP),HL         ; Stack them,get return
368A: E5      	        PUSH    HL              ; Re-save return
368B: 2A7641  	        LD      HL,(FPREG+2)    ; MSB and exponent of FPREG
368E: E3      	        EX      (SP),HL         ; Stack them,get return
368F: E5      	        PUSH    HL              ; Re-save return
3690: EB      	        EX      DE,HL           ; Restore code string address
3691: C9      	        RET
              	
3692: CDA336  	PHLTFP: CALL    LOADFP          ; Number at HL to BCDE
3695: EB      	FPBCDE: EX      DE,HL           ; Save code string address
3696: 227441  	        LD      (FPREG),HL      ; Save LSB,NLSB of number
3699: 60      	        LD      H,B             ; Exponent of number
369A: 69      	        LD      L,C             ; MSB of number
369B: 227641  	        LD      (FPREG+2),HL    ; Save MSB and exponent
369E: EB      	        EX      DE,HL           ; Restore code string address
369F: C9      	        RET
              	
36A0: 217441  	BCDEFP: LD      HL,FPREG        ; Point to FPREG
36A3: 5E      	LOADFP: LD      E,(HL)          ; Get LSB of number
36A4: 23      	        INC     HL
36A5: 56      	        LD      D,(HL)          ; Get NMSB of number
36A6: 23      	        INC     HL
36A7: 4E      	        LD      C,(HL)          ; Get MSB of number
36A8: 23      	        INC     HL
36A9: 46      	        LD      B,(HL)          ; Get exponent of number
36AA: 23      	INCHL:  INC     HL              ; Used for conditional "INC HL"
36AB: C9      	        RET
              	
36AC: 117441  	FPTHL:  LD      DE,FPREG        ; Point to FPREG
36AF: 0604    	DETHL4: LD      B,4             ; 4 bytes to move
36B1: 1A      	DETHLB: LD      A,(DE)          ; Get source
36B2: 77      	        LD      (HL),A          ; Save destination
36B3: 13      	        INC     DE              ; Next source
36B4: 23      	        INC     HL              ; Next destination
36B5: 05      	        DEC     B               ; Count bytes
36B6: C2B136  	        JP      NZ,DETHLB       ; Loop if more
36B9: C9      	        RET
              	
36BA: 217641  	SIGNS:  LD      HL,FPREG+2      ; Point to MSB of FPREG
36BD: 7E      	        LD      A,(HL)          ; Get MSB
36BE: 07      	        RLCA                    ; Old sign to carry
36BF: 37      	        SCF                     ; Set MSBit
36C0: 1F      	        RRA                     ; Set MSBit of MSB
36C1: 77      	        LD      (HL),A          ; Save new MSB
36C2: 3F      	        CCF                     ; Complement sign
36C3: 1F      	        RRA                     ; Old sign to carry
36C4: 23      	        INC     HL
36C5: 23      	        INC     HL
36C6: 77      	        LD      (HL),A          ; Set sign of result
36C7: 79      	        LD      A,C             ; Get MSB
36C8: 07      	        RLCA                    ; Old sign to carry
36C9: 37      	        SCF                     ; Set MSBit
36CA: 1F      	        RRA                     ; Set MSBit of MSB
36CB: 4F      	        LD      C,A             ; Save MSB
36CC: 1F      	        RRA
36CD: AE      	        XOR     (HL)            ; New sign of result
36CE: C9      	        RET
              	
36CF: 78      	CMPNUM: LD      A,B             ; Get exponent of number
36D0: B7      	        OR      A
36D1: CA5436  	        JP      Z,TSTSGN        ; Zero - Test sign of FPREG
36D4: 215D36  	        LD      HL,RETREL       ; Return relation routine
36D7: E5      	        PUSH    HL              ; Save for return
36D8: CD5436  	        CALL    TSTSGN          ; Test sign of FPREG
36DB: 79      	        LD      A,C             ; Get MSB of number
36DC: C8      	        RET     Z               ; FPREG zero - Number's MSB
36DD: 217641  	        LD      HL,FPREG+2      ; MSB of FPREG
36E0: AE      	        XOR     (HL)            ; Combine signs
36E1: 79      	        LD      A,C             ; Get MSB of number
36E2: F8      	        RET     M               ; Exit if signs different
36E3: CDE936  	        CALL    CMPFP           ; Compare FP numbers
36E6: 1F      	        RRA                     ; Get carry to sign
36E7: A9      	        XOR     C               ; Combine with MSB of number
36E8: C9      	        RET
              	
36E9: 23      	CMPFP:  INC     HL              ; Point to exponent
36EA: 78      	        LD      A,B             ; Get exponent
36EB: BE      	        CP      (HL)            ; Compare exponents
36EC: C0      	        RET     NZ              ; Different
36ED: 2B      	        DEC     HL              ; Point to MBS
36EE: 79      	        LD      A,C             ; Get MSB
36EF: BE      	        CP      (HL)            ; Compare MSBs
36F0: C0      	        RET     NZ              ; Different
36F1: 2B      	        DEC     HL              ; Point to NMSB
36F2: 7A      	        LD      A,D             ; Get NMSB
36F3: BE      	        CP      (HL)            ; Compare NMSBs
36F4: C0      	        RET     NZ              ; Different
36F5: 2B      	        DEC     HL              ; Point to LSB
36F6: 7B      	        LD      A,E             ; Get LSB
36F7: 96      	        SUB     (HL)            ; Compare LSBs
36F8: C0      	        RET     NZ              ; Different
36F9: E1      	        POP     HL              ; Drop RETurn
36FA: E1      	        POP     HL              ; Drop another RETurn
36FB: C9      	        RET
              	
36FC: 47      	FPINT:  LD      B,A             ; <- Move
36FD: 4F      	        LD      C,A             ; <- exponent
36FE: 57      	        LD      D,A             ; <- to all
36FF: 5F      	        LD      E,A             ; <- bits
3700: B7      	        OR      A               ; Test exponent
3701: C8      	        RET     Z               ; Zero - Return zero
3702: E5      	        PUSH    HL              ; Save pointer to number
3703: CDA036  	        CALL    BCDEFP          ; Move FPREG to BCDE
3706: CDBA36  	        CALL    SIGNS           ; Set MSBs & sign of result
3709: AE      	        XOR     (HL)            ; Combine with sign of FPREG
370A: 67      	        LD      H,A             ; Save combined signs
370B: FC2037  	        CALL    M,DCBCDE        ; Negative - Decrement BCDE
370E: 3E98    	        LD      A,80H+24        ; 24 bits
3710: 90      	        SUB     B               ; Bits to shift
3711: CDD334  	        CALL    SCALE           ; Shift BCDE
3714: 7C      	        LD      A,H             ; Get combined sign
3715: 17      	        RLA                     ; Sign to carry
3716: DCA634  	        CALL    C,FPROND        ; Negative - Round number up
3719: 0600    	        LD      B,0             ; Zero exponent
371B: DCBF34  	        CALL    C,COMPL         ; If negative make positive
371E: E1      	        POP     HL              ; Restore pointer to number
371F: C9      	        RET
              	
3720: 1B      	DCBCDE: DEC     DE              ; Decrement BCDE
3721: 7A      	        LD      A,D             ; Test LSBs
3722: A3      	        AND     E
3723: 3C      	        INC     A
3724: C0      	        RET     NZ              ; Exit if LSBs not FFFF
3725: 0B      	        DEC     BC              ; Decrement MSBs
3726: C9      	        RET
              	
3727: 217741  	INT:    LD      HL,FPEXP        ; Point to exponent
372A: 7E      	        LD      A,(HL)          ; Get exponent
372B: FE98    	        CP      80H+24          ; Integer accuracy only?
372D: 3A7441  	        LD      A,(FPREG)       ; Get LSB
3730: D0      	        RET     NC              ; Yes - Already integer
3731: 7E      	        LD      A,(HL)          ; Get exponent
3732: CDFC36  	        CALL    FPINT           ; F.P to integer
3735: 3698    	        LD      (HL),80H+24     ; Save 24 bit integer
3737: 7B      	        LD      A,E             ; Get LSB of number
3738: F5      	        PUSH    AF              ; Save LSB
3739: 79      	        LD      A,C             ; Get MSB of number
373A: 17      	        RLA                     ; Sign to carry
373B: CD5C34  	        CALL    CONPOS          ; Set sign of result
373E: F1      	        POP     AF              ; Restore LSB of number
373F: C9      	        RET
              	
3740: 210000  	MLDEBC: LD      HL,0            ; Clear partial product
3743: 78      	        LD      A,B             ; Test multiplier
3744: B1      	        OR      C
3745: C8      	        RET     Z               ; Return zero if zero
3746: 3E10    	        LD      A,16            ; 16 bits
3748: 29      	MLDBLP: ADD     HL,HL           ; Shift P.P left
3749: DA802F  	        JP      C,BSERR         ; ?BS Error if overflow
374C: EB      	        EX      DE,HL
374D: 29      	        ADD     HL,HL           ; Shift multiplier left
374E: EB      	        EX      DE,HL
374F: D25637  	        JP      NC,NOMLAD       ; Bit was zero - No add
3752: 09      	        ADD     HL,BC           ; Add multiplicand
3753: DA802F  	        JP      C,BSERR         ; ?BS Error if overflow
3756: 3D      	NOMLAD: DEC     A               ; Count bits
3757: C24837  	        JP      NZ,MLDBLP       ; More
375A: C9      	        RET
              	
375B: FE2D    	ASCTFP: CP      '-'             ; Negative?
375D: F5      	        PUSH    AF              ; Save it and flags
375E: CA6737  	        JP      Z,CNVNUM        ; Yes - Convert number
3761: FE2B    	        CP      '+'             ; Positive?
3763: CA6737  	        JP      Z,CNVNUM        ; Yes - Convert number
3766: 2B      	        DEC     HL              ; DEC 'cos GETCHR INCs
3767: CD7434  	CNVNUM: CALL    RESZER          ; Set result to zero
376A: 47      	        LD      B,A             ; Digits after point counter
376B: 57      	        LD      D,A             ; Sign of exponent
376C: 5F      	        LD      E,A             ; Exponent of ten
376D: 2F      	        CPL
376E: 4F      	        LD      C,A             ; Before or after point flag
376F: CD0528  	MANLP:  CALL    GETCHR          ; Get next character
3772: DAB837  	        JP      C,ADDIG         ; Digit - Add to number
3775: FE2E    	        CP      '.'
3777: CA9337  	        JP      Z,DPOINT        ; '.' - Flag point
377A: FE45    	        CP      'E'
377C: C29737  	        JP      NZ,CONEXP       ; Not 'E' - Scale number
377F: CD0528  	        CALL    GETCHR          ; Get next character
3782: CDAB2D  	        CALL    SGNEXP          ; Get sign of exponent
3785: CD0528  	EXPLP:  CALL    GETCHR          ; Get next character
3788: DADA37  	        JP      C,EDIGIT        ; Digit - Add to exponent
378B: 14      	        INC     D               ; Is sign negative?
378C: C29737  	        JP      NZ,CONEXP       ; No - Scale number
378F: AF      	        XOR     A
3790: 93      	        SUB     E               ; Negate exponent
3791: 5F      	        LD      E,A             ; And re-save it
3792: 0C      	        INC     C               ; Flag end of number
3793: 0C      	DPOINT: INC     C               ; Flag point passed
3794: CA6F37  	        JP      Z,MANLP         ; Zero - Get another digit
3797: E5      	CONEXP: PUSH    HL              ; Save code string address
3798: 7B      	        LD      A,E             ; Get exponent
3799: 90      	        SUB     B               ; Subtract digits after point
379A: F4B037  	SCALMI: CALL    P,SCALPL        ; Positive - Multiply number
379D: F2A637  	        JP      P,ENDCON        ; Positive - All done
37A0: F5      	        PUSH    AF              ; Save number of times to /10
37A1: CD9C35  	        CALL    DIV10           ; Divide by 10
37A4: F1      	        POP     AF              ; Restore count
37A5: 3C      	        INC     A               ; Count divides
              	
37A6: C29A37  	ENDCON: JP      NZ,SCALMI       ; More to do
37A9: D1      	        POP     DE              ; Restore code string address
37AA: F1      	        POP     AF              ; Restore sign of number
37AB: CC7D36  	        CALL    Z,INVSGN        ; Negative - Negate number
37AE: EB      	        EX      DE,HL           ; Code string address to HL
37AF: C9      	        RET
              	
37B0: C8      	SCALPL: RET     Z               ; Exit if no scaling needed
37B1: F5      	MULTEN: PUSH    AF              ; Save count
37B2: CD3D36  	        CALL    MLSP10          ; Multiply number by 10
37B5: F1      	        POP     AF              ; Restore count
37B6: 3D      	        DEC     A               ; Count multiplies
37B7: C9      	        RET
              	
37B8: D5      	ADDIG:  PUSH    DE              ; Save sign of exponent
37B9: 57      	        LD      D,A             ; Save digit
37BA: 78      	        LD      A,B             ; Get digits after point
37BB: 89      	        ADC     A,C             ; Add one if after point
37BC: 47      	        LD      B,A             ; Re-save counter
37BD: C5      	        PUSH    BC              ; Save point flags
37BE: E5      	        PUSH    HL              ; Save code string address
37BF: D5      	        PUSH    DE              ; Save digit
37C0: CD3D36  	        CALL    MLSP10          ; Multiply number by 10
37C3: F1      	        POP     AF              ; Restore digit
37C4: D630    	        SUB     '0'             ; Make it absolute
37C6: CDCF37  	        CALL    RSCALE          ; Re-scale number
37C9: E1      	        POP     HL              ; Restore code string address
37CA: C1      	        POP     BC              ; Restore point flags
37CB: D1      	        POP     DE              ; Restore sign of exponent
37CC: C36F37  	        JP      MANLP           ; Get another digit
              	
37CF: CD8536  	RSCALE: CALL    STAKFP          ; Put number on stack
37D2: CD6636  	        CALL    FLGREL          ; Digit to add to FPREG
37D5: C1      	PADD:   POP     BC              ; Restore number
37D6: D1      	        POP     DE
37D7: C30E34  	        JP      FPADD           ; Add BCDE to FPREG and return
              	
37DA: 7B      	EDIGIT: LD      A,E             ; Get digit
37DB: 07      	        RLCA                    ; Times 2
37DC: 07      	        RLCA                    ; Times 4
37DD: 83      	        ADD     A,E             ; Times 5
37DE: 07      	        RLCA                    ; Times 10
37DF: 86      	        ADD     A,(HL)          ; Add next digit
37E0: D630    	        SUB     '0'             ; Make it absolute
37E2: 5F      	        LD      E,A             ; Save new digit
37E3: C38537  	        JP      EXPLP           ; Look for another digit
              	
37E6: E5      	LINEIN: PUSH    HL              ; Save code string address
37E7: 214523  	        LD      HL,INMSG        ; Output " in "
37EA: CD4B31  	        CALL    PRS             ; Output string at HL
37ED: E1      	        POP     HL              ; Restore code string address
37EE: EB      	PRNTHL: EX      DE,HL           ; Code string address to DE
37EF: AF      	        XOR     A
37F0: 0698    	        LD      B,80H+24        ; 24 bits
37F2: CD6B36  	        CALL    RETINT          ; Return the integer
37F5: 214A31  	        LD      HL,PRNUMS       ; Print number string
37F8: E5      	        PUSH    HL              ; Save for return
37F9: 217941  	NUMASC: LD      HL,PBUFF        ; Convert number to ASCII
37FC: E5      	        PUSH    HL              ; Save for return
37FD: CD5436  	        CALL    TSTSGN          ; Test sign of FPREG
3800: 3620    	        LD      (HL),' '        ; Space at start
3802: F20738  	        JP      P,SPCFST        ; Positive - Space to start
3805: 362D    	        LD      (HL),'-'        ; '-' sign at start
3807: 23      	SPCFST: INC     HL              ; First byte of number
3808: 3630    	        LD      (HL),'0'        ; '0' if zero
380A: CABD38  	        JP      Z,JSTZER        ; Return '0' if zero
380D: E5      	        PUSH    HL              ; Save buffer address
380E: FC7D36  	        CALL    M,INVSGN        ; Negate FPREG if negative
3811: AF      	        XOR     A               ; Zero A
3812: F5      	        PUSH    AF              ; Save it
3813: CDC338  	        CALL    RNGTST          ; Test number is in range
3816: 014391  	SIXDIG: LD      BC,9143H        ; BCDE - 99999.9
3819: 11F84F  	        LD      DE,4FF8H
381C: CDCF36  	        CALL    CMPNUM          ; Compare numbers
381F: B7      	        OR      A
3820: E23438  	        JP      PO,INRNG        ; > 99999.9 - Sort it out
3823: F1      	        POP     AF              ; Restore count
3824: CDB137  	        CALL    MULTEN          ; Multiply by ten
3827: F5      	        PUSH    AF              ; Re-save count
3828: C31638  	        JP      SIXDIG          ; Test it again
              	
382B: CD9C35  	GTSIXD: CALL    DIV10           ; Divide by 10
382E: F1      	        POP     AF              ; Get count
382F: 3C      	        INC     A               ; Count divides
3830: F5      	        PUSH    AF              ; Re-save count
3831: CDC338  	        CALL    RNGTST          ; Test number is in range
3834: CDFC33  	INRNG:  CALL    ROUND           ; Add 0.5 to FPREG
3837: 3C      	        INC     A
3838: CDFC36  	        CALL    FPINT           ; F.P to integer
383B: CD9536  	        CALL    FPBCDE          ; Move BCDE to FPREG
383E: 010603  	        LD      BC,0306H        ; 1E+06 to 1E-03 range
3841: F1      	        POP     AF              ; Restore count
3842: 81      	        ADD     A,C             ; 6 digits before point
3843: 3C      	        INC     A               ; Add one
3844: FA5038  	        JP      M,MAKNUM        ; Do it in 'E' form if < 1E-02
3847: FE08    	        CP      6+1+1           ; More than 999999 ?
3849: D25038  	        JP      NC,MAKNUM       ; Yes - Do it in 'E' form
384C: 3C      	        INC     A               ; Adjust for exponent
384D: 47      	        LD      B,A             ; Exponent of number
384E: 3E02    	        LD      A,2             ; Make it zero after
              	
3850: 3D      	MAKNUM: DEC     A               ; Adjust for digits to do
3851: 3D      	        DEC     A
3852: E1      	        POP     HL              ; Restore buffer address
3853: F5      	        PUSH    AF              ; Save count
3854: 11D638  	        LD      DE,POWERS       ; Powers of ten
3857: 05      	        DEC     B               ; Count digits before point
3858: C26138  	        JP      NZ,DIGTXT       ; Not zero - Do number
385B: 362E    	        LD      (HL),'.'        ; Save point
385D: 23      	        INC     HL              ; Move on
385E: 3630    	        LD      (HL),'0'        ; Save zero
3860: 23      	        INC     HL              ; Move on
3861: 05      	DIGTXT: DEC     B               ; Count digits before point
3862: 362E    	        LD      (HL),'.'        ; Save point in case
3864: CCAA36  	        CALL    Z,INCHL         ; Last digit - move on
3867: C5      	        PUSH    BC              ; Save digits before point
3868: E5      	        PUSH    HL              ; Save buffer address
3869: D5      	        PUSH    DE              ; Save powers of ten
386A: CDA036  	        CALL    BCDEFP          ; Move FPREG to BCDE
386D: E1      	        POP     HL              ; Powers of ten table
386E: 062F    	        LD      B, '0'-1        ; ASCII '0' - 1
3870: 04      	TRYAGN: INC     B               ; Count subtractions
3871: 7B      	        LD      A,E             ; Get LSB
3872: 96      	        SUB     (HL)            ; Subtract LSB
3873: 5F      	        LD      E,A             ; Save LSB
3874: 23      	        INC     HL
3875: 7A      	        LD      A,D             ; Get NMSB
3876: 9E      	        SBC     A,(HL)          ; Subtract NMSB
3877: 57      	        LD      D,A             ; Save NMSB
3878: 23      	        INC     HL
3879: 79      	        LD      A,C             ; Get MSB
387A: 9E      	        SBC     A,(HL)          ; Subtract MSB
387B: 4F      	        LD      C,A             ; Save MSB
387C: 2B      	        DEC     HL              ; Point back to start
387D: 2B      	        DEC     HL
387E: D27038  	        JP      NC,TRYAGN       ; No overflow - Try again
3881: CDB334  	        CALL    PLUCDE          ; Restore number
3884: 23      	        INC     HL              ; Start of next number
3885: CD9536  	        CALL    FPBCDE          ; Move BCDE to FPREG
3888: EB      	        EX      DE,HL           ; Save point in table
3889: E1      	        POP     HL              ; Restore buffer address
388A: 70      	        LD      (HL),B          ; Save digit in buffer
388B: 23      	        INC     HL              ; And move on
388C: C1      	        POP     BC              ; Restore digit count
388D: 0D      	        DEC     C               ; Count digits
388E: C26138  	        JP      NZ,DIGTXT       ; More - Do them
3891: 05      	        DEC     B               ; Any decimal part?
3892: CAA138  	        JP      Z,DOEBIT        ; No - Do 'E' bit
3895: 2B      	SUPTLZ: DEC     HL              ; Move back through buffer
3896: 7E      	        LD      A,(HL)          ; Get character
3897: FE30    	        CP      '0'             ; '0' character?
3899: CA9538  	        JP      Z,SUPTLZ        ; Yes - Look back for more
389C: FE2E    	        CP      '.'             ; A decimal point?
389E: C4AA36  	        CALL    NZ,INCHL        ; Move back over digit
              	
38A1: F1      	DOEBIT: POP     AF              ; Get 'E' flag
38A2: CAC038  	        JP      Z,NOENED        ; No 'E' needed - End buffer
38A5: 3645    	        LD      (HL),'E'        ; Put 'E' in buffer
38A7: 23      	        INC     HL              ; And move on
38A8: 362B    	        LD      (HL),'+'        ; Put '+' in buffer
38AA: F2B138  	        JP      P,OUTEXP        ; Positive - Output exponent
38AD: 362D    	        LD      (HL),'-'        ; Put '-' in buffer
38AF: 2F      	        CPL                     ; Negate exponent
38B0: 3C      	        INC     A
38B1: 062F    	OUTEXP: LD      B,'0'-1         ; ASCII '0' - 1
38B3: 04      	EXPTEN: INC     B               ; Count subtractions
38B4: D60A    	        SUB     10              ; Tens digit
38B6: D2B338  	        JP      NC,EXPTEN       ; More to do
38B9: C63A    	        ADD     A,'0'+10        ; Restore and make ASCII
38BB: 23      	        INC     HL              ; Move on
38BC: 70      	        LD      (HL),B          ; Save MSB of exponent
38BD: 23      	JSTZER: INC     HL              ;
38BE: 77      	        LD      (HL),A          ; Save LSB of exponent
38BF: 23      	        INC     HL
38C0: 71      	NOENED: LD      (HL),C          ; Mark end of buffer
38C1: E1      	        POP     HL              ; Restore code string address
38C2: C9      	        RET
              	
38C3: 017494  	RNGTST: LD      BC,9474H        ; BCDE = 999999.
38C6: 11F723  	        LD      DE,23F7H
38C9: CDCF36  	        CALL    CMPNUM          ; Compare numbers
38CC: B7      	        OR      A
38CD: E1      	        POP     HL              ; Return address to HL
38CE: E22B38  	        JP      PO,GTSIXD       ; Too big - Divide by ten
38D1: E9      	        JP      (HL)            ; Otherwise return to caller
              	
38D2: 00000080	HALF:   .BYTE      00H,00H,00H,80H ; 0.5
              	
38D6: A08601  	POWERS: .BYTE      0A0H,086H,001H  ; 100000
38D9: 102700  	        .BYTE      010H,027H,000H  ;  10000
38DC: E80300  	        .BYTE      0E8H,003H,000H  ;   1000
38DF: 640000  	        .BYTE      064H,000H,000H  ;    100
38E2: 0A0000  	        .BYTE      00AH,000H,000H  ;     10
38E5: 010000  	        .BYTE      001H,000H,000H  ;      1
              	
38E8: 217D36  	NEGAFT: LD  HL,INVSGN           ; Negate result
38EB: E3      	        EX      (SP),HL         ; To be done after caller
38EC: E9      	        JP      (HL)            ; Return to caller
              	
38ED: CD8536  	SQR:    CALL    STAKFP          ; Put value on stack
38F0: 21D238  	        LD      HL,HALF         ; Set power to 1/2
38F3: CD9236  	        CALL    PHLTFP          ; Move 1/2 to FPREG
              	
38F6: C1      	POWER:  POP     BC              ; Get base
38F7: D1      	        POP     DE
38F8: CD5436  	        CALL    TSTSGN          ; Test sign of power
38FB: 78      	        LD      A,B             ; Get exponent of base
38FC: CA3B39  	        JP      Z,EXP           ; Make result 1 if zero
38FF: F20639  	        JP      P,POWER1        ; Positive base - Ok
3902: B7      	        OR      A               ; Zero to negative power?
3903: CAB023  	        JP      Z,DZERR         ; Yes - ?/0 Error
3906: B7      	POWER1: OR      A               ; Base zero?
3907: CA7534  	        JP      Z,SAVEXP        ; Yes - Return zero
390A: D5      	        PUSH    DE              ; Save base
390B: C5      	        PUSH    BC
390C: 79      	        LD      A,C             ; Get MSB of base
390D: F67F    	        OR      01111111B       ; Get sign status
390F: CDA036  	        CALL    BCDEFP          ; Move power to BCDE
3912: F22339  	        JP      P,POWER2        ; Positive base - Ok
3915: D5      	        PUSH    DE              ; Save power
3916: C5      	        PUSH    BC
3917: CD2737  	        CALL    INT             ; Get integer of power
391A: C1      	        POP     BC              ; Restore power
391B: D1      	        POP     DE
391C: F5      	        PUSH    AF              ; MSB of base
391D: CDCF36  	        CALL    CMPNUM          ; Power an integer?
3920: E1      	        POP     HL              ; Restore MSB of base
3921: 7C      	        LD      A,H             ; but don't affect flags
3922: 1F      	        RRA                     ; Exponent odd or even?
3923: E1      	POWER2: POP     HL              ; Restore MSB and exponent
3924: 227641  	        LD      (FPREG+2),HL    ; Save base in FPREG
3927: E1      	        POP     HL              ; LSBs of base
3928: 227441  	        LD      (FPREG),HL      ; Save in FPREG
392B: DCE838  	        CALL    C,NEGAFT        ; Odd power - Negate result
392E: CC7D36  	        CALL    Z,INVSGN        ; Negative base - Negate it
3931: D5      	        PUSH    DE              ; Save power
3932: C5      	        PUSH    BC
3933: CD0835  	        CALL    LOG             ; Get LOG of base
3936: C1      	        POP     BC              ; Restore power
3937: D1      	        POP     DE
3938: CD4935  	        CALL    FPMULT          ; Multiply LOG by power
              	
393B: CD8536  	EXP:    CALL    STAKFP          ; Put value on stack
393E: 013881  	        LD      BC,08138H       ; BCDE = 1/Ln(2)
3941: 113BAA  	        LD      DE,0AA3BH
3944: CD4935  	        CALL    FPMULT          ; Multiply value by 1/LN(2)
3947: 3A7741  	        LD      A,(FPEXP)       ; Get exponent
394A: FE88    	        CP      80H+8           ; Is it in range?
394C: D23036  	        JP      NC,OVTST1       ; No - Test for overflow
394F: CD2737  	        CALL    INT             ; Get INT of FPREG
3952: C680    	        ADD     A,80H           ; For excess 128
3954: C602    	        ADD     A,2             ; Exponent > 126?
3956: DA3036  	        JP      C,OVTST1        ; Yes - Test for overflow
3959: F5      	        PUSH    AF              ; Save scaling factor
395A: 21F734  	        LD      HL,UNITY        ; Point to 1.
395D: CDFF33  	        CALL    ADDPHL          ; Add 1 to FPREG
3960: CD4035  	        CALL    MULLN2          ; Multiply by LN(2)
3963: F1      	        POP     AF              ; Restore scaling factor
3964: C1      	        POP     BC              ; Restore exponent
3965: D1      	        POP     DE
3966: F5      	        PUSH    AF              ; Save scaling factor
3967: CD0B34  	        CALL    SUBCDE          ; Subtract exponent from FPREG
396A: CD7D36  	        CALL    INVSGN          ; Negate result
396D: 217B39  	        LD      HL,EXPTAB       ; Coefficient table
3970: CDAB39  	        CALL    SMSER1          ; Sum the series
3973: 110000  	        LD      DE,0            ; Zero LSBs
3976: C1      	        POP     BC              ; Scaling factor
3977: 4A      	        LD      C,D             ; Zero MSB
3978: C34935  	        JP      FPMULT          ; Scale result to correct value
              	
397B: 08      	EXPTAB: .BYTE      8                       ; Table used by EXP
397C: 402E9474	        .BYTE      040H,02EH,094H,074H     ; -1/7! (-1/5040)
3980: 704F2E77	        .BYTE      070H,04FH,02EH,077H     ;  1/6! ( 1/720)
3984: 6E02887A	        .BYTE      06EH,002H,088H,07AH     ; -1/5! (-1/120)
3988: E6A02A7C	        .BYTE      0E6H,0A0H,02AH,07CH     ;  1/4! ( 1/24)
398C: 50AAAA7E	        .BYTE      050H,0AAH,0AAH,07EH     ; -1/3! (-1/6)
3990: FFFF7F7F	        .BYTE      0FFH,0FFH,07FH,07FH     ;  1/2! ( 1/2)
3994: 00008081	        .BYTE      000H,000H,080H,081H     ; -1/1! (-1/1)
3998: 00000081	        .BYTE      000H,000H,000H,081H     ;  1/0! ( 1/1)
              	
399C: CD8536  	SUMSER: CALL    STAKFP          ; Put FPREG on stack
399F: 114735  	        LD      DE,MULT         ; Multiply by "X"
39A2: D5      	        PUSH    DE              ; To be done after
39A3: E5      	        PUSH    HL              ; Save address of table
39A4: CDA036  	        CALL    BCDEFP          ; Move FPREG to BCDE
39A7: CD4935  	        CALL    FPMULT          ; Square the value
39AA: E1      	        POP     HL              ; Restore address of table
39AB: CD8536  	SMSER1: CALL    STAKFP          ; Put value on stack
39AE: 7E      	        LD      A,(HL)          ; Get number of coefficients
39AF: 23      	        INC     HL              ; Point to start of table
39B0: CD9236  	        CALL    PHLTFP          ; Move coefficient to FPREG
39B3: 06      	        .BYTE      06H             ; Skip "POP AF"
39B4: F1      	SUMLP:  POP     AF              ; Restore count
39B5: C1      	        POP     BC              ; Restore number
39B6: D1      	        POP     DE
39B7: 3D      	        DEC     A               ; Cont coefficients
39B8: C8      	        RET     Z               ; All done
39B9: D5      	        PUSH    DE              ; Save number
39BA: C5      	        PUSH    BC
39BB: F5      	        PUSH    AF              ; Save count
39BC: E5      	        PUSH    HL              ; Save address in table
39BD: CD4935  	        CALL    FPMULT          ; Multiply FPREG by BCDE
39C0: E1      	        POP     HL              ; Restore address in table
39C1: CDA336  	        CALL    LOADFP          ; Number at HL to BCDE
39C4: E5      	        PUSH    HL              ; Save address in table
39C5: CD0E34  	        CALL    FPADD           ; Add coefficient to FPREG
39C8: E1      	        POP     HL              ; Restore address in table
39C9: C3B439  	        JP      SUMLP           ; More coefficients
              	
39CC: CD5436  	RND:    CALL    TSTSGN          ; Test sign of FPREG
39CF: 21A940  	        LD      HL,SEED+2       ; Random number seed
39D2: FA2D3A  	        JP      M,RESEED        ; Negative - Re-seed
39D5: 21CA40  	        LD      HL,LSTRND       ; Last random number
39D8: CD9236  	        CALL    PHLTFP          ; Move last RND to FPREG
39DB: 21A940  	        LD      HL,SEED+2       ; Random number seed
39DE: C8      	        RET     Z               ; Return if RND(0)
39DF: 86      	        ADD     A,(HL)          ; Add (SEED)+2)
39E0: E607    	        AND     00000111B       ; 0 to 7
39E2: 0600    	        LD      B,0
39E4: 77      	        LD      (HL),A          ; Re-save seed
39E5: 23      	        INC     HL              ; Move to coefficient table
39E6: 87      	        ADD     A,A             ; 4 bytes
39E7: 87      	        ADD     A,A             ; per entry
39E8: 4F      	        LD      C,A             ; BC = Offset into table
39E9: 09      	        ADD     HL,BC           ; Point to coefficient
39EA: CDA336  	        CALL    LOADFP          ; Coefficient to BCDE
39ED: CD4935  	        CALL    FPMULT  ;       ; Multiply FPREG by coefficient
39F0: 3AA840  	        LD      A,(SEED+1)      ; Get (SEED+1)
39F3: 3C      	        INC     A               ; Add 1
39F4: E603    	        AND     00000011B       ; 0 to 3
39F6: 0600    	        LD      B,0
39F8: FE01    	        CP      1               ; Is it zero?
39FA: 88      	        ADC     A,B             ; Yes - Make it 1
39FB: 32A840  	        LD      (SEED+1),A      ; Re-save seed
39FE: 21313A  	        LD      HL,RNDTAB-4     ; Addition table
3A01: 87      	        ADD     A,A             ; 4 bytes
3A02: 87      	        ADD     A,A             ; per entry
3A03: 4F      	        LD      C,A             ; BC = Offset into table
3A04: 09      	        ADD     HL,BC           ; Point to value
3A05: CDFF33  	        CALL    ADDPHL          ; Add value to FPREG
3A08: CDA036  	RND1:   CALL    BCDEFP          ; Move FPREG to BCDE
3A0B: 7B      	        LD      A,E             ; Get LSB
3A0C: 59      	        LD      E,C             ; LSB = MSB
3A0D: EE4F    	        XOR     01001111B       ; Fiddle around
3A0F: 4F      	        LD      C,A             ; New MSB
3A10: 3680    	        LD      (HL),80H        ; Set exponent
3A12: 2B      	        DEC     HL              ; Point to MSB
3A13: 46      	        LD      B,(HL)          ; Get MSB
3A14: 3680    	        LD      (HL),80H        ; Make value -0.5
3A16: 21A740  	        LD      HL,SEED         ; Random number seed
3A19: 34      	        INC     (HL)            ; Count seed
3A1A: 7E      	        LD      A,(HL)          ; Get seed
3A1B: D6AB    	        SUB     171             ; Do it modulo 171
3A1D: C2243A  	        JP      NZ,RND2         ; Non-zero - Ok
3A20: 77      	        LD      (HL),A          ; Zero seed
3A21: 0C      	        INC     C               ; Fillde about
3A22: 15      	        DEC     D               ; with the
3A23: 1C      	        INC     E               ; number
3A24: CD5F34  	RND2:   CALL    BNORM           ; Normalise number
3A27: 21CA40  	        LD      HL,LSTRND       ; Save random number
3A2A: C3AC36  	        JP      FPTHL           ; Move FPREG to last and return
              	
3A2D: 77      	RESEED: LD      (HL),A          ; Re-seed random numbers
3A2E: 2B      	        DEC     HL
3A2F: 77      	        LD      (HL),A
3A30: 2B      	        DEC     HL
3A31: 77      	        LD      (HL),A
3A32: C3083A  	        JP      RND1            ; Return RND seed
              	
3A35: 68B14668	RNDTAB: .BYTE   068H,0B1H,046H,068H     ; Table used by RND
3A39: 99E99269	        .BYTE   099H,0E9H,092H,069H
3A3D: 10D17568	        .BYTE   010H,0D1H,075H,068H
              	
3A41: 218B3A  	COS:    LD      HL,HALFPI       ; Point to PI/2
3A44: CDFF33  	        CALL    ADDPHL          ; Add it to PPREG
3A47: CD8536  	SIN:    CALL    STAKFP          ; Put angle on stack
3A4A: 014983  	        LD      BC,8349H        ; BCDE = 2 PI
3A4D: 11DB0F  	        LD      DE,0FDBH
3A50: CD9536  	        CALL    FPBCDE          ; Move 2 PI to FPREG
3A53: C1      	        POP     BC              ; Restore angle
3A54: D1      	        POP     DE
3A55: CDAA35  	        CALL    DVBCDE          ; Divide angle by 2 PI
3A58: CD8536  	        CALL    STAKFP          ; Put it on stack
3A5B: CD2737  	        CALL    INT             ; Get INT of result
3A5E: C1      	        POP     BC              ; Restore number
3A5F: D1      	        POP     DE
3A60: CD0B34  	        CALL    SUBCDE          ; Make it 0 <= value < 1
3A63: 218F3A  	        LD      HL,QUARTR       ; Point to 0.25
3A66: CD0534  	        CALL    SUBPHL          ; Subtract value from 0.25
3A69: CD5436  	        CALL    TSTSGN          ; Test sign of value
3A6C: 37      	        SCF                     ; Flag positive
3A6D: F2773A  	        JP      P,SIN1          ; Positive - Ok
3A70: CDFC33  	        CALL    ROUND           ; Add 0.5 to value
3A73: CD5436  	        CALL    TSTSGN          ; Test sign of value
3A76: B7      	        OR      A               ; Flag negative
3A77: F5      	SIN1:   PUSH    AF              ; Save sign
3A78: F47D36  	        CALL    P,INVSGN        ; Negate value if positive
3A7B: 218F3A  	        LD      HL,QUARTR       ; Point to 0.25
3A7E: CDFF33  	        CALL    ADDPHL          ; Add 0.25 to value
3A81: F1      	        POP     AF              ; Restore sign
3A82: D47D36  	        CALL    NC,INVSGN       ; Negative - Make positive
3A85: 21933A  	        LD      HL,SINTAB       ; Coefficient table
3A88: C39C39  	        JP      SUMSER          ; Evaluate sum of series
              	
3A8B: DB0F4981	HALFPI: .BYTE   0DBH,00FH,049H,081H     ; 1.5708 (PI/2)
              	
3A8F: 0000007F	QUARTR: .BYTE   000H,000H,000H,07FH     ; 0.25
              	
3A93: 05      	SINTAB: .BYTE   5                       ; Table used by SIN
3A94: BAD71E86	        .BYTE   0BAH,0D7H,01EH,086H     ; 39.711
3A98: 64269987	        .BYTE   064H,026H,099H,087H     ;-76.575
3A9C: 58342387	        .BYTE   058H,034H,023H,087H     ; 81.602
3AA0: E05DA586	        .BYTE   0E0H,05DH,0A5H,086H     ;-41.342
3AA4: DA0F4983	        .BYTE   0DAH,00FH,049H,083H     ;  6.2832
              	
3AA8: CD8536  	TAN:    CALL    STAKFP          ; Put angle on stack
3AAB: CD473A  	        CALL    SIN             ; Get SIN of angle
3AAE: C1      	        POP     BC              ; Restore angle
3AAF: E1      	        POP     HL
3AB0: CD8536  	        CALL    STAKFP          ; Save SIN of angle
3AB3: EB      	        EX      DE,HL           ; BCDE = Angle
3AB4: CD9536  	        CALL    FPBCDE          ; Angle to FPREG
3AB7: CD413A  	        CALL    COS             ; Get COS of angle
3ABA: C3A835  	        JP      DIV             ; TAN = SIN / COS
              	
3ABD: CD5436  	ATN:    CALL    TSTSGN          ; Test sign of value
3AC0: FCE838  	        CALL    M,NEGAFT        ; Negate result after if -ve
3AC3: FC7D36  	        CALL    M,INVSGN        ; Negate value if -ve
3AC6: 3A7741  	        LD      A,(FPEXP)       ; Get exponent
3AC9: FE81    	        CP      81H             ; Number less than 1?
3ACB: DADA3A  	        JP      C,ATN1          ; Yes - Get arc tangnt
3ACE: 010081  	        LD      BC,8100H        ; BCDE = 1
3AD1: 51      	        LD      D,C
3AD2: 59      	        LD      E,C
3AD3: CDAA35  	        CALL    DVBCDE          ; Get reciprocal of number
3AD6: 210534  	        LD      HL,SUBPHL       ; Sub angle from PI/2
3AD9: E5      	        PUSH    HL              ; Save for angle > 1
3ADA: 21E43A  	ATN1:   LD      HL,ATNTAB       ; Coefficient table
3ADD: CD9C39  	        CALL    SUMSER          ; Evaluate sum of series
3AE0: 218B3A  	        LD      HL,HALFPI       ; PI/2 - angle in case > 1
3AE3: C9      	        RET                     ; Number > 1 - Sub from PI/2
              	
3AE4: 09      	ATNTAB: .BYTE   9                       ; Table used by ATN
3AE5: 4AD73B78	        .BYTE   04AH,0D7H,03BH,078H     ; 1/17
3AE9: 026E847B	        .BYTE   002H,06EH,084H,07BH     ;-1/15
3AED: FEC12F7C	        .BYTE   0FEH,0C1H,02FH,07CH     ; 1/13
3AF1: 74319A7D	        .BYTE   074H,031H,09AH,07DH     ;-1/11
3AF5: 843D5A7D	        .BYTE   084H,03DH,05AH,07DH     ; 1/9
3AF9: C87F917E	        .BYTE   0C8H,07FH,091H,07EH     ;-1/7
3AFD: E4BB4C7E	        .BYTE   0E4H,0BBH,04CH,07EH     ; 1/5
3B01: 6CAAAA7F	        .BYTE   06CH,0AAH,0AAH,07FH     ;-1/3
3B05: 00000081	        .BYTE   000H,000H,000H,081H     ; 1/1
              	
              	
3B09: C9      	ARET:   RET                     ; A RETurn instruction
              	
3B0A: D7      	GETINP: RST	    10H             ;input a character
3B0B: C9      	        RET
              	
3B0C:         	CLS: 
3B0C: 3E0C    	        LD      A,CS            ; ASCII Clear screen
3B0E: C3463C  	        JP      MONOUT          ; Output character
              	
3B11: CDD333  	WIDTH:  CALL    GETINT          ; Get integer 0-255
3B14: 7B      	        LD      A,E             ; Width to A
3B15: 32D240  	        LD      (LWIDTH),A      ; Set width
3B18: C9      	        RET
              	
3B19: CD722C  	LINES:  CALL    GETNUM          ; Get a number
3B1C: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
3B1F: ED53D640	        LD      (LINESC),DE     ; Set lines counter
3B23: ED53D840	        LD      (LINESN),DE     ; Set lines number
3B27: C9      	        RET
              	
3B28: CDB728  	DEEK:   CALL    DEINT           ; Get integer -32768 to 32767
3B2B: D5      	        PUSH    DE              ; Save number
3B2C: E1      	        POP     HL              ; Number to HL
3B2D: 46      	        LD      B,(HL)          ; Get LSB of contents
3B2E: 23      	        INC     HL
3B2F: 7E      	        LD      A,(HL)          ; Get MSB of contents
3B30: C32D30  	        JP      ABPASS          ; Return integer AB
              	
3B33: CD722C  	DOKE:   CALL    GETNUM          ; Get a number
3B36: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
3B39: D5      	        PUSH    DE              ; Save address
3B3A: CD7B26  	        CALL    CHKSYN          ; Make sure ',' follows
3B3D: 2C      	        .BYTE      ','
3B3E: CD722C  	        CALL    GETNUM          ; Get a number
3B41: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
3B44: E3      	        EX      (SP),HL         ; Save value,get address
3B45: 73      	        LD      (HL),E          ; Save LSB of value
3B46: 23      	        INC     HL
3B47: 72      	        LD      (HL),D          ; Save MSB of value
3B48: E1      	        POP     HL              ; Restore code string address
3B49: C9      	        RET
              	
              	
              	; HEX$(nn) Convert 16 bit number to Hexadecimal string
              	
3B4A: CD752C  	HEX: 	CALL	TSTNUM          ; Verify it's a number
3B4D: CDB728  	        CALL	DEINT           ; Get integer -32768 to 32767
3B50: C5      	        PUSH	BC              ; Save contents of BC
3B51: 217941  	        LD	    HL,PBUFF
3B54: 7A      	        LD	    A,D             ; Get high order into A
3B55: FE00    	        CP      $0
3B57: 280C    			JR      Z,HEX2          ; Skip output if both high digits are zero
3B59: CD823B  	        CALL    BYT2ASC         ; Convert D to ASCII
3B5C: 78      			LD      A,B
3B5D: FE30    			CP      '0'
3B5F: 2802    			JR      Z,HEX1          ; Don't store high digit if zero
3B61: 70      	        LD	    (HL),B          ; Store it to PBUFF
3B62: 23      	        INC	    HL              ; Next location
3B63: 71      	HEX1:   LD	    (HL),C          ; Store C to PBUFF+1
3B64: 23      	        INC     HL              ; Next location
3B65: 7B      	HEX2:   LD	    A,E             ; Get lower byte
3B66: CD823B  	        CALL    BYT2ASC         ; Convert E to ASCII
3B69: 7A      			LD      A,D
3B6A: FE00    	        CP      $0
3B6C: 2005    			JR      NZ,HEX3         ; If upper byte was not zero then always print lower byte
3B6E: 78      			LD      A,B
3B6F: FE30    			CP      '0'             ; If high digit of lower byte is zero then don't print
3B71: 2802    			JR      Z,HEX4
3B73: 70      	HEX3:   LD      (HL),B          ; to PBUFF+2
3B74: 23      	        INC     HL              ; Next location
3B75: 71      	HEX4:   LD      (HL),C          ; to PBUFF+3
3B76: 23      	        INC     HL              ; PBUFF+4 to zero
3B77: AF      	        XOR     A               ; Terminating character
3B78: 77      	        LD      (HL),A          ; Store zero to terminate
3B79: 23      	        INC     HL              ; Make sure PBUFF is terminated
3B7A: 77      	        LD      (HL),A          ; Store the double zero there
3B7B: C1      	        POP     BC              ; Get BC back
3B7C: 217941  	        LD      HL,PBUFF        ; Reset to start of PBUFF
3B7F: C3DB30  	        JP      STR1            ; Convert the PBUFF to a string and return it
              	
3B82: 47      	BYT2ASC	LD      B,A             ; Save original value
3B83: E60F    	        AND     $0F             ; Strip off upper nybble
3B85: FE0A    	        CP      $0A             ; 0-9?
3B87: 3802    	        JR      C,ADD30         ; If A-F, add 7 more
3B89: C607    	        ADD     A,$07           ; Bring value up to ASCII A-F
3B8B: C630    	ADD30	ADD     A,$30           ; And make ASCII
3B8D: 4F      	        LD      C,A             ; Save converted char to C
3B8E: 78      	        LD      A,B             ; Retrieve original value
3B8F: 0F      	        RRCA                    ; and Rotate it right
3B90: 0F      	        RRCA
3B91: 0F      	        RRCA
3B92: 0F      	        RRCA
3B93: E60F    	        AND     $0F             ; Mask off upper nybble
3B95: FE0A    	        CP      $0A             ; 0-9? < A hex?
3B97: 3802    	        JR      C,ADD301        ; Skip Add 7
3B99: C607    	        ADD     A,$07           ; Bring it up to ASCII A-F
3B9B: C630    	ADD301	ADD     A,$30           ; And make it full ASCII
3B9D: 47      	        LD      B,A             ; Store high order byte
3B9E: C9      	        RET	
              	
              	; Convert "&Hnnnn" to FPREG
              	; Gets a character from (HL) checks for Hexadecimal ASCII numbers "&Hnnnn"
              	; Char is in A, NC if char is ;<=>?@ A-z, CY is set if 0-9
3B9F: EB      	HEXTFP  EX      DE,HL           ; Move code string pointer to DE
3BA0: 210000  	        LD      HL,$0000        ; Zero out the value
3BA3: CDB83B  	        CALL    GETHEX          ; Check the number for valid hex
3BA6: DAD83B  	        JP      C,HXERR         ; First value wasn't hex, HX error
3BA9: 1805    	        JR      HEXLP1          ; Convert first character
3BAB: CDB83B  	HEXLP   CALL    GETHEX          ; Get second and addtional characters
3BAE: 381F    	        JR      C,HEXIT         ; Exit if not a hex character
3BB0: 29      	HEXLP1  ADD     HL,HL           ; Rotate 4 bits to the left
3BB1: 29      	        ADD     HL,HL
3BB2: 29      	        ADD     HL,HL
3BB3: 29      	        ADD     HL,HL
3BB4: B5      	        OR      L               ; Add in D0-D3 into L
3BB5: 6F      	        LD      L,A             ; Save new value
3BB6: 18F3    	        JR      HEXLP           ; And continue until all hex characters are in
              	
3BB8: 13      	GETHEX  INC     DE              ; Next location
3BB9: 1A      	        LD      A,(DE)          ; Load character at pointer
3BBA: FE20    	        CP      ' '
3BBC: CAB83B  	        JP      Z,GETHEX        ; Skip spaces
3BBF: D630    	        SUB     $30             ; Get absolute value
3BC1: D8      	        RET     C               ; < "0", error
3BC2: FE0A    	        CP      $0A
3BC4: 3805    	        JR      C,NOSUB7        ; Is already in the range 0-9
3BC6: D607    	        SUB     $07             ; Reduce to A-F
3BC8: FE0A    	        CP      $0A             ; Value should be $0A-$0F at this point
3BCA: D8      	        RET     C               ; CY set if was :            ; < = > ? @
3BCB: FE10    	NOSUB7  CP      $10             ; > Greater than "F"?
3BCD: 3F      	        CCF
3BCE: C9      	        RET                     ; CY set if it wasn't valid hex
              	    
3BCF: EB      	HEXIT   EX      DE,HL           ; Value into DE, Code string into HL
3BD0: 7A      	        LD      A,D             ; Load DE into AC
3BD1: 4B      	        LD      C,E             ; For prep to 
3BD2: E5      	        PUSH    HL
3BD3: CD2C30  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
3BD6: E1      	        POP     HL
3BD7: C9      	        RET
              	
3BD8: 1E26    	HXERR:  LD      E,HX            ; ?HEX Error
3BDA: C3C123  	        JP      ERROR
              	
              	; BIN$(NN) Convert integer to a 1-16 char binary string
3BDD: CD752C  	BIN:    CALL    TSTNUM          ; Verify it's a number
3BE0: CDB728  	        CALL    DEINT           ; Get integer -32768 to 32767
3BE3: C5      	BIN2:   PUSH    BC              ; Save contents of BC
3BE4: 217941  	        LD      HL,PBUFF
3BE7: 0611    	        LD      B,17            ; One higher than max char count
3BE9:         	ZEROSUP:                        ; Suppress leading zeros
3BE9: 05      	        DEC     B               ; Max 16 chars
3BEA: 78      	        LD      A,B
3BEB: FE01    	        CP      $01
3BED: 2808    	        JR      Z,BITOUT        ; Always output at least one character
3BEF: CB13    	        RL      E
3BF1: CB12    	        RL      D
3BF3: 30F4    	        JR      NC,ZEROSUP
3BF5: 1804    	        JR      BITOUT2
3BF7:         	BITOUT:      
3BF7: CB13    	        RL      E
3BF9: CB12    	        RL      D               ; Top bit now in carry
3BFB:         	BITOUT2:
3BFB: 3E30    	        LD      A,'0'           ; Char for '0'
3BFD: CE00    	        ADC     A,0             ; If carry set then '0' --> '1'
3BFF: 77      	        LD      (HL),A
3C00: 23      	        INC     HL
3C01: 05      	        DEC     B
3C02: 20F3    	        JR      NZ,BITOUT
3C04: AF      	        XOR     A               ; Terminating character
3C05: 77      	        LD      (HL),A          ; Store zero to terminate
3C06: 23      	        INC     HL              ; Make sure PBUFF is terminated
3C07: 77      	        LD      (HL),A          ; Store the double zero there
3C08: C1      	        POP     BC
3C09: 217941  	        LD      HL,PBUFF
3C0C: C3DB30  	        JP      STR1
              	
              	; Convert "&Bnnnn" to FPREG
              	; Gets a character from (HL) checks for Binary ASCII numbers "&Bnnnn"
3C0F: EB      	BINTFP: EX      DE,HL           ; Move code string pointer to DE
3C10: 210000  	        LD      HL,$0000        ; Zero out the value
3C13: CD2C3C  	        CALL    CHKBIN          ; Check the number for valid bin
3C16: DA3A3C  	        JP      C,BINERR        ; First value wasn't bin, HX error
3C19: D630    	BINIT:  SUB     '0'
3C1B: 29      	        ADD     HL,HL           ; Rotate HL left
3C1C: B5      	        OR      L
3C1D: 6F      	        LD      L,A
3C1E: CD2C3C  	        CALL    CHKBIN          ; Get second and addtional characters
3C21: 30F6    	        JR      NC,BINIT        ; Process if a bin character
3C23: EB      	        EX      DE,HL           ; Value into DE, Code string into HL
3C24: 7A      	        LD      A,D             ; Load DE into AC
3C25: 4B      	        LD      C,E             ; For prep to 
3C26: E5      	        PUSH    HL
3C27: CD2C30  	        CALL    ACPASS          ; ACPASS to set AC as integer into FPREG
3C2A: E1      	        POP     HL
3C2B: C9      	        RET
              	
              	; Char is in A, NC if char is 0 or 1
3C2C: 13      	CHKBIN: INC     DE
3C2D: 1A      	        LD      A,(DE)
3C2E: FE20    	        CP      ' '
3C30: CA2C3C  	        JP      Z,CHKBIN        ; Skip spaces
3C33: FE30    	        CP      '0'             ; Set C if < '0'
3C35: D8      	        RET     C
3C36: FE32    	        CP      '2'
3C38: 3F      	        CCF                     ; Set C if > '1'
3C39: C9      	        RET
              	
3C3A: 1E28    	BINERR: LD      E,BN            ; ?BIN Error
3C3C: C3C123  	        JP      ERROR
              	
              	
3C3F:         	JJUMP1: 
3C3F: DD21FFFF	        LD      IX,-1           ; Flag cold start
3C43: C31120  	        JP      CSTART          ; Go and initialise
              	
3C46:         	MONOUT: 
3C46: C30800  	        JP      $0008           ; output a char
              	
              	
3C49:         	MONITR: 
3C49: C30000  	        JP      $0000           ; Restart (Normally Monitor Start)
              	
              	
3C4C: 3E00    	INITST: LD      A,0             ; Clear break flag
3C4E: 32DD40  	        LD      (BRKFLG),A
3C51: C31820  	        JP      INIT
              	
3C54: ED45    	ARETN:  RETN                    ; Return from NMI
              	
              	
3C56: F5      	TSTBIT: PUSH    AF              ; Save bit mask
3C57: A0      	        AND     B               ; Get common bits
3C58: C1      	        POP     BC              ; Restore bit mask
3C59: B8      	        CP      B               ; Same bit set?
3C5A: 3E00    	        LD      A,0             ; Return 0 in A
3C5C: C9      	        RET
              	
3C5D: CD8626  	OUTNCR: CALL    OUTC            ; Output character in A
3C60: C3AD2A  	        JP      PRNTCRLF        ; Output CRLF
              	
              	.end
              	
***ERROR*** No such file or directory: file = "/pub/Develop/Projects/zasm-4.0/Test/Z80/original/MS-Basic." (fd108)


; +++ segments +++

#CODE          = $2000 =  8192,  size = $1C63 =  7267

; +++ global symbols +++

ABPASS   = $302D = 12333          MS-Basic.asm:2414
ABS      = $3679 = 13945          MS-Basic.asm:3437
ACCSUM   = $2896 = 10390          MS-Basic.asm:1316 (unused)
ACPASS   = $302C = 12332          MS-Basic.asm:2413
ADD30    = $3B8B = 15243          MS-Basic.asm:4185
ADD301   = $3B9B = 15259          MS-Basic.asm:4196
ADDEXP   = $3612 = 13842          MS-Basic.asm:3372
ADDIG    = $37B8 = 14264          MS-Basic.asm:3660
ADDPHL   = $33FF = 13311          MS-Basic.asm:3019
ALLFOL   = $32FB = 13051          MS-Basic.asm:2861
ANTVLU   = $2B96 = 11158          MS-Basic.asm:1723
ARET     = $3B09 = 15113          MS-Basic.asm:4100 (unused)
ARETN    = $3C54 = 15444          MS-Basic.asm:4328 (unused)
ARLDSV   = $2F4D = 12109          MS-Basic.asm:2269
ARREND   = $416A = 16746          MS-Basic.asm:94
ARRLP    = $31C6 = 12742          MS-Basic.asm:2652
ASC      = $32CC = 13004          MS-Basic.asm:2831
ASCTFP   = $375B = 14171          MS-Basic.asm:3606
ASPCS    = $2AF8 = 11000          MS-Basic.asm:1646
ATN      = $3ABD = 15037          MS-Basic.asm:4071
ATN1     = $3ADA = 15066          MS-Basic.asm:4083
ATNTAB   = $3AE4 = 15076          MS-Basic.asm:4088
ATOH     = $28D1 = 10449          MS-Basic.asm:1349
BADINP   = $2B1D = 11037          MS-Basic.asm:1658
BAKSTK   = $2356 =  9046          MS-Basic.asm:524
BAKTMP   = $32AC = 12972          MS-Basic.asm:2809
BASTXT   = $40EE = 16622          MS-Basic.asm:70
BCDEFP   = $36A0 = 13984          MS-Basic.asm:3464
BFREE    = $20AD =  8365          MS-Basic.asm:223
BIN      = $3BDD = 15325          MS-Basic.asm:4245
BIN2     = $3BE3 = 15331          MS-Basic.asm:4247 (unused)
BINERR   = $3C3A = 15418          MS-Basic.asm:4308
BINIT    = $3C19 = 15385          MS-Basic.asm:4283
BINTFP   = $3C0F = 15375          MS-Basic.asm:4279
BITOUT   = $3BF7 = 15351          MS-Basic.asm:4259
BITOUT2  = $3BFB = 15355          MS-Basic.asm:4262
BKSP     = $0008 =     8          MS-Basic.asm:27
BN       = $0028 =    40          MS-Basic.asm:128
BNORM    = $345F = 13407          MS-Basic.asm:3078
BNRMLP   = $3462 = 13410          MS-Basic.asm:3081
BRK      = $2848 = 10312          MS-Basic.asm:1271
BRKFLG   = $40DD = 16605          MS-Basic.asm:63
BRKLIN   = $415E = 16734          MS-Basic.asm:88
BRKMSG   = $2350 =  9040          MS-Basic.asm:522
BRKRET   = $20A7 =  8359          MS-Basic.asm:220
BS       = $0010 =    16          MS-Basic.asm:116
BSERR    = $2F80 = 12160          MS-Basic.asm:2300
BUFFER   = $40F1 = 16625          MS-Basic.asm:71
BYT2ASC  = $3B82 = 15234          MS-Basic.asm:4180
BYTSFT   = $3597 = 13719          MS-Basic.asm:3289
CFEVAL   = $2EE3 = 12003          MS-Basic.asm:2200
CHARTY   = $2E91 = 11921          MS-Basic.asm:2156
CHEKFN   = $30C4 = 12484          MS-Basic.asm:2505
CHKBIN   = $3C2C = 15404          MS-Basic.asm:4298
CHKLTR   = $28A3 = 10403          MS-Basic.asm:1325
CHKSTK   = $238A =  9098          MS-Basic.asm:561
CHKSUM   = $40DA = 16602          MS-Basic.asm:61
CHKSYN   = $267B =  9851          MS-Basic.asm:995
CHKTYP   = $2C77 = 11383          MS-Basic.asm:1838
CHR      = $32DD = 13021          MS-Basic.asm:2843
CLEAR    = $28F6 = 10486          MS-Basic.asm:1373
CLOTST   = $26B0 =  9904          MS-Basic.asm:1027
CLREG    = $24DF =  9439          MS-Basic.asm:767
CLRPTR   = $24BA =  9402          MS-Basic.asm:747
CLS      = $3B0C = 15116          MS-Basic.asm:4105
CMPFP    = $36E9 = 14057          MS-Basic.asm:3522
CMPLG1   = $2DF7 = 11767          MS-Basic.asm:2062
CMPLOG   = $2DF5 = 11765          MS-Basic.asm:2061
CMPNUM   = $36CF = 14031          MS-Basic.asm:3505
CMPRES   = $2E39 = 11833          MS-Basic.asm:2110
CMPSTR   = $2E21 = 11809          MS-Basic.asm:2090
CN       = $0020 =    32          MS-Basic.asm:124
CNVNUM   = $3767 = 14183          MS-Basic.asm:3612
COLD     = $2000 =  8192          MS-Basic.asm:132 (unused)
COMMAN   = $40D3 = 16595          MS-Basic.asm:56
COMPL    = $34BF = 13503          MS-Basic.asm:3152
CONCAT   = $3241 = 12865          MS-Basic.asm:2742
CONEXP   = $3797 = 14231          MS-Basic.asm:3636
CONPOS   = $345C = 13404          MS-Basic.asm:3076
CONT     = $287B = 10363          MS-Basic.asm:1299
CONTAD   = $4164 = 16740          MS-Basic.asm:91
CONVAR   = $2D62 = 11618          MS-Basic.asm:1962
COPY     = $2020 =  8224          MS-Basic.asm:149
COS      = $3A41 = 14913          MS-Basic.asm:4019
COUNT    = $2720 = 10016          MS-Basic.asm:1093
CPDEHL   = $2675 =  9845          MS-Basic.asm:988
CPYLIT   = $25B1 =  9649          MS-Basic.asm:885
CR       = $000D =    13          MS-Basic.asm:30
CRARLP   = $2FA0 = 12192          MS-Basic.asm:2320
CREARY   = $2F85 = 12165          MS-Basic.asm:2303
CRESTR   = $29F5 = 10741          MS-Basic.asm:1512
CRNCLP   = $2512 =  9490          MS-Basic.asm:793
CRTMST   = $30FD = 12541          MS-Basic.asm:2538
CRTST    = $3109 = 12553          MS-Basic.asm:2549
CRTSTE   = $311F = 12575          MS-Basic.asm:2563
CRUNCH   = $2509 =  9481          MS-Basic.asm:789
CS       = $000C =    12          MS-Basic.asm:29
CSTART   = $2011 =  8209          MS-Basic.asm:142
CTLOFG   = $40D5 = 16597          MS-Basic.asm:58
CTRLC    = $0003 =     3          MS-Basic.asm:25
CTRLG    = $0007 =     7          MS-Basic.asm:26
CTRLO    = $000F =    15          MS-Basic.asm:31
CTRLQ    = $0011 =    17          MS-Basic.asm:32
CTRLR    = $0012 =    18          MS-Basic.asm:33
CTRLS    = $0013 =    19          MS-Basic.asm:34
CTRLU    = $0015 =    21          MS-Basic.asm:35
CUROPR   = $4155 = 16725          MS-Basic.asm:82
CURPOS   = $413B = 16699          MS-Basic.asm:73
DATA     = $299C = 10652          MS-Basic.asm:1464
DATFLG   = $413E = 16702          MS-Basic.asm:76
DATLIN   = $4159 = 16729          MS-Basic.asm:84
DATSNR   = $23A7 =  9127          MS-Basic.asm:581
DCBCDE   = $3720 = 14112          MS-Basic.asm:3565
DD       = $0012 =    18          MS-Basic.asm:117
DDERR    = $23B6 =  9142          MS-Basic.asm:589
DEEK     = $3B28 = 15144          MS-Basic.asm:4120
DEF      = $3041 = 12353          MS-Basic.asm:2426
DEFSIZ   = $2FA8 = 12200          MS-Basic.asm:2324
DEINT    = $28B7 = 10423          MS-Basic.asm:1336
DEL      = $007F =   127          MS-Basic.asm:37
DELCHR   = $25E1 =  9697          MS-Basic.asm:915
DEPINT   = $28B1 = 10417          MS-Basic.asm:1334
DETHL4   = $36AF = 13999          MS-Basic.asm:3476
DETHLB   = $36B1 = 14001          MS-Basic.asm:3477
DIGTXT   = $3861 = 14433          MS-Basic.asm:3758
DIM      = $2E63 = 11875          MS-Basic.asm:2136
DIMRET   = $2E5A = 11866          MS-Basic.asm:2131
DINPOS   = $26AA =  9898          MS-Basic.asm:1022
DIV      = $35A8 = 13736          MS-Basic.asm:3300
DIV1     = $409A = 16538          MS-Basic.asm:46
DIV10    = $359C = 13724          MS-Basic.asm:3295
DIV2     = $409E = 16542          MS-Basic.asm:47
DIV3     = $40A2 = 16546          MS-Basic.asm:48
DIV4     = $40A5 = 16549          MS-Basic.asm:49
DIVLP    = $35CF = 13775          MS-Basic.asm:3324
DIVSUP   = $4099 = 16537          MS-Basic.asm:45
DOAGN    = $24F8 =  9464          MS-Basic.asm:780
DOCOM    = $2AC9 = 10953          MS-Basic.asm:1622
DODEL    = $25C1 =  9665          MS-Basic.asm:899
DOEBIT   = $38A1 = 14497          MS-Basic.asm:3801
DOFN     = $306E = 12398          MS-Basic.asm:2454
DOKE     = $3B33 = 15155          MS-Basic.asm:4128
DONULL   = $2AB7 = 10935          MS-Basic.asm:1611
DOSPC    = $2AF3 = 10995          MS-Basic.asm:1643
DOTAB    = $2AE0 = 10976          MS-Basic.asm:1633
DPOINT   = $3793 = 14227          MS-Basic.asm:3634
DTSTR    = $310D = 12557          MS-Basic.asm:2552
DVBCDE   = $35AA = 13738          MS-Basic.asm:3302
DZ       = $0014 =    20          MS-Basic.asm:118
DZERR    = $23B0 =  9136          MS-Basic.asm:585
ECHDEL   = $25D5 =  9685          MS-Basic.asm:908
EDIGIT   = $37DA = 14298          MS-Basic.asm:3683
ENDBUF   = $25B8 =  9656          MS-Basic.asm:891
ENDCON   = $37A6 = 14246          MS-Basic.asm:3646
ENDDIM   = $3007 = 12295          MS-Basic.asm:2393
ENDINP   = $2AA8 = 10920          MS-Basic.asm:1605
ENDNAM   = $2E85 = 11909          MS-Basic.asm:2152
ENDPRG   = $2857 = 10327          MS-Basic.asm:1282
ENFMEM   = $2393 =  9107          MS-Basic.asm:567
ERRIN    = $23E1 =  9185          MS-Basic.asm:610
ERRLIN   = $4162 = 16738          MS-Basic.asm:90
ERRMSG   = $233E =  9022          MS-Basic.asm:518
ERROR    = $23C1 =  9153          MS-Basic.asm:597
ERRORS   = $22B4 =  8884          MS-Basic.asm:447
ESC      = $001B =    27          MS-Basic.asm:36
EVAL     = $2C84 = 11396          MS-Basic.asm:1846
EVAL1    = $2C87 = 11399          MS-Basic.asm:1848
EVAL2    = $2C90 = 11408          MS-Basic.asm:1852
EVAL3    = $2C93 = 11411          MS-Basic.asm:1853
EVLPAR   = $2D49 = 11593          MS-Basic.asm:1948
EVNOT    = $2E43 = 11843          MS-Basic.asm:2118
EXCUTE   = $27E5 = 10213          MS-Basic.asm:1204
EXP      = $393B = 14651          MS-Basic.asm:3888
EXPLP    = $3785 = 14213          MS-Basic.asm:3626
EXPTAB   = $397B = 14715          MS-Basic.asm:3916
EXPTEN   = $38B3 = 14515          MS-Basic.asm:3811
EXTIG    = $2BF2 = 11250          MS-Basic.asm:1771
FANDT    = $2C1C = 11292          MS-Basic.asm:1789
FC       = $0008 =     8          MS-Basic.asm:112
FCERR    = $28CC = 10444          MS-Basic.asm:1346
FDTLP    = $2C03 = 11267          MS-Basic.asm:1773
FINDEL   = $2FE3 = 12259          MS-Basic.asm:2365
FLGDIF   = $365F = 13919          MS-Basic.asm:3420
FLGREL   = $3666 = 13926          MS-Basic.asm:3426
FNARG    = $4170 = 16752          MS-Basic.asm:97
FNCTAB   = $20FE =  8446          MS-Basic.asm:233
FNDARY   = $2F53 = 12115          MS-Basic.asm:2273
FNDELP   = $2FE8 = 12264          MS-Basic.asm:2370
FNDEND   = $248D =  9357          MS-Basic.asm:710
FNDNUM   = $33D0 = 13264          MS-Basic.asm:2993
FNDTOK   = $26FF =  9983          MS-Basic.asm:1073
FNDVAR   = $2ECA = 11978          MS-Basic.asm:2184
FNDWRD   = $253C =  9532          MS-Basic.asm:813
FNOFST   = $2D73 = 11635          MS-Basic.asm:1972
FNRGNM   = $416E = 16750          MS-Basic.asm:96
FNTHR    = $2ED8 = 11992          MS-Basic.asm:2192
FNVAL    = $2D9A = 11674          MS-Basic.asm:1994
FOPRND   = $2CBC = 11452          MS-Basic.asm:1874
FOR      = $274C = 10060          MS-Basic.asm:1115
FORFLG   = $415B = 16731          MS-Basic.asm:85
FORFND   = $277C = 10108          MS-Basic.asm:1143
FORSLP   = $2760 = 10080          MS-Basic.asm:1124
FPADD    = $340E = 13326          MS-Basic.asm:3027
FPBCDE   = $3695 = 13973          MS-Basic.asm:3456
FPEXP    = $4177 = 16759          MS-Basic.asm:99
FPINT    = $36FC = 14076          MS-Basic.asm:3542
FPMULT   = $3549 = 13641          MS-Basic.asm:3238
FPREG    = $4174 = 16756          MS-Basic.asm:98
FPROND   = $34A6 = 13478          MS-Basic.asm:3128
FPSINT   = $28AB = 10411          MS-Basic.asm:1332
FPTHL    = $36AC = 13996          MS-Basic.asm:3475
FRE      = $300B = 12299          MS-Basic.asm:2396
FRENUM   = $3027 = 12327          MS-Basic.asm:2408
FRMEVL   = $2D65 = 11621          MS-Basic.asm:1963
GARBGE   = $318E = 12686          MS-Basic.asm:2625
GARBLP   = $3191 = 12689          MS-Basic.asm:2626
GETCHR   = $2805 = 10245          MS-Basic.asm:1224
GETCMD   = $2405 =  9221          MS-Basic.asm:627
GETHEX   = $3BB8 = 15288          MS-Basic.asm:4218
GETINP   = $3B0A = 15114          MS-Basic.asm:4102
GETINT   = $33D3 = 13267          MS-Basic.asm:2994
GETLEN   = $32C1 = 12993          MS-Basic.asm:2823
GETLIN   = $25F2 =  9714          MS-Basic.asm:923
GETLN    = $28D2 = 10450          MS-Basic.asm:1350
GETNUM   = $2C72 = 11378          MS-Basic.asm:1835
GETNXT   = $2557 =  9559          MS-Basic.asm:828
GETSTR   = $328B = 12939          MS-Basic.asm:2789
GETVAR   = $2E68 = 11880          MS-Basic.asm:2139
GNXARY   = $31C5 = 12741          MS-Basic.asm:2651
GOFUNC   = $2DA2 = 11682          MS-Basic.asm:1998
GOSUB    = $2948 = 10568          MS-Basic.asm:1415
GOTO     = $2959 = 10585          MS-Basic.asm:1427
GRBARY   = $31E5 = 12773          MS-Basic.asm:2670
GRBDON   = $3166 = 12646          MS-Basic.asm:2600
GRBLP    = $319F = 12703          MS-Basic.asm:2632
GSTRCU   = $328E = 12942          MS-Basic.asm:2790
GSTRDE   = $3292 = 12946          MS-Basic.asm:2792
GSTRHL   = $3291 = 12945          MS-Basic.asm:2791
GTFLNM   = $32D0 = 13008          MS-Basic.asm:2833 (unused)
GTFNAM   = $2E6D = 11885          MS-Basic.asm:2142
GTLNLP   = $28D5 = 10453          MS-Basic.asm:1351
GTSIXD   = $382B = 14379          MS-Basic.asm:3727
GTVLUS   = $2B6E = 11118          MS-Basic.asm:1701
HALF     = $38D2 = 14546          MS-Basic.asm:3832
HALFPI   = $3A8B = 14987          MS-Basic.asm:4050
HEX      = $3B4A = 15178          MS-Basic.asm:4145
HEX1     = $3B63 = 15203          MS-Basic.asm:4158
HEX2     = $3B65 = 15205          MS-Basic.asm:4160
HEX3     = $3B73 = 15219          MS-Basic.asm:4168
HEX4     = $3B75 = 15221          MS-Basic.asm:4170
HEXIT    = $3BCF = 15311          MS-Basic.asm:4233
HEXLP    = $3BAB = 15275          MS-Basic.asm:4208
HEXLP1   = $3BB0 = 15280          MS-Basic.asm:4210
HEXTFP   = $3B9F = 15263          MS-Basic.asm:4203
HX       = $0026 =    38          MS-Basic.asm:127
HXERR    = $3BD8 = 15320          MS-Basic.asm:4241
ID       = $0016 =    22          MS-Basic.asm:119
IDTEST   = $30B6 = 12470          MS-Basic.asm:2495
IF       = $2A2B = 10795          MS-Basic.asm:1545
IFGO     = $2A39 = 10809          MS-Basic.asm:1552
IFJMP    = $27EC = 10220          MS-Basic.asm:1207
INCHL    = $36AA = 13994          MS-Basic.asm:3472
INCLEN   = $26A6 =  9894          MS-Basic.asm:1020
INDFND   = $2370 =  9072          MS-Basic.asm:543
INEWLN   = $2455 =  9301          MS-Basic.asm:670
INIT     = $2018 =  8216          MS-Basic.asm:146
INITAB   = $22DE =  8926          MS-Basic.asm:471
INITBE   = $233E =  9022          MS-Basic.asm:514
INITST   = $3C4C = 15436          MS-Basic.asm:4324
INMSG    = $2345 =  9029          MS-Basic.asm:519
INP      = $3390 = 13200          MS-Basic.asm:2962
INPBIN   = $2BC0 = 11200          MS-Basic.asm:1745
INPBRK   = $2854 = 10324          MS-Basic.asm:1280
INPORT   = $40CF = 16591          MS-Basic.asm:53
INPSUB   = $40CE = 16590          MS-Basic.asm:52
INPUT    = $2B2E = 11054          MS-Basic.asm:1666
INRNG    = $3834 = 14388          MS-Basic.asm:3732
INT      = $3727 = 14119          MS-Basic.asm:3573
INTVAR   = $24C9 =  9417          MS-Basic.asm:758
INVSGN   = $367D = 13949          MS-Basic.asm:3439
ITMSEP   = $2BB1 = 11185          MS-Basic.asm:1736
JJUMP1   = $3C3F = 15423          MS-Basic.asm:4312 (unused)
JSTZER   = $38BD = 14525          MS-Basic.asm:3817
KILFOR   = $2C62 = 11362          MS-Basic.asm:1826
KILIN    = $25EC =  9708          MS-Basic.asm:920
LCRFLG   = $413C = 16700          MS-Basic.asm:74
LEFT     = $32ED = 13037          MS-Basic.asm:2851
LEN      = $32BD = 12989          MS-Basic.asm:2821
LET      = $29B3 = 10675          MS-Basic.asm:1480
LETNUM   = $2A06 = 10758          MS-Basic.asm:1522
LETSTR   = $29CE = 10702          MS-Basic.asm:1493
LF       = $000A =    10          MS-Basic.asm:28
LFRGNM   = $3386 = 13190          MS-Basic.asm:2953
LINEAT   = $40EC = 16620          MS-Basic.asm:69
LINEIN   = $37E6 = 14310          MS-Basic.asm:3693
LINES    = $3B19 = 15129          MS-Basic.asm:4114
LINESC   = $40D6 = 16598          MS-Basic.asm:59
LINESN   = $40D8 = 16600          MS-Basic.asm:60
LINFND   = $243E =  9278          MS-Basic.asm:656
LIST     = $26C1 =  9921          MS-Basic.asm:1037
LISTLP   = $26CD =  9933          MS-Basic.asm:1043
LOADFP   = $36A3 = 13987          MS-Basic.asm:3465
LOG      = $3508 = 13576          MS-Basic.asm:3206
LOGTAB   = $34FB = 13563          MS-Basic.asm:3201
LOKFOR   = $235A =  9050          MS-Basic.asm:526
LOOPST   = $4157 = 16727          MS-Basic.asm:83
LS       = $001C =    28          MS-Basic.asm:122
LSTBIN   = $415C = 16732          MS-Basic.asm:86
LSTLP2   = $26ED =  9965          MS-Basic.asm:1064
LSTLP3   = $26F0 =  9968          MS-Basic.asm:1065
LSTRAM   = $413F = 16703          MS-Basic.asm:77
LSTRND   = $40CA = 16586          MS-Basic.asm:51
LTSTND   = $2BCB = 11211          MS-Basic.asm:1750
LWIDTH   = $40D2 = 16594          MS-Basic.asm:55
MAKINT   = $33D6 = 13270          MS-Basic.asm:2995
MAKNUM   = $3850 = 14416          MS-Basic.asm:3747
MANLP    = $376F = 14191          MS-Basic.asm:3618
MATCH    = $2589 =  9609          MS-Basic.asm:860
MEMMSG   = $20F3 =  8435          MS-Basic.asm:229
MID      = $3327 = 13095          MS-Basic.asm:2891
MID1     = $32F3 = 13043          MS-Basic.asm:2855
MIDNUM   = $338B = 13195          MS-Basic.asm:2956
MINCDE   = $344E = 13390          MS-Basic.asm:3062
MINUS    = $2D51 = 11601          MS-Basic.asm:1953
MKTMST   = $30FA = 12538          MS-Basic.asm:2537
MLDBLP   = $3748 = 14152          MS-Basic.asm:3594
MLDEBC   = $3740 = 14144          MS-Basic.asm:3589
MLOOP    = $2048 =  8264          MS-Basic.asm:167
MLSP10   = $363D = 13885          MS-Basic.asm:3400
MO       = $0024 =    36          MS-Basic.asm:126
MONITR   = $3C49 = 15433          MS-Basic.asm:4320
MONOUT   = $3C46 = 15430          MS-Basic.asm:4316
MORDT    = $2BD7 = 11223          MS-Basic.asm:1755
MORINP   = $25FB =  9723          MS-Basic.asm:928
MOVBUF   = $2474 =  9332          MS-Basic.asm:691
MOVDIR   = $2591 =  9617          MS-Basic.asm:868
MOVLP    = $237F =  9087          MS-Basic.asm:553
MOVSTR   = $237C =  9084          MS-Basic.asm:550
MOVUP    = $2379 =  9081          MS-Basic.asm:549
MRPRNT   = $2A4B = 10827          MS-Basic.asm:1559
MSIZE    = $2035 =  8245          MS-Basic.asm:160
MUL8LP   = $3574 = 13684          MS-Basic.asm:3261
MULLN2   = $3540 = 13632          MS-Basic.asm:3232
MULT     = $3547 = 13639          MS-Basic.asm:3236
MULT8    = $356B = 13675          MS-Basic.asm:3255
MULTEN   = $37B1 = 14257          MS-Basic.asm:3654
MULVAL   = $4186 = 16774          MS-Basic.asm:102
MVSTPT   = $29FD = 10749          MS-Basic.asm:1516
NEDMOR   = $2B6A = 11114          MS-Basic.asm:1699
NEGAFT   = $38E8 = 14568          MS-Basic.asm:3841
NEW      = $24B9 =  9401          MS-Basic.asm:746
NEXITM   = $2B03 = 11011          MS-Basic.asm:1652
NEXT     = $2C27 = 11303          MS-Basic.asm:1794
NEXT1    = $2C2A = 11306          MS-Basic.asm:1795
NF       = $0000 =     0          MS-Basic.asm:108
NFERR    = $23B3 =  9139          MS-Basic.asm:587
NMIFLG   = $40DC = 16604          MS-Basic.asm:62 (unused)
NOCHNG   = $2581 =  9601          MS-Basic.asm:855
NOENED   = $38C0 = 14528          MS-Basic.asm:3820
NOLIN    = $286A = 10346          MS-Basic.asm:1291
NOMADD   = $3585 = 13701          MS-Basic.asm:3272
NOMLAD   = $3756 = 14166          MS-Basic.asm:3602
NOPMPT   = $2B48 = 11080          MS-Basic.asm:1678
NORMAL   = $3479 = 13433          MS-Basic.asm:3097
NOSPC    = $2578 =  9592          MS-Basic.asm:850
NOSUB7   = $3BCB = 15307          MS-Basic.asm:4229
NOSWAP   = $3428 = 13352          MS-Basic.asm:3043
NOTAMP   = $2D26 = 11558          MS-Basic.asm:1934
NOTSTR   = $2EA0 = 11936          MS-Basic.asm:2164
NOXOR    = $33B6 = 13238          MS-Basic.asm:2979
NSCFOR   = $2EB0 = 11952          MS-Basic.asm:2172
NULFLG   = $40D4 = 16596          MS-Basic.asm:57
NULL     = $288E = 10382          MS-Basic.asm:1310
NULLP    = $2ABE = 10942          MS-Basic.asm:1614
NULLS    = $40D1 = 16593          MS-Basic.asm:54
NUMASC   = $37F9 = 14329          MS-Basic.asm:3703
NXTARY   = $2F67 = 12135          MS-Basic.asm:2285
NXTBYT   = $2567 =  9575          MS-Basic.asm:840
NXTCHR   = $25A8 =  9640          MS-Basic.asm:880
NXTDAT   = $416C = 16748          MS-Basic.asm:95
NXTDTA   = $299B = 10651          MS-Basic.asm:1462
NXTITM   = $2B62 = 11106          MS-Basic.asm:1694
NXTOPR   = $4160 = 16736          MS-Basic.asm:89
NXTSTL   = $29A2 = 10658          MS-Basic.asm:1467
NXTSTT   = $29A5 = 10661          MS-Basic.asm:1470
OD       = $0006 =     6          MS-Basic.asm:111
OKMSG    = $234A =  9034          MS-Basic.asm:521
OM       = $000C =    12          MS-Basic.asm:114
OMERR    = $23A2 =  9122          MS-Basic.asm:578
ON       = $2A0D = 10765          MS-Basic.asm:1528
ONGO     = $2A1C = 10780          MS-Basic.asm:1536
ONGOLP   = $2A1D = 10781          MS-Basic.asm:1537
ONJMP    = $27ED = 10221          MS-Basic.asm:1208
OPNPAR   = $2C80 = 11392          MS-Basic.asm:1844
OPRND    = $2CFB = 11515          MS-Basic.asm:1917
OS       = $001A =    26          MS-Basic.asm:121
OTKLN    = $25E9 =  9705          MS-Basic.asm:919
OTPORT   = $4097 = 16535          MS-Basic.asm:44
OUTC     = $2686 =  9862          MS-Basic.asm:1003
OUTEXP   = $38B1 = 14513          MS-Basic.asm:3810
OUTIT    = $2667 =  9831          MS-Basic.asm:981
OUTNBS   = $266D =  9837          MS-Basic.asm:984
OUTNCR   = $3C5D = 15453          MS-Basic.asm:4338
OUTSUB   = $4096 = 16534          MS-Basic.asm:43
OUTWRD   = $2709 =  9993          MS-Basic.asm:1079
OV       = $000A =    10          MS-Basic.asm:113
OVERR    = $23BC =  9148          MS-Basic.asm:593
OVTST1   = $3630 = 13872          MS-Basic.asm:3392
OVTST2   = $3635 = 13877          MS-Basic.asm:3395
OVTST3   = $3636 = 13878          MS-Basic.asm:3396
PADD     = $37D5 = 14293          MS-Basic.asm:3679
PAND     = $2DBC = 11708          MS-Basic.asm:2020
PASSA    = $303C = 12348          MS-Basic.asm:2422
PBUFF    = $4179 = 16761          MS-Basic.asm:101
PEEK     = $33E4 = 13284          MS-Basic.asm:3004
PEND     = $284F = 10319          MS-Basic.asm:1277
PHLTFP   = $3692 = 13970          MS-Basic.asm:3455
PLUCDE   = $34B3 = 13491          MS-Basic.asm:3139
PNORM    = $3481 = 13441          MS-Basic.asm:3105
POINT    = $40E1 = 16609          MS-Basic.asm:65
POKE     = $33EB = 13291          MS-Basic.asm:3008
POPAF    = $3180 = 12672          MS-Basic.asm:2615
POPHL    = $32AA = 12970          MS-Basic.asm:2806
POPHRT   = $3595 = 13717          MS-Basic.asm:3286
POPNOK   = $23F7 =  9207          MS-Basic.asm:620
POR      = $2DBB = 11707          MS-Basic.asm:2019
POR1     = $2DDE = 11742          MS-Basic.asm:2043
POS      = $3039 = 12345          MS-Basic.asm:2421
POSINT   = $28AE = 10414          MS-Basic.asm:1333
POUT     = $339C = 13212          MS-Basic.asm:2967
POWER    = $38F6 = 14582          MS-Basic.asm:3849
POWER1   = $3906 = 14598          MS-Basic.asm:3857
POWER2   = $3923 = 14627          MS-Basic.asm:3875
POWERS   = $38D6 = 14550          MS-Basic.asm:3834
PRINT    = $2A4F = 10831          MS-Basic.asm:1561
PRITAB   = $229F =  8863          MS-Basic.asm:424
PRNTCRLF = $2AAD = 10925          MS-Basic.asm:1607
PRNTHL   = $37EE = 14318          MS-Basic.asm:3697
PRNTLP   = $2A52 = 10834          MS-Basic.asm:1562
PRNTNB   = $2A95 = 10901          MS-Basic.asm:1594
PRNTOK   = $23F8 =  9208          MS-Basic.asm:622
PRNTST   = $2A99 = 10905          MS-Basic.asm:1596
PRNUMS   = $314A = 12618          MS-Basic.asm:2584
PROCES   = $2614 =  9748          MS-Basic.asm:939
PROGND   = $4166 = 16742          MS-Basic.asm:92
PROGST   = $4189 = 16777          MS-Basic.asm:103
PROMPT   = $24FC =  9468          MS-Basic.asm:783
PRS      = $314B = 12619          MS-Basic.asm:2585
PRS1     = $314E = 12622          MS-Basic.asm:2586
PRSLP    = $3155 = 12629          MS-Basic.asm:2589
PSET     = $40E4 = 16612          MS-Basic.asm:66
PSUB     = $3409 = 13321          MS-Basic.asm:3024
PTRLP    = $2481 =  9345          MS-Basic.asm:700
PUTBUF   = $2653 =  9811          MS-Basic.asm:970
PUTCTL   = $2658 =  9816          MS-Basic.asm:972
PUTFID   = $27C1 = 10177          MS-Basic.asm:1181
QTSTLP   = $3110 = 12560          MS-Basic.asm:2554
QTSTR    = $310A = 12554          MS-Basic.asm:2550
QUARTR   = $3A8F = 14991          MS-Basic.asm:4052
READ     = $2B5D = 11101          MS-Basic.asm:1691
READFG   = $415D = 16733          MS-Basic.asm:87
REDO     = $2B0A = 11018          MS-Basic.asm:1656
REM      = $299E = 10654          MS-Basic.asm:1465
RESDIV   = $35E2 = 13794          MS-Basic.asm:3337
RESEED   = $3A2D = 14893          MS-Basic.asm:4008
RESET    = $40E7 = 16615          MS-Basic.asm:67
RESTNL   = $282A = 10282          MS-Basic.asm:1247
RESTOR   = $2815 = 10261          MS-Basic.asm:1236
RESZER   = $3474 = 13428          MS-Basic.asm:3093
RETADR   = $2F17 = 12055          MS-Basic.asm:2232
RETINT   = $366B = 13931          MS-Basic.asm:3428
RETLIN   = $2996 = 10646          MS-Basic.asm:1459
RETNAD   = $258D =  9613          MS-Basic.asm:864
RETNUL   = $2F1A = 12058          MS-Basic.asm:2236
RETNUM   = $2D5D = 11613          MS-Basic.asm:1958
RETREL   = $365D = 13917          MS-Basic.asm:3418
RETURN   = $2977 = 10615          MS-Basic.asm:1443
RG       = $0004 =     4          MS-Basic.asm:110
RIGHT    = $331D = 13085          MS-Basic.asm:2884
RIGHT1   = $32F1 = 13041          MS-Basic.asm:2853
RINPUT   = $40DE = 16606          MS-Basic.asm:64
RLTLP    = $2CA0 = 11424          MS-Basic.asm:1860
RND      = $39CC = 14796          MS-Basic.asm:3955
RND1     = $3A08 = 14856          MS-Basic.asm:3986
RND2     = $3A24 = 14884          MS-Basic.asm:4004
RNDTAB   = $3A35 = 14901          MS-Basic.asm:4015
RNGTST   = $38C3 = 14531          MS-Basic.asm:3824
RONDB    = $3495 = 13461          MS-Basic.asm:3117
RONDUP   = $3494 = 13460          MS-Basic.asm:3116
ROUND    = $33FC = 13308          MS-Basic.asm:3018
RSCALE   = $37CF = 14287          MS-Basic.asm:3677
RSLNBK   = $2743 = 10051          MS-Basic.asm:1111
RSTSTR   = $3340 = 13120          MS-Basic.asm:2904
RUN      = $293C = 10556          MS-Basic.asm:1410
RUNCNT   = $27C5 = 10181          MS-Basic.asm:1185
RUNFST   = $24C5 =  9413          MS-Basic.asm:755
RUNLIN   = $2958 = 10584          MS-Basic.asm:1426
SAVEXP   = $3475 = 13429          MS-Basic.asm:3094
SAVSTP   = $27B8 = 10168          MS-Basic.asm:1174
SAVSTR   = $30E5 = 12517          MS-Basic.asm:2521
SBSCPT   = $2F25 = 12069          MS-Basic.asm:2242
SCALE    = $34D3 = 13523          MS-Basic.asm:3171
SCALLP   = $34D5 = 13525          MS-Basic.asm:3172
SCALMI   = $379A = 14234          MS-Basic.asm:3639
SCALPL   = $37B0 = 14256          MS-Basic.asm:3653
SCNEND   = $321C = 12828          MS-Basic.asm:2711
SCPTLP   = $2F2B = 12075          MS-Basic.asm:2246
SEARCH   = $2555 =  9557          MS-Basic.asm:826
SEED     = $40A7 = 16551          MS-Basic.asm:50
SETIO    = $33C0 = 13248          MS-Basic.asm:2986
SETLIN   = $2717 = 10007          MS-Basic.asm:1087
SETLIT   = $259F =  9631          MS-Basic.asm:876
SETPTR   = $247C =  9340          MS-Basic.asm:697
SETTOP   = $206C =  8300          MS-Basic.asm:192
SFTPRG   = $2446 =  9286          MS-Basic.asm:660
SGN      = $3663 = 13923          MS-Basic.asm:3425
SGNEXP   = $2DAB = 11691          MS-Basic.asm:2006
SGNRES   = $4178 = 16760          MS-Basic.asm:100
SHRITE   = $34E2 = 13538          MS-Basic.asm:3180
SHRLP    = $34E5 = 13541          MS-Basic.asm:3182
SHRT1    = $34E9 = 13545          MS-Basic.asm:3186
SIGNON   = $20BC =  8380          MS-Basic.asm:225
SIGNS    = $36BA = 14010          MS-Basic.asm:3485
SIN      = $3A47 = 14919          MS-Basic.asm:4021
SIN1     = $3A77 = 14967          MS-Basic.asm:4041
SINTAB   = $3A93 = 14995          MS-Basic.asm:4054
SIXDIG   = $3816 = 14358          MS-Basic.asm:3717
SMPVAR   = $31B0 = 12720          MS-Basic.asm:2639
SMSER1   = $39AB = 14763          MS-Basic.asm:3933
SN       = $0002 =     2          MS-Basic.asm:109
SNERR    = $23AD =  9133          MS-Basic.asm:583
SPCFST   = $3807 = 14343          MS-Basic.asm:3709
SPCLP    = $2AFC = 11004          MS-Basic.asm:1649
SQR      = $38ED = 14573          MS-Basic.asm:3845
SRCHLN   = $2499 =  9369          MS-Basic.asm:719
SRCHLP   = $249C =  9372          MS-Basic.asm:720
SSTSA    = $3278 = 12920          MS-Basic.asm:2771
ST       = $001E =    30          MS-Basic.asm:123
STACK    = $40F6 = 16630          MS-Basic.asm:72
STAKFP   = $3685 = 13957          MS-Basic.asm:3445
STALL    = $283E = 10302          MS-Basic.asm:1264
STARTB   = $2006 =  8198          MS-Basic.asm:134
STKTHS   = $2CE4 = 11492          MS-Basic.asm:1901
STLOOK   = $41ED = 16877          MS-Basic.asm:104
STOP     = $284D = 10317          MS-Basic.asm:1275
STORED   = $2919 = 10521          MS-Basic.asm:1390
STPOOL   = $31F3 = 12787          MS-Basic.asm:2676
STR      = $30D5 = 12501          MS-Basic.asm:2514
STR1     = $30DB = 12507          MS-Basic.asm:2516
STRADD   = $31F6 = 12790          MS-Basic.asm:2678
STRBOT   = $4153 = 16723          MS-Basic.asm:81
STRENT   = $2BB4 = 11188          MS-Basic.asm:1738
STRSPC   = $40EA = 16618          MS-Basic.asm:68
STTLIN   = $2AA0 = 10912          MS-Basic.asm:1600
SUBCDE   = $340B = 13323          MS-Basic.asm:3026
SUBPHL   = $3405 = 13317          MS-Basic.asm:3022
SUMLP    = $39B4 = 14772          MS-Basic.asm:3938
SUMSER   = $399C = 14748          MS-Basic.asm:3926
SUPTLZ   = $3895 = 14485          MS-Basic.asm:3794
SVNAM2   = $2E84 = 11908          MS-Basic.asm:2151
SVSTAD   = $3103 = 12547          MS-Basic.asm:2542
TAN      = $3AA8 = 15016          MS-Basic.asm:4061
TESTOS   = $3182 = 12674          MS-Basic.asm:2618
TESTR    = $3164 = 12644          MS-Basic.asm:2598
TM       = $0018 =    24          MS-Basic.asm:120
TMERR    = $23BF =  9151          MS-Basic.asm:595
TMPSTR   = $414F = 16719          MS-Basic.asm:80
TMSTPL   = $4143 = 16707          MS-Basic.asm:79
TMSTPT   = $4141 = 16705          MS-Basic.asm:78
TOPOOL   = $32E9 = 13033          MS-Basic.asm:2848
TOSTRA   = $3281 = 12929          MS-Basic.asm:2780
TRYAGN   = $3870 = 14448          MS-Basic.asm:3767
TSALP    = $3282 = 12930          MS-Basic.asm:2781
TSTBIT   = $3C56 = 15446          MS-Basic.asm:4331 (unused)
TSTBRK   = $2830 = 10288          MS-Basic.asm:1253
TSTMEM   = $205A =  8282          MS-Basic.asm:180
TSTNUM   = $2C75 = 11381          MS-Basic.asm:1836
TSTOPL   = $312B = 12587          MS-Basic.asm:2570
TSTRED   = $2DE3 = 11747          MS-Basic.asm:2049
TSTREM   = $25A2 =  9634          MS-Basic.asm:877
TSTSGN   = $3654 = 13908          MS-Basic.asm:3413
TSTSTR   = $2C76 = 11382          MS-Basic.asm:1837
TTYLIN   = $25F2 =  9714          MS-Basic.asm:924
TYPE     = $413D = 16701          MS-Basic.asm:75
UF       = $0022 =    34          MS-Basic.asm:125
UFERR    = $23B9 =  9145          MS-Basic.asm:591
UL       = $000E =    14          MS-Basic.asm:115
ULERR    = $2972 = 10610          MS-Basic.asm:1440
UNITY    = $34F7 = 13559          MS-Basic.asm:3199
UPDATA   = $282B = 10283          MS-Basic.asm:1248
USR      = $4093 = 16531          MS-Basic.asm:42
VAL      = $3357 = 13143          MS-Basic.asm:2923
VAL1     = $3375 = 13173          MS-Basic.asm:2943
VAL2     = $337F = 13183          MS-Basic.asm:2947
VAL3     = $3382 = 13186          MS-Basic.asm:2948
VAREND   = $4168 = 16744          MS-Basic.asm:93
WAIT     = $33A2 = 13218          MS-Basic.asm:2970
WAITLP   = $33B7 = 13239          MS-Basic.asm:2980
WARM     = $2003 =  8195          MS-Basic.asm:133 (unused)
WARMST   = $20A4 =  8356          MS-Basic.asm:219
WIDTH    = $3B11 = 15121          MS-Basic.asm:4109
WORDS    = $2136 =  8502          MS-Basic.asm:264
WORDTB   = $2255 =  8789          MS-Basic.asm:353
WRKSPC   = $4090 = 16528          MS-Basic.asm:41
ZDATA    = $0083 =   131          MS-Basic.asm:395
ZDIV     = $00AF =   175          MS-Basic.asm:413 (unused)
ZEND     = $0080 =   128          MS-Basic.asm:393
ZEQUAL   = $00B4 =   180          MS-Basic.asm:416
ZERARY   = $2FC6 = 12230          MS-Basic.asm:2345
ZERBYT   = $2349 =  9033          MS-Basic.asm:520
ZEROLP   = $2F09 = 12041          MS-Basic.asm:2223
ZEROSUP  = $3BE9 = 15337          MS-Basic.asm:4250
ZFN      = $00A7 =   167          MS-Basic.asm:404
ZFOR     = $0081 =   129          MS-Basic.asm:394
ZGOSUB   = $008C =   140          MS-Basic.asm:397
ZGOTO    = $0088 =   136          MS-Basic.asm:396
ZGTR     = $00B3 =   179          MS-Basic.asm:415
ZLEFT    = $00CF =   207          MS-Basic.asm:420
ZLTH     = $00B5 =   181          MS-Basic.asm:417
ZMINUS   = $00AD =   173          MS-Basic.asm:411
ZNEW     = $00A4 =   164          MS-Basic.asm:400
ZNOT     = $00AA =   170          MS-Basic.asm:407
ZONELP   = $2AD7 = 10967          MS-Basic.asm:1628
ZOR      = $00B2 =   178          MS-Basic.asm:414
ZPLUS    = $00AC =   172          MS-Basic.asm:410
ZPOINT   = $00C7 =   199          MS-Basic.asm:419 (unused)
ZPRINT   = $009E =   158          MS-Basic.asm:399
ZREM     = $008E =   142          MS-Basic.asm:398
ZSGN     = $00B6 =   182          MS-Basic.asm:418
ZSPC     = $00A8 =   168          MS-Basic.asm:405
ZSTEP    = $00AB =   171          MS-Basic.asm:408
ZTAB     = $00A5 =   165          MS-Basic.asm:402
ZTHEN    = $00A9 =   169          MS-Basic.asm:406
ZTIMES   = $00AE =   174          MS-Basic.asm:412 (unused)
ZTO      = $00A6 =   166          MS-Basic.asm:403
_end     = $3C63 = 15459          MS-Basic.asm:129 (unused)
_size    = $1C63 =  7267          MS-Basic.asm:129 (unused)


total time: 0.0950 sec.
1 error
