              	; --------------------------------------
              	; zasm: assemble "CPM22.asm"
              	; opts: --8080
              	; date: 2018-05-18 20:49:25
              	; --------------------------------------


              	#!/usr/local/bin/zasm --8080 -o original/
              	;**************************************************************
              	;*
              	;*             C P / M   version   2 . 2
              	;*
              	;*   Reconstructed from memory image on February 27, 1981
              	;*
              	;*                by Clark A. Calkins
              	;*
              	;**************************************************************
              	;
              	;   Set memory limit here. This is the amount of contigeous
              	; ram starting from 0000. CP/M will reside at the end of this space.
              	;
002B:         	MEM	EQU	43		;for a 43k system (TS802 TEST - WORKS OK).
              	;
0003:         	IOBYTE	EQU	3		;i/o definition byte.
0004:         	TDRIVE	EQU	4		;current drive name and user number.
0005:         	ENTRY	EQU	5		;entry point for the cp/m bdos.
005C:         	TFCB	EQU	5CH		;default file control block.
0080:         	TBUFF	EQU	80H		;i/o buffer and command line storage.
0100:         	TBASE	EQU	100H		;transiant program storage area.
              	;
              	;   Set control character equates.
              	;
0003:         	CNTRLC	EQU	3		;control-c
0005:         	CNTRLE	EQU	05H		;control-e
0008:         	BS	EQU	08H		;backspace
0009:         	TAB	EQU	09H		;tab
000A:         	LF	EQU	0AH		;line feed
000C:         	FF	EQU	0CH		;form feed
000D:         	CR	EQU	0DH		;carriage return
0010:         	CNTRLP	EQU	10H		;control-p
0012:         	CNTRLR	EQU	12H		;control-r
0013:         	CNTRLS	EQU	13H		;control-s
0015:         	CNTRLU	EQU	15H		;control-u
0018:         	CNTRLX	EQU	18H		;control-x
001A:         	CNTRLZ	EQU	1AH		;control-z (end-of-file mark)
007F:         	DEL	EQU	7FH		;rubout
              	;
              	;   Set origin for CP/M
              	;
9000:         		ORG	(MEM-7)*1024
              	;
9000: C35C93  	CBASE:	JP	COMMAND		;execute command processor (ccp).
9003: C35893  		JP	CLEARBUF	;entry to empty input buffer before starting ccp.
              	
              	;
              	;   Standard cp/m ccp input buffer. Format is (max length),
              	; (actual length), (char #1), (char #2), (char #3), etc.
              	;
9006: 7F      	INBUFF:	DEFB	127		;length of input buffer.
9007: 00      		DEFB	0		;current length of contents.
9008: 436F7079		DEFB	'Copyright'
900C: 72696768	
9010: 74      	
9011: 20313937		DEFB	' 1979 (c) by Digital Research      '
9015: 39202863	
9019: 29206279	
901D: 20446967	
9021: 6974616C	
9025: 20526573	
9029: 65617263	
902D: 68202020	
9031: 202020  	
9034: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9038: 00...   	
904B: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
904F: 00...   	
9062: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9066: 00...   	
9079: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
907D: 00...   	
9088: 0890    	INPOINT:DEFW	INBUFF+2	;input line pointer
908A: 0000    	NAMEPNT:DEFW	0		;input line pointer used for error message. Points to
              	;			;start of name in error.
              	;
              	;   Routine to print (A) on the console. All registers used.
              	;
908C: 5F      	PRINT:	LD	E,A		;setup bdos call.
908D: 0E02    		LD	C,2
908F: C30500  		JP	ENTRY
              	;
              	;   Routine to print (A) on the console and to save (BC).
              	;
9092: C5      	PRINTB:	PUSH	BC
9093: CD8C90  		CALL	PRINT
9096: C1      		POP	BC
9097: C9      		RET	
              	;
              	;   Routine to send a carriage return, line feed combination
              	; to the console.
              	;
9098: 3E0D    	CRLF:	LD	A,CR
909A: CD9290  		CALL	PRINTB
909D: 3E0A    		LD	A,LF
909F: C39290  		JP	PRINTB
              	;
              	;   Routine to send one space to the console and save (BC).
              	;
90A2: 3E20    	SPACE:	LD	A,' '
90A4: C39290  		JP	PRINTB
              	;
              	;   Routine to print character string pointed to be (BC) on the
              	; console. It must terminate with a null byte.
              	;
90A7: C5      	PLINE:	PUSH	BC
90A8: CD9890  		CALL	CRLF
90AB: E1      		POP	HL
90AC: 7E      	PLINE2:	LD	A,(HL)
90AD: B7      		OR	A
90AE: C8      		RET	Z
90AF: 23      		INC	HL
90B0: E5      		PUSH	HL
90B1: CD8C90  		CALL	PRINT
90B4: E1      		POP	HL
90B5: C3AC90  		JP	PLINE2
              	;
              	;   Routine to reset the disk system.
              	;
90B8: 0E0D    	RESDSK:	LD	C,13
90BA: C30500  		JP	ENTRY
              	;
              	;   Routine to select disk (A).
              	;
90BD: 5F      	DSKSEL:	LD	E,A
90BE: 0E0E    		LD	C,14
90C0: C30500  		JP	ENTRY
              	;
              	;   Routine to call bdos and save the return code. The zero
              	; flag is set on a return of 0ffh.
              	;
90C3: CD0500  	ENTRY1:	CALL	ENTRY
90C6: 32EE97  		LD	(RTNCODE),A	;save return code.
90C9: 3C      		INC	A		;set zero if 0ffh returned.
90CA: C9      		RET	
              	;
              	;   Routine to open a file. (DE) must point to the FCB.
              	;
90CB: 0E0F    	OPEN:	LD	C,15
90CD: C3C390  		JP	ENTRY1
              	;
              	;   Routine to open file at (FCB).
              	;
90D0: AF      	OPENFCB:XOR	A		;clear the record number byte at fcb+32
90D1: 32ED97  		LD	(FCB+32),A
90D4: 11CD97  		LD	DE,FCB
90D7: C3CB90  		JP	OPEN
              	;
              	;   Routine to close a file. (DE) points to FCB.
              	;
90DA: 0E10    	CLOSE:	LD	C,16
90DC: C3C390  		JP	ENTRY1
              	;
              	;   Routine to search for the first file with ambigueous name
              	; (DE).
              	;
90DF: 0E11    	SRCHFST:LD	C,17
90E1: C3C390  		JP	ENTRY1
              	;
              	;   Search for the next ambigeous file name.
              	;
90E4: 0E12    	SRCHNXT:LD	C,18
90E6: C3C390  		JP	ENTRY1
              	;
              	;   Search for file at (FCB).
              	;
90E9: 11CD97  	SRCHFCB:LD	DE,FCB
90EC: C3DF90  		JP	SRCHFST
              	;
              	;   Routine to delete a file pointed to by (DE).
              	;
90EF: 0E13    	DELETE:	LD	C,19
90F1: C30500  		JP	ENTRY
              	;
              	;   Routine to call the bdos and set the zero flag if a zero
              	; status is returned.
              	;
90F4: CD0500  	ENTRY2:	CALL	ENTRY
90F7: B7      		OR	A		;set zero flag if appropriate.
90F8: C9      		RET	
              	;
              	;   Routine to read the next record from a sequential file.
              	; (DE) points to the FCB.
              	;
90F9: 0E14    	RDREC:	LD	C,20
90FB: C3F490  		JP	ENTRY2
              	;
              	;   Routine to read file at (FCB).
              	;
90FE: 11CD97  	READFCB:LD	DE,FCB
9101: C3F990  		JP	RDREC
              	;
              	;   Routine to write the next record of a sequential file.
              	; (DE) points to the FCB.
              	;
9104: 0E15    	WRTREC:	LD	C,21
9106: C3F490  		JP	ENTRY2
              	;
              	;   Routine to create the file pointed to by (DE).
              	;
9109: 0E16    	CREATE:	LD	C,22
910B: C3C390  		JP	ENTRY1
              	;
              	;   Routine to rename the file pointed to by (DE). Note that
              	; the new name starts at (DE+16).
              	;
910E: 0E17    	RENAM:	LD	C,23
9110: C30500  		JP	ENTRY
              	;
              	;   Get the current user code.
              	;
9113: 1EFF    	GETUSR:	LD	E,0FFH
              	;
              	;   Routne to get or set the current user code.
              	; If (E) is FF then this is a GET, else it is a SET.
              	;
9115: 0E20    	GETSETUC: LD	C,32
9117: C30500  		JP	ENTRY
              	;
              	;   Routine to set the current drive byte at (TDRIVE).
              	;
911A: CD1391  	SETCDRV:CALL	GETUSR		;get user number
911D: 87      		ADD	A,A		;and shift into the upper 4 bits.
911E: 87      		ADD	A,A
911F: 87      		ADD	A,A
9120: 87      		ADD	A,A
9121: 21EF97  		LD	HL,CDRIVE	;now add in the current drive number.
9124: B6      		OR	(HL)
9125: 320400  		LD	(TDRIVE),A	;and save.
9128: C9      		RET	
              	;
              	;   Move currently active drive down to (TDRIVE).
              	;
9129: 3AEF97  	MOVECD:	LD	A,(CDRIVE)
912C: 320400  		LD	(TDRIVE),A
912F: C9      		RET	
              	;
              	;   Routine to convert (A) into upper case ascii. Only letters
              	; are affected.
              	;
9130: FE61    	UPPER:	CP	'a'		;check for letters in the range of 'a' to 'z'.
9132: D8      		RET	C
9133: FE7B    		CP	'{'
9135: D0      		RET	NC
9136: E65F    		AND	5FH		;convert it if found.
9138: C9      		RET	
              	;
              	;   Routine to get a line of input. We must check to see if the
              	; user is in (BATCH) mode. If so, then read the input from file
              	; ($$$.SUB). At the end, reset to console input.
              	;
9139: 3AAB97  	GETINP:	LD	A,(BATCH)	;if =0, then use console input.
913C: B7      		OR	A
913D: CA9691  		JP	Z,GETINP1
              	;
              	;   Use the submit file ($$$.sub) which is prepared by a
              	; SUBMIT run. It must be on drive (A) and it will be deleted
              	; if and error occures (like eof).
              	;
9140: 3AEF97  		LD	A,(CDRIVE)	;select drive 0 if need be.
9143: B7      		OR	A
9144: 3E00    		LD	A,0		;always use drive A for submit.
9146: C4BD90  		CALL	NZ,DSKSEL	;select it if required.
9149: 11AC97  		LD	DE,BATCHFCB
914C: CDCB90  		CALL	OPEN		;look for it.
914F: CA9691  		JP	Z,GETINP1	;if not there, use normal input.
9152: 3ABB97  		LD	A,(BATCHFCB+15)	;get last record number+1.
9155: 3D      		DEC	A
9156: 32CC97  		LD	(BATCHFCB+32),A
9159: 11AC97  		LD	DE,BATCHFCB
915C: CDF990  		CALL	RDREC		;read last record.
915F: C29691  		JP	NZ,GETINP1	;quit on end of file.
              	;
              	;   Move this record into input buffer.
              	;
9162: 110790  		LD	DE,INBUFF+1
9165: 218000  		LD	HL,TBUFF	;data was read into buffer here.
9168: 0680    		LD	B,128		;all 128 characters may be used.
916A: CD4294  		CALL	HL2DE		;(HL) to (DE), (B) bytes.
916D: 21BA97  		LD	HL,BATCHFCB+14
9170: 3600    		LD	(HL),0		;zero out the 's2' byte.
9172: 23      		INC	HL		;and decrement the record count.
9173: 35      		DEC	(HL)
9174: 11AC97  		LD	DE,BATCHFCB	;close the batch file now.
9177: CDDA90  		CALL	CLOSE
917A: CA9691  		JP	Z,GETINP1	;quit on an error.
917D: 3AEF97  		LD	A,(CDRIVE)	;re-select previous drive if need be.
9180: B7      		OR	A
9181: C4BD90  		CALL	NZ,DSKSEL	;don't do needless selects.
              	;
              	;   Print line just read on console.
              	;
9184: 210890  		LD	HL,INBUFF+2
9187: CDAC90  		CALL	PLINE2
918A: CDC291  		CALL	CHKCON		;check console, quit on a key.
918D: CAA791  		JP	Z,GETINP2	;jump if no key is pressed.
              	;
              	;   Terminate the submit job on any keyboard input. Delete this
              	; file such that it is not re-started and jump to normal keyboard
              	; input section.
              	;
9190: CDDD91  		CALL	DELBATCH	;delete the batch file.
9193: C38293  		JP	CMMND1		;and restart command input.
              	;
              	;   Get here for normal keyboard input. Delete the submit file
              	; incase there was one.
              	;
9196: CDDD91  	GETINP1:CALL	DELBATCH	;delete file ($$$.sub).
9199: CD1A91  		CALL	SETCDRV		;reset active disk.
919C: 0E0A    		LD	C,10		;get line from console device.
919E: 110690  		LD	DE,INBUFF
91A1: CD0500  		CALL	ENTRY
91A4: CD2991  		CALL	MOVECD		;reset current drive (again).
              	;
              	;   Convert input line to upper case.
              	;
91A7: 210790  	GETINP2:LD	HL,INBUFF+1
91AA: 46      		LD	B,(HL)		;(B)=character counter.
91AB: 23      	GETINP3:INC	HL
91AC: 78      		LD	A,B		;end of the line?
91AD: B7      		OR	A
91AE: CABA91  		JP	Z,GETINP4
91B1: 7E      		LD	A,(HL)		;convert to upper case.
91B2: CD3091  		CALL	UPPER
91B5: 77      		LD	(HL),A
91B6: 05      		DEC	B		;adjust character count.
91B7: C3AB91  		JP	GETINP3
91BA: 77      	GETINP4:LD	(HL),A		;add trailing null.
91BB: 210890  		LD	HL,INBUFF+2
91BE: 228890  		LD	(INPOINT),HL	;reset input line pointer.
91C1: C9      		RET	
              	;
              	;   Routine to check the console for a key pressed. The zero
              	; flag is set is none, else the character is returned in (A).
              	;
91C2: 0E0B    	CHKCON:	LD	C,11		;check console.
91C4: CD0500  		CALL	ENTRY
91C7: B7      		OR	A
91C8: C8      		RET	Z		;return if nothing.
91C9: 0E01    		LD	C,1		;else get character.
91CB: CD0500  		CALL	ENTRY
91CE: B7      		OR	A		;clear zero flag and return.
91CF: C9      		RET	
              	;
              	;   Routine to get the currently active drive number.
              	;
91D0: 0E19    	GETDSK:	LD	C,25
91D2: C30500  		JP	ENTRY
              	;
              	;   Set the stabdard dma address.
              	;
91D5: 118000  	STDDMA:	LD	DE,TBUFF
              	;
              	;   Routine to set the dma address to (DE).
              	;
91D8: 0E1A    	DMASET:	LD	C,26
91DA: C30500  		JP	ENTRY
              	;
              	;  Delete the batch file created by SUBMIT.
              	;
91DD: 21AB97  	DELBATCH: LD	HL,BATCH	;is batch active?
91E0: 7E      		LD	A,(HL)
91E1: B7      		OR	A
91E2: C8      		RET	Z
91E3: 3600    		LD	(HL),0		;yes, de-activate it.
91E5: AF      		XOR	A
91E6: CDBD90  		CALL	DSKSEL		;select drive 0 for sure.
91E9: 11AC97  		LD	DE,BATCHFCB	;and delete this file.
91EC: CDEF90  		CALL	DELETE
91EF: 3AEF97  		LD	A,(CDRIVE)	;reset current drive.
91F2: C3BD90  		JP	DSKSEL
              	;
              	;   Check to two strings at (PATTRN1) and (PATTRN2). They must be
              	; the same or we halt....
              	;
91F5: 112893  	VERIFY:	LD	DE,PATTRN1	;these are the serial number bytes.
91F8: 210098  		LD	HL,PATTRN2	;ditto, but how could they be different?
91FB: 0606    		LD	B,6		;6 bytes each.
91FD: 1A      	VERIFY1:LD	A,(DE)
91FE: BE      		CP	(HL)
91FF: C2CF93  		JP	NZ,_HALT		;jump to halt routine.
9202: 13      		INC	DE
9203: 23      		INC	HL
9204: 05      		DEC	B
9205: C2FD91  		JP	NZ,VERIFY1
9208: C9      		RET	
              	;
              	;   Print back file name with a '?' to indicate a syntax error.
              	;
9209: CD9890  	SYNERR:	CALL	CRLF		;end current line.
920C: 2A8A90  		LD	HL,(NAMEPNT)	;this points to name in error.
920F: 7E      	SYNERR1:LD	A,(HL)		;print it until a space or null is found.
9210: FE20    		CP	' '
9212: CA2292  		JP	Z,SYNERR2
9215: B7      		OR	A
9216: CA2292  		JP	Z,SYNERR2
9219: E5      		PUSH	HL
921A: CD8C90  		CALL	PRINT
921D: E1      		POP	HL
921E: 23      		INC	HL
921F: C30F92  		JP	SYNERR1
9222: 3E3F    	SYNERR2:LD	A,'?'		;add trailing '?'.
9224: CD8C90  		CALL	PRINT
9227: CD9890  		CALL	CRLF
922A: CDDD91  		CALL	DELBATCH	;delete any batch file.
922D: C38293  		JP	CMMND1		;and restart from console input.
              	;
              	;   Check character at (DE) for legal command input. Note that the
              	; zero flag is set if the character is a delimiter.
              	;
9230: 1A      	CHECK:	LD	A,(DE)
9231: B7      		OR	A
9232: C8      		RET	Z
9233: FE20    		CP	' '		;control characters are not legal here.
9235: DA0992  		JP	C,SYNERR
9238: C8      		RET	Z		;check for valid delimiter.
9239: FE3D    		CP	'='
923B: C8      		RET	Z
923C: FE5F    		CP	'_'
923E: C8      		RET	Z
923F: FE2E    		CP	'.'
9241: C8      		RET	Z
9242: FE3A    		CP	':'
9244: C8      		RET	Z
9245: FE3B    		CP	';'
9247: C8      		RET	Z
9248: FE3C    		CP	'<'
924A: C8      		RET	Z
924B: FE3E    		CP	'>'
924D: C8      		RET	Z
924E: C9      		RET	
              	;
              	;   Get the next non-blank character from (DE).
              	;
924F: 1A      	NONBLANK: LD	A,(DE)
9250: B7      		OR	A		;string ends with a null.
9251: C8      		RET	Z
9252: FE20    		CP	' '
9254: C0      		RET	NZ
9255: 13      		INC	DE
9256: C34F92  		JP	NONBLANK
              	;
              	;   Add (HL)=(HL)+(A)
              	;
9259: 85      	ADDHL:	ADD	A,L
925A: 6F      		LD	L,A
925B: D0      		RET	NC		;take care of any carry.
925C: 24      		INC	H
925D: C9      		RET	
              	;
              	;   Convert the first name in (FCB).
              	;
925E: 3E00    	CONVFST:LD	A,0
              	;
              	;   Format a file name (convert * to '?', etc.). On return,
              	; (A)=0 is an unambigeous name was specified. Enter with (A) equal to
              	; the position within the fcb for the name (either 0 or 16).
              	;
9260: 21CD97  	CONVERT:LD	HL,FCB
9263: CD5992  		CALL	ADDHL
9266: E5      		PUSH	HL
9267: E5      		PUSH	HL
9268: AF      		XOR	A
9269: 32F097  		LD	(CHGDRV),A	;initialize drive change flag.
926C: 2A8890  		LD	HL,(INPOINT)	;set (HL) as pointer into input line.
926F: EB      		EX	DE,HL
9270: CD4F92  		CALL	NONBLANK	;get next non-blank character.
9273: EB      		EX	DE,HL
9274: 228A90  		LD	(NAMEPNT),HL	;save pointer here for any error message.
9277: EB      		EX	DE,HL
9278: E1      		POP	HL
9279: 1A      		LD	A,(DE)		;get first character.
927A: B7      		OR	A
927B: CA8992  		JP	Z,CONVRT1
927E: DE40    		SBC	A,'A'-1		;might be a drive name, convert to binary.
9280: 47      		LD	B,A		;and save.
9281: 13      		INC	DE		;check next character for a ':'.
9282: 1A      		LD	A,(DE)
9283: FE3A    		CP	':'
9285: CA9092  		JP	Z,CONVRT2
9288: 1B      		DEC	DE		;nope, move pointer back to the start of the line.
9289: 3AEF97  	CONVRT1:LD	A,(CDRIVE)
928C: 77      		LD	(HL),A
928D: C39692  		JP	CONVRT3
9290: 78      	CONVRT2:LD	A,B
9291: 32F097  		LD	(CHGDRV),A	;set change in drives flag.
9294: 70      		LD	(HL),B
9295: 13      		INC	DE
              	;
              	;   Convert the basic file name.
              	;
9296: 0608    	CONVRT3:LD	B,08H
9298: CD3092  	CONVRT4:CALL	CHECK
929B: CAB992  		JP	Z,CONVRT8
929E: 23      		INC	HL
929F: FE2A    		CP	'*'		;note that an '*' will fill the remaining
92A1: C2A992  		JP	NZ,CONVRT5	;field with '?'.
92A4: 363F    		LD	(HL),'?'
92A6: C3AB92  		JP	CONVRT6
92A9: 77      	CONVRT5:LD	(HL),A
92AA: 13      		INC	DE
92AB: 05      	CONVRT6:DEC	B
92AC: C29892  		JP	NZ,CONVRT4
92AF: CD3092  	CONVRT7:CALL	CHECK		;get next delimiter.
92B2: CAC092  		JP	Z,GETEXT
92B5: 13      		INC	DE
92B6: C3AF92  		JP	CONVRT7
92B9: 23      	CONVRT8:INC	HL		;blank fill the file name.
92BA: 3620    		LD	(HL),' '
92BC: 05      		DEC	B
92BD: C2B992  		JP	NZ,CONVRT8
              	;
              	;   Get the extension and convert it.
              	;
92C0: 0603    	GETEXT:	LD	B,03H
92C2: FE2E    		CP	'.'
92C4: C2E992  		JP	NZ,GETEXT5
92C7: 13      		INC	DE
92C8: CD3092  	GETEXT1:CALL	CHECK
92CB: CAE992  		JP	Z,GETEXT5
92CE: 23      		INC	HL
92CF: FE2A    		CP	'*'
92D1: C2D992  		JP	NZ,GETEXT2
92D4: 363F    		LD	(HL),'?'
92D6: C3DB92  		JP	GETEXT3
92D9: 77      	GETEXT2:LD	(HL),A
92DA: 13      		INC	DE
92DB: 05      	GETEXT3:DEC	B
92DC: C2C892  		JP	NZ,GETEXT1
92DF: CD3092  	GETEXT4:CALL	CHECK
92E2: CAF092  		JP	Z,GETEXT6
92E5: 13      		INC	DE
92E6: C3DF92  		JP	GETEXT4
92E9: 23      	GETEXT5:INC	HL
92EA: 3620    		LD	(HL),' '
92EC: 05      		DEC	B
92ED: C2E992  		JP	NZ,GETEXT5
92F0: 0603    	GETEXT6:LD	B,3
92F2: 23      	GETEXT7:INC	HL
92F3: 3600    		LD	(HL),0
92F5: 05      		DEC	B
92F6: C2F292  		JP	NZ,GETEXT7
92F9: EB      		EX	DE,HL
92FA: 228890  		LD	(INPOINT),HL	;save input line pointer.
92FD: E1      		POP	HL
              	;
              	;   Check to see if this is an ambigeous file name specification.
              	; Set the (A) register to non zero if it is.
              	;
92FE: 010B00  		LD	BC,11		;set name length.
9301: 23      	GETEXT8:INC	HL
9302: 7E      		LD	A,(HL)
9303: FE3F    		CP	'?'		;any question marks?
9305: C20993  		JP	NZ,GETEXT9
9308: 04      		INC	B		;count them.
9309: 0D      	GETEXT9:DEC	C
930A: C20193  		JP	NZ,GETEXT8
930D: 78      		LD	A,B
930E: B7      		OR	A
930F: C9      		RET	
              	;
              	;   CP/M command table. Note commands can be either 3 or 4 characters long.
              	;
0006:         	NUMCMDS EQU	6		;number of commands
9310: 44495220	CMDTBL:	DEFB	'DIR '
9314: 45524120		DEFB	'ERA '
9318: 54595045		DEFB	'TYPE'
931C: 53415645		DEFB	'SAVE'
9320: 52454E20		DEFB	'REN '
9324: 55534552		DEFB	'USER'
              	;
              	;   The following six bytes must agree with those at (PATTRN2)
              	; or cp/m will HALT. Why?
              	;
9328: 00160000	PATTRN1:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
932C: 0000    	
              	;
              	;   Search the command table for a match with what has just
              	; been entered. If a match is found, then we jump to the
              	; proper section. Else jump to (UNKNOWN).
              	; On return, the (C) register is set to the command number
              	; that matched (or NUMCMDS+1 if no match).
              	;
932E: 211093  	SEARCH:	LD	HL,CMDTBL
9331: 0E00    		LD	C,0
9333: 79      	SEARCH1:LD	A,C
9334: FE06    		CP	NUMCMDS		;this commands exists.
9336: D0      		RET	NC
9337: 11CE97  		LD	DE,FCB+1	;check this one.
933A: 0604    		LD	B,4		;max command length.
933C: 1A      	SEARCH2:LD	A,(DE)
933D: BE      		CP	(HL)
933E: C24F93  		JP	NZ,SEARCH3	;not a match.
9341: 13      		INC	DE
9342: 23      		INC	HL
9343: 05      		DEC	B
9344: C23C93  		JP	NZ,SEARCH2
9347: 1A      		LD	A,(DE)		;allow a 3 character command to match.
9348: FE20    		CP	' '
934A: C25493  		JP	NZ,SEARCH4
934D: 79      		LD	A,C		;set return register for this command.
934E: C9      		RET	
934F: 23      	SEARCH3:INC	HL
9350: 05      		DEC	B
9351: C24F93  		JP	NZ,SEARCH3
9354: 0C      	SEARCH4:INC	C
9355: C33393  		JP	SEARCH1
              	;
              	;   Set the input buffer to empty and then start the command
              	; processor (ccp).
              	;
9358: AF      	CLEARBUF: XOR	A
9359: 320790  		LD	(INBUFF+1),A	;second byte is actual length.
              	;
              	;**************************************************************
              	;*
              	;*
              	;* C C P  -   C o n s o l e   C o m m a n d   P r o c e s s o r
              	;*
              	;**************************************************************
              	;*
935C: 31AB97  	COMMAND:LD	SP,CCPSTACK	;setup stack area.
935F: C5      		PUSH	BC		;note that (C) should be equal to:
9360: 79      		LD	A,C		;(uuuudddd) where 'uuuu' is the user number
9361: 1F      		RRA			;and 'dddd' is the drive number.
9362: 1F      		RRA	
9363: 1F      		RRA	
9364: 1F      		RRA	
9365: E60F    		AND	0FH		;isolate the user number.
9367: 5F      		LD	E,A
9368: CD1591  		CALL	GETSETUC	;and set it.
936B: CDB890  		CALL	RESDSK		;reset the disk system.
936E: 32AB97  		LD	(BATCH),A	;clear batch mode flag.
9371: C1      		POP	BC
9372: 79      		LD	A,C
9373: E60F    		AND	0FH		;isolate the drive number.
9375: 32EF97  		LD	(CDRIVE),A	;and save.
9378: CDBD90  		CALL	DSKSEL		;...and select.
937B: 3A0790  		LD	A,(INBUFF+1)
937E: B7      		OR	A		;anything in input buffer already?
937F: C29893  		JP	NZ,CMMND2	;yes, we just process it.
              	;
              	;   Entry point to get a command line from the console.
              	;
9382: 31AB97  	CMMND1:	LD	SP,CCPSTACK	;set stack straight.
9385: CD9890  		CALL	CRLF		;start a new line on the screen.
9388: CDD091  		CALL	GETDSK		;get current drive.
938B: C661    		ADD	A,'a'
938D: CD8C90  		CALL	PRINT		;print current drive.
9390: 3E3E    		LD	A,'>'
9392: CD8C90  		CALL	PRINT		;and add prompt.
9395: CD3991  		CALL	GETINP		;get line from user.
              	;
              	;   Process command line here.
              	;
9398: 118000  	CMMND2:	LD	DE,TBUFF
939B: CDD891  		CALL	DMASET		;set standard dma address.
939E: CDD091  		CALL	GETDSK
93A1: 32EF97  		LD	(CDRIVE),A	;set current drive.
93A4: CD5E92  		CALL	CONVFST		;convert name typed in.
93A7: C40992  		CALL	NZ,SYNERR	;wild cards are not allowed.
93AA: 3AF097  		LD	A,(CHGDRV)	;if a change in drives was indicated,
93AD: B7      		OR	A		;then treat this as an unknown command
93AE: C2A596  		JP	NZ,UNKNOWN	;which gets executed.
93B1: CD2E93  		CALL	SEARCH		;else search command table for a match.
              	;
              	;   Note that an unknown command returns
              	; with (A) pointing to the last address
              	; in our table which is (UNKNOWN).
              	;
93B4: 21C193  		LD	HL,CMDADR	;now, look thru our address table for command (A).
93B7: 5F      		LD	E,A		;set (DE) to command number.
93B8: 1600    		LD	D,0
93BA: 19      		ADD	HL,DE
93BB: 19      		ADD	HL,DE		;(HL)=(CMDADR)+2*(command number).
93BC: 7E      		LD	A,(HL)		;now pick out this address.
93BD: 23      		INC	HL
93BE: 66      		LD	H,(HL)
93BF: 6F      		LD	L,A
93C0: E9      		JP	(HL)		;now execute it.
              	;
              	;   CP/M command address table.
              	;
93C1: 77941F95	CMDADR:	DEFW	DIRECT,ERASE,TYPE,SAVE
93C5: 5D95AD95	
93C9: 10968E96		DEFW	RENAME,USER,UNKNOWN
93CD: A596    	
              	;
              	;   Halt the system. Reason for this is unknown at present.
              	;
93CF: 21F376  	_HALT:	LD	HL,76F3H	;'DI HLT' instructions.
93D2: 220090  		LD	(CBASE),HL
93D5: 210090  		LD	HL,CBASE
93D8: E9      		JP	(HL)
              	;
              	;   Read error while TYPEing a file.
              	;
93D9: 01DF93  	RDERROR:LD	BC,RDERR
93DC: C3A790  		JP	PLINE
93DF: 52656164	RDERR:	DEFB	'Read error',0
93E3: 20657272	
93E7: 6F7200  	
              	;
              	;   Required file was not located.
              	;
93EA: 01F093  	NONE:	LD	BC,NOFILE
93ED: C3A790  		JP	PLINE
93F0: 4E6F2066	NOFILE:	DEFB	'No file',0
93F4: 696C6500	
              	;
              	;   Decode a command of the form 'A>filename number{ filename}.
              	; Note that a drive specifier is not allowed on the first file
              	; name. On return, the number is in register (A). Any error
              	; causes 'filename?' to be printed and the command is aborted.
              	;
93F8: CD5E92  	DECODE:	CALL	CONVFST		;convert filename.
93FB: 3AF097  		LD	A,(CHGDRV)	;do not allow a drive to be specified.
93FE: B7      		OR	A
93FF: C20992  		JP	NZ,SYNERR
9402: 21CE97  		LD	HL,FCB+1	;convert number now.
9405: 010B00  		LD	BC,11		;(B)=sum register, (C)=max digit count.
9408: 7E      	DECODE1:LD	A,(HL)
9409: FE20    		CP	' '		;a space terminates the numeral.
940B: CA3394  		JP	Z,DECODE3
940E: 23      		INC	HL
940F: D630    		SUB	'0'		;make binary from ascii.
9411: FE0A    		CP	10		;legal digit?
9413: D20992  		JP	NC,SYNERR
9416: 57      		LD	D,A		;yes, save it in (D).
9417: 78      		LD	A,B		;compute (B)=(B)*10 and check for overflow.
9418: E6E0    		AND	0E0H
941A: C20992  		JP	NZ,SYNERR
941D: 78      		LD	A,B
941E: 07      		RLCA	
941F: 07      		RLCA	
9420: 07      		RLCA			;(A)=(B)*8
9421: 80      		ADD	A,B		;.......*9
9422: DA0992  		JP	C,SYNERR
9425: 80      		ADD	A,B		;.......*10
9426: DA0992  		JP	C,SYNERR
9429: 82      		ADD	A,D		;add in new digit now.
942A: DA0992  	DECODE2:JP	C,SYNERR
942D: 47      		LD	B,A		;and save result.
942E: 0D      		DEC	C		;only look at 11 digits.
942F: C20894  		JP	NZ,DECODE1
9432: C9      		RET	
9433: 7E      	DECODE3:LD	A,(HL)		;spaces must follow (why?).
9434: FE20    		CP	' '
9436: C20992  		JP	NZ,SYNERR
9439: 23      		INC	HL
943A: 0D      	DECODE4:DEC	C
943B: C23394  		JP	NZ,DECODE3
943E: 78      		LD	A,B		;set (A)=the numeric value entered.
943F: C9      		RET	
              	;
              	;   Move 3 bytes from (HL) to (DE). Note that there is only
              	; one reference to this at (A2D5h).
              	;
9440: 0603    	MOVE3:	LD	B,3
              	;
              	;   Move (B) bytes from (HL) to (DE).
              	;
9442: 7E      	HL2DE:	LD	A,(HL)
9443: 12      		LD	(DE),A
9444: 23      		INC	HL
9445: 13      		INC	DE
9446: 05      		DEC	B
9447: C24294  		JP	NZ,HL2DE
944A: C9      		RET	
              	;
              	;   Compute (HL)=(TBUFF)+(A)+(C) and get the byte that's here.
              	;
944B: 218000  	EXTRACT:LD	HL,TBUFF
944E: 81      		ADD	A,C
944F: CD5992  		CALL	ADDHL
9452: 7E      		LD	A,(HL)
9453: C9      		RET	
              	;
              	;  Check drive specified. If it means a change, then the new
              	; drive will be selected. In any case, the drive byte of the
              	; fcb will be set to null (means use current drive).
              	;
9454: AF      	DSELECT:XOR	A		;null out first byte of fcb.
9455: 32CD97  		LD	(FCB),A
9458: 3AF097  		LD	A,(CHGDRV)	;a drive change indicated?
945B: B7      		OR	A
945C: C8      		RET	Z
945D: 3D      		DEC	A		;yes, is it the same as the current drive?
945E: 21EF97  		LD	HL,CDRIVE
9461: BE      		CP	(HL)
9462: C8      		RET	Z
9463: C3BD90  		JP	DSKSEL		;no. Select it then.
              	;
              	;   Check the drive selection and reset it to the previous
              	; drive if it was changed for the preceeding command.
              	;
9466: 3AF097  	RESETDR:LD	A,(CHGDRV)	;drive change indicated?
9469: B7      		OR	A
946A: C8      		RET	Z
946B: 3D      		DEC	A		;yes, was it a different drive?
946C: 21EF97  		LD	HL,CDRIVE
946F: BE      		CP	(HL)
9470: C8      		RET	Z
9471: 3AEF97  		LD	A,(CDRIVE)	;yes, re-select our old drive.
9474: C3BD90  		JP	DSKSEL
              	;
              	;**************************************************************
              	;*
              	;*           D I R E C T O R Y   C O M M A N D
              	;*
              	;**************************************************************
              	;
9477: CD5E92  	DIRECT:	CALL	CONVFST		;convert file name.
947A: CD5494  		CALL	DSELECT		;select indicated drive.
947D: 21CE97  		LD	HL,FCB+1	;was any file indicated?
9480: 7E      		LD	A,(HL)
9481: FE20    		CP	' '
9483: C28F94  		JP	NZ,DIRECT2
9486: 060B    		LD	B,11		;no. Fill field with '?' - same as *.*.
9488: 363F    	DIRECT1:LD	(HL),'?'
948A: 23      		INC	HL
948B: 05      		DEC	B
948C: C28894  		JP	NZ,DIRECT1
948F: 1E00    	DIRECT2:LD	E,0		;set initial cursor position.
9491: D5      		PUSH	DE
9492: CDE990  		CALL	SRCHFCB		;get first file name.
9495: CCEA93  		CALL	Z,NONE		;none found at all?
9498: CA1B95  	DIRECT3:JP	Z,DIRECT9	;terminate if no more names.
949B: 3AEE97  		LD	A,(RTNCODE)	;get file's position in segment (0-3).
949E: 0F      		RRCA	
949F: 0F      		RRCA	
94A0: 0F      		RRCA	
94A1: E660    		AND	60H		;(A)=position*32
94A3: 4F      		LD	C,A
94A4: 3E0A    		LD	A,10
94A6: CD4B94  		CALL	EXTRACT		;extract the tenth entry in fcb.
94A9: 17      		RLA			;check system file status bit.
94AA: DA0F95  		JP	C,DIRECT8	;we don't list them.
94AD: D1      		POP	DE
94AE: 7B      		LD	A,E		;bump name count.
94AF: 1C      		INC	E
94B0: D5      		PUSH	DE
94B1: E603    		AND	03H		;at end of line?
94B3: F5      		PUSH	AF
94B4: C2CC94  		JP	NZ,DIRECT4
94B7: CD9890  		CALL	CRLF		;yes, end this line and start another.
94BA: C5      		PUSH	BC
94BB: CDD091  		CALL	GETDSK		;start line with ('A:').
94BE: C1      		POP	BC
94BF: C641    		ADD	A,'A'
94C1: CD9290  		CALL	PRINTB
94C4: 3E3A    		LD	A,':'
94C6: CD9290  		CALL	PRINTB
94C9: C3D494  		JP	DIRECT5
94CC: CDA290  	DIRECT4:CALL	SPACE		;add seperator between file names.
94CF: 3E3A    		LD	A,':'
94D1: CD9290  		CALL	PRINTB
94D4: CDA290  	DIRECT5:CALL	SPACE
94D7: 0601    		LD	B,1		;'extract' each file name character at a time.
94D9: 78      	DIRECT6:LD	A,B
94DA: CD4B94  		CALL	EXTRACT
94DD: E67F    		AND	7FH		;strip bit 7 (status bit).
94DF: FE20    		CP	' '		;are we at the end of the name?
94E1: C2F994  		JP	NZ,DRECT65
94E4: F1      		POP	AF		;yes, don't print spaces at the end of a line.
94E5: F5      		PUSH	AF
94E6: FE03    		CP	3
94E8: C2F794  		JP	NZ,DRECT63
94EB: 3E09    		LD	A,9		;first check for no extension.
94ED: CD4B94  		CALL	EXTRACT
94F0: E67F    		AND	7FH
94F2: FE20    		CP	' '
94F4: CA0E95  		JP	Z,DIRECT7	;don't print spaces.
94F7: 3E20    	DRECT63:LD	A,' '		;else print them.
94F9: CD9290  	DRECT65:CALL	PRINTB
94FC: 04      		INC	B		;bump to next character psoition.
94FD: 78      		LD	A,B
94FE: FE0C    		CP	12		;end of the name?
9500: D20E95  		JP	NC,DIRECT7
9503: FE09    		CP	9		;nope, starting extension?
9505: C2D994  		JP	NZ,DIRECT6
9508: CDA290  		CALL	SPACE		;yes, add seperating space.
950B: C3D994  		JP	DIRECT6
950E: F1      	DIRECT7:POP	AF		;get the next file name.
950F: CDC291  	DIRECT8:CALL	CHKCON		;first check console, quit on anything.
9512: C21B95  		JP	NZ,DIRECT9
9515: CDE490  		CALL	SRCHNXT		;get next name.
9518: C39894  		JP	DIRECT3		;and continue with our list.
951B: D1      	DIRECT9:POP	DE		;restore the stack and return to command level.
951C: C38697  		JP	GETBACK
              	;
              	;**************************************************************
              	;*
              	;*                E R A S E   C O M M A N D
              	;*
              	;**************************************************************
              	;
951F: CD5E92  	ERASE:	CALL	CONVFST		;convert file name.
9522: FE0B    		CP	11		;was '*.*' entered?
9524: C24295  		JP	NZ,ERASE1
9527: 015295  		LD	BC,YESNO	;yes, ask for confirmation.
952A: CDA790  		CALL	PLINE
952D: CD3991  		CALL	GETINP
9530: 210790  		LD	HL,INBUFF+1
9533: 35      		DEC	(HL)		;must be exactly 'y'.
9534: C28293  		JP	NZ,CMMND1
9537: 23      		INC	HL
9538: 7E      		LD	A,(HL)
9539: FE59    		CP	'Y'
953B: C28293  		JP	NZ,CMMND1
953E: 23      		INC	HL
953F: 228890  		LD	(INPOINT),HL	;save input line pointer.
9542: CD5494  	ERASE1:	CALL	DSELECT		;select desired disk.
9545: 11CD97  		LD	DE,FCB
9548: CDEF90  		CALL	DELETE		;delete the file.
954B: 3C      		INC	A
954C: CCEA93  		CALL	Z,NONE		;not there?
954F: C38697  		JP	GETBACK		;return to command level now.
9552: 416C6C20	YESNO:	DEFB	'All (y/n)?',0
9556: 28792F6E	
955A: 293F00  	
              	;
              	;**************************************************************
              	;*
              	;*            T Y P E   C O M M A N D
              	;*
              	;**************************************************************
              	;
955D: CD5E92  	TYPE:	CALL	CONVFST		;convert file name.
9560: C20992  		JP	NZ,SYNERR	;wild cards not allowed.
9563: CD5494  		CALL	DSELECT		;select indicated drive.
9566: CDD090  		CALL	OPENFCB		;open the file.
9569: CAA795  		JP	Z,TYPE5		;not there?
956C: CD9890  		CALL	CRLF		;ok, start a new line on the screen.
956F: 21F197  		LD	HL,NBYTES	;initialize byte counter.
9572: 36FF    		LD	(HL),0FFH	;set to read first sector.
9574: 21F197  	TYPE1:	LD	HL,NBYTES
9577: 7E      	TYPE2:	LD	A,(HL)		;have we written the entire sector?
9578: FE80    		CP	128
957A: DA8795  		JP	C,TYPE3
957D: E5      		PUSH	HL		;yes, read in the next one.
957E: CDFE90  		CALL	READFCB
9581: E1      		POP	HL
9582: C2A095  		JP	NZ,TYPE4	;end or error?
9585: AF      		XOR	A		;ok, clear byte counter.
9586: 77      		LD	(HL),A
9587: 34      	TYPE3:	INC	(HL)		;count this byte.
9588: 218000  		LD	HL,TBUFF	;and get the (A)th one from the buffer (TBUFF).
958B: CD5992  		CALL	ADDHL
958E: 7E      		LD	A,(HL)
958F: FE1A    		CP	CNTRLZ		;end of file mark?
9591: CA8697  		JP	Z,GETBACK
9594: CD8C90  		CALL	PRINT		;no, print it.
9597: CDC291  		CALL	CHKCON		;check console, quit if anything ready.
959A: C28697  		JP	NZ,GETBACK
959D: C37495  		JP	TYPE1
              	;
              	;   Get here on an end of file or read error.
              	;
95A0: 3D      	TYPE4:	DEC	A		;read error?
95A1: CA8697  		JP	Z,GETBACK
95A4: CDD993  		CALL	RDERROR		;yes, print message.
95A7: CD6694  	TYPE5:	CALL	RESETDR		;and reset proper drive
95AA: C30992  		JP	SYNERR		;now print file name with problem.
              	;
              	;**************************************************************
              	;*
              	;*            S A V E   C O M M A N D
              	;*
              	;**************************************************************
              	;
95AD: CDF893  	SAVE:	CALL	DECODE		;get numeric number that follows SAVE.
95B0: F5      		PUSH	AF		;save number of pages to write.
95B1: CD5E92  		CALL	CONVFST		;convert file name.
95B4: C20992  		JP	NZ,SYNERR	;wild cards not allowed.
95B7: CD5494  		CALL	DSELECT		;select specified drive.
95BA: 11CD97  		LD	DE,FCB		;now delete this file.
95BD: D5      		PUSH	DE
95BE: CDEF90  		CALL	DELETE
95C1: D1      		POP	DE
95C2: CD0991  		CALL	CREATE		;and create it again.
95C5: CAFB95  		JP	Z,SAVE3		;can't create?
95C8: AF      		XOR	A		;clear record number byte.
95C9: 32ED97  		LD	(FCB+32),A
95CC: F1      		POP	AF		;convert pages to sectors.
95CD: 6F      		LD	L,A
95CE: 2600    		LD	H,0
95D0: 29      		ADD	HL,HL		;(HL)=number of sectors to write.
95D1: 110001  		LD	DE,TBASE	;and we start from here.
95D4: 7C      	SAVE1:	LD	A,H		;done yet?
95D5: B5      		OR	L
95D6: CAF195  		JP	Z,SAVE2
95D9: 2B      		DEC	HL		;nope, count this and compute the start
95DA: E5      		PUSH	HL		;of the next 128 byte sector.
95DB: 218000  		LD	HL,128
95DE: 19      		ADD	HL,DE
95DF: E5      		PUSH	HL		;save it and set the transfer address.
95E0: CDD891  		CALL	DMASET
95E3: 11CD97  		LD	DE,FCB		;write out this sector now.
95E6: CD0491  		CALL	WRTREC
95E9: D1      		POP	DE		;reset (DE) to the start of the last sector.
95EA: E1      		POP	HL		;restore sector count.
95EB: C2FB95  		JP	NZ,SAVE3	;write error?
95EE: C3D495  		JP	SAVE1
              	;
              	;   Get here after writing all of the file.
              	;
95F1: 11CD97  	SAVE2:	LD	DE,FCB		;now close the file.
95F4: CDDA90  		CALL	CLOSE
95F7: 3C      		INC	A		;did it close ok?
95F8: C20196  		JP	NZ,SAVE4
              	;
              	;   Print out error message (no space).
              	;
95FB: 010796  	SAVE3:	LD	BC,NOSPACE
95FE: CDA790  		CALL	PLINE
9601: CDD591  	SAVE4:	CALL	STDDMA		;reset the standard dma address.
9604: C38697  		JP	GETBACK
9607: 4E6F2073	NOSPACE:DEFB	'No space',0
960B: 70616365	
960F: 00      	
              	;
              	;**************************************************************
              	;*
              	;*           R E N A M E   C O M M A N D
              	;*
              	;**************************************************************
              	;
9610: CD5E92  	RENAME:	CALL	CONVFST		;convert first file name.
9613: C20992  		JP	NZ,SYNERR	;wild cards not allowed.
9616: 3AF097  		LD	A,(CHGDRV)	;remember any change in drives specified.
9619: F5      		PUSH	AF
961A: CD5494  		CALL	DSELECT		;and select this drive.
961D: CDE990  		CALL	SRCHFCB		;is this file present?
9620: C27996  		JP	NZ,RENAME6	;yes, print error message.
9623: 21CD97  		LD	HL,FCB		;yes, move this name into second slot.
9626: 11DD97  		LD	DE,FCB+16
9629: 0610    		LD	B,16
962B: CD4294  		CALL	HL2DE
962E: 2A8890  		LD	HL,(INPOINT)	;get input pointer.
9631: EB      		EX	DE,HL
9632: CD4F92  		CALL	NONBLANK	;get next non blank character.
9635: FE3D    		CP	'='		;only allow an '=' or '_' seperator.
9637: CA3F96  		JP	Z,RENAME1
963A: FE5F    		CP	'_'
963C: C27396  		JP	NZ,RENAME5
963F: EB      	RENAME1:EX	DE,HL
9640: 23      		INC	HL		;ok, skip seperator.
9641: 228890  		LD	(INPOINT),HL	;save input line pointer.
9644: CD5E92  		CALL	CONVFST		;convert this second file name now.
9647: C27396  		JP	NZ,RENAME5	;again, no wild cards.
964A: F1      		POP	AF		;if a drive was specified, then it
964B: 47      		LD	B,A		;must be the same as before.
964C: 21F097  		LD	HL,CHGDRV
964F: 7E      		LD	A,(HL)
9650: B7      		OR	A
9651: CA5996  		JP	Z,RENAME2
9654: B8      		CP	B
9655: 70      		LD	(HL),B
9656: C27396  		JP	NZ,RENAME5	;they were different, error.
9659: 70      	RENAME2:LD	(HL),B		;	reset as per the first file specification.
965A: AF      		XOR	A
965B: 32CD97  		LD	(FCB),A		;clear the drive byte of the fcb.
965E: CDE990  	RENAME3:CALL	SRCHFCB		;and go look for second file.
9661: CA6D96  		JP	Z,RENAME4	;doesn't exist?
9664: 11CD97  		LD	DE,FCB
9667: CD0E91  		CALL	RENAM		;ok, rename the file.
966A: C38697  		JP	GETBACK
              	;
              	;   Process rename errors here.
              	;
966D: CDEA93  	RENAME4:CALL	NONE		;file not there.
9670: C38697  		JP	GETBACK
9673: CD6694  	RENAME5:CALL	RESETDR		;bad command format.
9676: C30992  		JP	SYNERR
9679: 018296  	RENAME6:LD	BC,EXISTS	;destination file already exists.
967C: CDA790  		CALL	PLINE
967F: C38697  		JP	GETBACK
9682: 46696C65	EXISTS:	DEFB	'File exists',0
9686: 20657869	
968A: 73747300	
              	;
              	;**************************************************************
              	;*
              	;*             U S E R   C O M M A N D
              	;*
              	;**************************************************************
              	;
968E: CDF893  	USER:	CALL	DECODE		;get numeric value following command.
9691: FE10    		CP	16		;legal user number?
9693: D20992  		JP	NC,SYNERR
9696: 5F      		LD	E,A		;yes but is there anything else?
9697: 3ACE97  		LD	A,(FCB+1)
969A: FE20    		CP	' '
969C: CA0992  		JP	Z,SYNERR	;yes, that is not allowed.
969F: CD1591  		CALL	GETSETUC	;ok, set user code.
96A2: C38997  		JP	GETBACK1
              	;
              	;**************************************************************
              	;*
              	;*        T R A N S I A N T   P R O G R A M   C O M M A N D
              	;*
              	;**************************************************************
              	;
96A5: CDF591  	UNKNOWN:CALL	VERIFY		;check for valid system (why?).
96A8: 3ACE97  		LD	A,(FCB+1)	;anything to execute?
96AB: FE20    		CP	' '
96AD: C2C496  		JP	NZ,UNKWN1
96B0: 3AF097  		LD	A,(CHGDRV)	;nope, only a drive change?
96B3: B7      		OR	A
96B4: CA8997  		JP	Z,GETBACK1	;neither???
96B7: 3D      		DEC	A
96B8: 32EF97  		LD	(CDRIVE),A	;ok, store new drive.
96BB: CD2991  		CALL	MOVECD		;set (TDRIVE) also.
96BE: CDBD90  		CALL	DSKSEL		;and select this drive.
96C1: C38997  		JP	GETBACK1	;then return.
              	;
              	;   Here a file name was typed. Prepare to execute it.
              	;
96C4: 11D697  	UNKWN1:	LD	DE,FCB+9	;an extension specified?
96C7: 1A      		LD	A,(DE)
96C8: FE20    		CP	' '
96CA: C20992  		JP	NZ,SYNERR	;yes, not allowed.
96CD: D5      	UNKWN2:	PUSH	DE
96CE: CD5494  		CALL	DSELECT		;select specified drive.
96D1: D1      		POP	DE
96D2: 218397  		LD	HL,COMFILE	;set the extension to 'COM'.
96D5: CD4094  		CALL	MOVE3
96D8: CDD090  		CALL	OPENFCB		;and open this file.
96DB: CA6B97  		JP	Z,UNKWN9	;not present?
              	;
              	;   Load in the program.
              	;
96DE: 210001  		LD	HL,TBASE	;store the program starting here.
96E1: E5      	UNKWN3:	PUSH	HL
96E2: EB      		EX	DE,HL
96E3: CDD891  		CALL	DMASET		;set transfer address.
96E6: 11CD97  		LD	DE,FCB		;and read the next record.
96E9: CDF990  		CALL	RDREC
96EC: C20197  		JP	NZ,UNKWN4	;end of file or read error?
96EF: E1      		POP	HL		;nope, bump pointer for next sector.
96F0: 118000  		LD	DE,128
96F3: 19      		ADD	HL,DE
96F4: 110090  		LD	DE,CBASE	;enough room for the whole file?
96F7: 7D      		LD	A,L
96F8: 93      		SUB	E
96F9: 7C      		LD	A,H
96FA: 9A      		SBC	A,D
96FB: D27197  		JP	NC,UNKWN0	;no, it can't fit.
96FE: C3E196  		JP	UNKWN3
              	;
              	;   Get here after finished reading.
              	;
9701: E1      	UNKWN4:	POP	HL
9702: 3D      		DEC	A		;normal end of file?
9703: C27197  		JP	NZ,UNKWN0
9706: CD6694  		CALL	RESETDR		;yes, reset previous drive.
9709: CD5E92  		CALL	CONVFST		;convert the first file name that follows
970C: 21F097  		LD	HL,CHGDRV	;command name.
970F: E5      		PUSH	HL
9710: 7E      		LD	A,(HL)		;set drive code in default fcb.
9711: 32CD97  		LD	(FCB),A
9714: 3E10    		LD	A,16		;put second name 16 bytes later.
9716: CD6092  		CALL	CONVERT		;convert second file name.
9719: E1      		POP	HL
971A: 7E      		LD	A,(HL)		;and set the drive for this second file.
971B: 32DD97  		LD	(FCB+16),A
971E: AF      		XOR	A		;clear record byte in fcb.
971F: 32ED97  		LD	(FCB+32),A
9722: 115C00  		LD	DE,TFCB		;move it into place at(005Ch).
9725: 21CD97  		LD	HL,FCB
9728: 0621    		LD	B,33
972A: CD4294  		CALL	HL2DE
972D: 210890  		LD	HL,INBUFF+2	;now move the remainder of the input
9730: 7E      	UNKWN5:	LD	A,(HL)		;line down to (0080h). Look for a non blank.
9731: B7      		OR	A		;or a null.
9732: CA3E97  		JP	Z,UNKWN6
9735: FE20    		CP	' '
9737: CA3E97  		JP	Z,UNKWN6
973A: 23      		INC	HL
973B: C33097  		JP	UNKWN5
              	;
              	;   Do the line move now. It ends in a null byte.
              	;
973E: 0600    	UNKWN6:	LD	B,0		;keep a character count.
9740: 118100  		LD	DE,TBUFF+1	;data gets put here.
9743: 7E      	UNKWN7:	LD	A,(HL)		;move it now.
9744: 12      		LD	(DE),A
9745: B7      		OR	A
9746: CA4F97  		JP	Z,UNKWN8
9749: 04      		INC	B
974A: 23      		INC	HL
974B: 13      		INC	DE
974C: C34397  		JP	UNKWN7
974F: 78      	UNKWN8:	LD	A,B		;now store the character count.
9750: 328000  		LD	(TBUFF),A
9753: CD9890  		CALL	CRLF		;clean up the screen.
9756: CDD591  		CALL	STDDMA		;set standard transfer address.
9759: CD1A91  		CALL	SETCDRV		;reset current drive.
975C: CD0001  		CALL	TBASE		;and execute the program.
              	;
              	;   Transiant programs return here (or reboot).
              	;
975F: 31AB97  		LD	SP,BATCH	;set stack first off.
9762: CD2991  		CALL	MOVECD		;move current drive into place (TDRIVE).
9765: CDBD90  		CALL	DSKSEL		;and reselect it.
9768: C38293  		JP	CMMND1		;back to comand mode.
              	;
              	;   Get here if some error occured.
              	;
976B: CD6694  	UNKWN9:	CALL	RESETDR		;inproper format.
976E: C30992  		JP	SYNERR
9771: 017A97  	UNKWN0:	LD	BC,BADLOAD	;read error or won't fit.
9774: CDA790  		CALL	PLINE
9777: C38697  		JP	GETBACK
977A: 42616420	BADLOAD:DEFB	'Bad load',0
977E: 6C6F6164	
9782: 00      	
9783: 434F4D  	COMFILE:DEFB	'COM'		;command file extension.
              	;
              	;   Get here to return to command level. We will reset the
              	; previous active drive and then either return to command
              	; level directly or print error message and then return.
              	;
9786: CD6694  	GETBACK:CALL	RESETDR		;reset previous drive.
9789: CD5E92  	GETBACK1: CALL	CONVFST		;convert first name in (FCB).
978C: 3ACE97  		LD	A,(FCB+1)	;if this was just a drive change request,
978F: D620    		SUB	' '		;make sure it was valid.
9791: 21F097  		LD	HL,CHGDRV
9794: B6      		OR	(HL)
9795: C20992  		JP	NZ,SYNERR
9798: C38293  		JP	CMMND1		;ok, return to command level.
              	;
              	;   ccp stack area.
              	;
979B: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
979F: 00...   	
97AB:         	CCPSTACK EQU	$	;end of ccp stack area.
              	;
              	;   Batch (or SUBMIT) processing information storage.
              	;
97AB: 00      	BATCH:	DEFB	0		;batch mode flag (0=not active).
97AC: 00242424	BATCHFCB: DEFB	0,'$$$     SUB',0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
97B0: 20202020	
97B4: 20535542	
97B8: 00000000	
97BC: 00...   	
              	;
              	;   File control block setup by the CCP.
              	;
97CD: 00202020	FCB:	DEFB	0,'           ',0,0,0,0,0,'           ',0,0,0,0,0
97D1: 20202020	
97D5: 20202020	
97D9: 00000000	
97DD: 00202020	
97E1: 20202020	
97E5: 20202020	
97E9: 00000000	
97ED: 00      	
97EE: 00      	RTNCODE:DEFB	0		;status returned from bdos call.
97EF: 00      	CDRIVE:	DEFB	0		;currently active drive.
97F0: 00      	CHGDRV:	DEFB	0		;change in drives flag (0=no change).
97F1: 0000    	NBYTES:	DEFW	0		;byte counter used by TYPE.
              	;
              	;   Room for expansion?
              	;
97F3: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0
97F7: 00...   	
              	;
              	;   Note that the following six bytes must match those at
              	; (PATTRN1) or cp/m will HALT. Why?
              	;
9800: 00160000	PATTRN2:DEFB	0,22,0,0,0,0	;(* serial number bytes *).
9804: 0000    	
              	;
              	;**************************************************************
              	;*
              	;*                    B D O S   E N T R Y
              	;*
              	;**************************************************************
              	;
9806: C31198  	FBASE:	JP	FBASE1
              	;
              	;   Bdos error table.
              	;
9809: 9998    	BADSCTR:DEFW	ERROR1		;bad sector on read or write.
980B: A598    	BADSLCT:DEFW	ERROR2		;bad disk select.
980D: AB98    	RODISK:	DEFW	ERROR3		;disk is read only.
980F: B198    	ROFILE:	DEFW	ERROR4		;file is read only.
              	;
              	;   Entry into bdos. (DE) or (E) are the parameters passed. The
              	; function number desired is in register (C).
              	;
9811: EB      	FBASE1:	EX	DE,HL		;save the (DE) parameters.
9812: 22439B  		LD	(PARAMS),HL
9815: EB      		EX	DE,HL
9816: 7B      		LD	A,E		;and save register (E) in particular.
9817: 32D6A5  		LD	(EPARAM),A
981A: 210000  		LD	HL,0
981D: 22459B  		LD	(STATUS),HL	;clear return status.
9820: 39      		ADD	HL,SP
9821: 220F9B  		LD	(USRSTACK),HL	;save users stack pointer.
9824: 31419B  		LD	SP,STKAREA	;and set our own.
9827: AF      		XOR	A		;clear auto select storage space.
9828: 32E0A5  		LD	(AUTOFLAG),A
982B: 32DEA5  		LD	(AUTO),A
982E: 2174A5  		LD	HL,GOBACK	;set return address.
9831: E5      		PUSH	HL
9832: 79      		LD	A,C		;get function number.
0029:         	NFUNCTS EQU	41		;number of functions in followin table.
9833: FE29    		CP	NFUNCTS		;valid function number?
9835: D0      		RET	NC
9836: 4B      		LD	C,E		;keep single register function here.
9837: 214798  		LD	HL,FUNCTNS	;now look thru the function table.
983A: 5F      		LD	E,A
983B: 1600    		LD	D,0		;(DE)=function number.
983D: 19      		ADD	HL,DE
983E: 19      		ADD	HL,DE		;(HL)=(start of table)+2*(function number).
983F: 5E      		LD	E,(HL)
9840: 23      		INC	HL
9841: 56      		LD	D,(HL)		;now (DE)=address for this function.
9842: 2A439B  		LD	HL,(PARAMS)	;retrieve parameters.
9845: EB      		EX	DE,HL		;now (DE) has the original parameters.
9846: E9      		JP	(HL)		;execute desired function.
              	;
              	;   BDOS function jump table.
              	;
              	;
9847: 03A6C89A	FUNCTNS:DEFW	WBOOT,GETCON,OUTCON,GETRDR,PUNCH,LIST,DIRCIO,GETIOB
984B: 9099CE9A	
984F: 12A60FA6	
9853: D49AED9A	
9857: F39AF89A		DEFW	SETIOB,PRTSTR,RDBUFF,GETCSTS,GETVER,RSTDSK,SETDSK,OPENFIL
985B: E199FE9A	
985F: 7EA483A4	
9863: 45A49CA4	
9867: A5A4ABA4		DEFW	CLOSEFIL,GETFST,GETNXT,DELFILE,READSEQ,WRTSEQ,FCREATE
986B: C8A4D7A4	
986F: E0A4E6A4	
9873: ECA4    	
9875: F5A4FEA4		DEFW	RENFILE,GETLOG,GETCRNT,PUTDMA,GETALOC,WRTPRTD,GETROV,SETATTR
9879: 04A50AA5	
987D: 11A52C9D	
9881: 17A51DA5	
9885: 26A52DA5		DEFW	GETPARM,GETUSER,RDRANDOM,WTRANDOM,FILESIZE,SETRAN,LOGOFF,RTN
9889: 41A547A5	
988D: 4DA50EA4	
9891: 53A5049B	
9895: 049B9BA5		DEFW	RTN,WTSPECL
              	;
              	;   Bdos error message section.
              	;
9899: 21CA98  	ERROR1:	LD	HL,BADSEC	;bad sector message.
989C: CDE598  		CALL	PRTERR		;print it and get a 1 char responce.
989F: FE03    		CP	CNTRLC		;re-boot request (control-c)?
98A1: CA0000  		JP	Z,0		;yes.
98A4: C9      		RET			;no, return to retry i/o function.
              	;
98A5: 21D598  	ERROR2:	LD	HL,BADSEL	;bad drive selected.
98A8: C3B498  		JP	ERROR5
              	;
98AB: 21E198  	ERROR3:	LD	HL,DISKRO	;disk is read only.
98AE: C3B498  		JP	ERROR5
              	;
98B1: 21DC98  	ERROR4:	LD	HL,FILERO	;file is read only.
              	;
98B4: CDE598  	ERROR5:	CALL	PRTERR
98B7: C30000  		JP	0		;always reboot on these errors.
              	;
98BA: 42646F73	BDOSERR:DEFB	'Bdos Err On '
98BE: 20457272	
98C2: 204F6E20	
98C6: 203A2024	BDOSDRV:DEFB	' : $'
98CA: 42616420	BADSEC:	DEFB	'Bad Sector$'
98CE: 53656374	
98D2: 6F7224  	
98D5: 53656C65	BADSEL:	DEFB	'Select$'
98D9: 637424  	
98DC: 46696C65	FILERO:	DEFB	'File '
98E0: 20      	
98E1: 522F4F24	DISKRO:	DEFB	'R/O$'
              	;
              	;   Print bdos error message.
              	;
98E5: E5      	PRTERR:	PUSH	HL		;save second message pointer.
98E6: CDC999  		CALL	OUTCRLF		;send (cr)(lf).
98E9: 3A429B  		LD	A,(ACTIVE)	;get active drive.
98EC: C641    		ADD	A,'A'		;make ascii.
98EE: 32C698  		LD	(BDOSDRV),A	;and put in message.
98F1: 01BA98  		LD	BC,BDOSERR	;and print it.
98F4: CDD399  		CALL	PRTMESG
98F7: C1      		POP	BC		;print second message line now.
98F8: CDD399  		CALL	PRTMESG
              	;
              	;   Get an input character. We will check our 1 character
              	; buffer first. This may be set by the console status routine.
              	;
98FB: 210E9B  	GETCHAR:LD	HL,CHARBUF	;check character buffer.
98FE: 7E      		LD	A,(HL)		;anything present already?
98FF: 3600    		LD	(HL),0		;...either case clear it.
9901: B7      		OR	A
9902: C0      		RET	NZ		;yes, use it.
9903: C309A6  		JP	CONIN		;nope, go get a character responce.
              	;
              	;   Input and echo a character.
              	;
9906: CDFB98  	GETECHO:CALL	GETCHAR		;input a character.
9909: CD1499  		CALL	CHKCHAR		;carriage control?
990C: D8      		RET	C		;no, a regular control char so don't echo.
990D: F5      		PUSH	AF		;ok, save character now.
990E: 4F      		LD	C,A
990F: CD9099  		CALL	OUTCON		;and echo it.
9912: F1      		POP	AF		;get character and return.
9913: C9      		RET	
              	;
              	;   Check character in (A). Set the zero flag on a carriage
              	; control character and the carry flag on any other control
              	; character.
              	;
9914: FE0D    	CHKCHAR:CP	CR		;check for carriage return, line feed, backspace,
9916: C8      		RET	Z		;or a tab.
9917: FE0A    		CP	LF
9919: C8      		RET	Z
991A: FE09    		CP	TAB
991C: C8      		RET	Z
991D: FE08    		CP	BS
991F: C8      		RET	Z
9920: FE20    		CP	' '		;other control char? Set carry flag.
9922: C9      		RET	
              	;
              	;   Check the console during output. Halt on a control-s, then
              	; reboot on a control-c. If anything else is ready, clear the
              	; zero flag and return (the calling routine may want to do
              	; something).
              	;
9923: 3A0E9B  	CKCONSOL: LD	A,(CHARBUF)	;check buffer.
9926: B7      		OR	A		;if anything, just return without checking.
9927: C24599  		JP	NZ,CKCON2
992A: CD06A6  		CALL	CONST		;nothing in buffer. Check console.
992D: E601    		AND	01H		;look at bit 0.
992F: C8      		RET	Z		;return if nothing.
9930: CD09A6  		CALL	CONIN		;ok, get it.
9933: FE13    		CP	CNTRLS		;if not control-s, return with zero cleared.
9935: C24299  		JP	NZ,CKCON1
9938: CD09A6  		CALL	CONIN		;halt processing until another char
993B: FE03    		CP	CNTRLC		;is typed. Control-c?
993D: CA0000  		JP	Z,0		;yes, reboot now.
9940: AF      		XOR	A		;no, just pretend nothing was ever ready.
9941: C9      		RET	
9942: 320E9B  	CKCON1:	LD	(CHARBUF),A	;save character in buffer for later processing.
9945: 3E01    	CKCON2:	LD	A,1		;set (A) to non zero to mean something is ready.
9947: C9      		RET	
              	;
              	;   Output (C) to the screen. If the printer flip-flop flag
              	; is set, we will send character to printer also. The console
              	; will be checked in the process.
              	;
9948: 3A0A9B  	OUTCHAR:LD	A,(OUTFLAG)	;check output flag.
994B: B7      		OR	A		;anything and we won't generate output.
994C: C26299  		JP	NZ,OUTCHR1
994F: C5      		PUSH	BC
9950: CD2399  		CALL	CKCONSOL	;check console (we don't care whats there).
9953: C1      		POP	BC
9954: C5      		PUSH	BC
9955: CD0CA6  		CALL	CONOUT		;output (C) to the screen.
9958: C1      		POP	BC
9959: C5      		PUSH	BC
995A: 3A0D9B  		LD	A,(PRTFLAG)	;check printer flip-flop flag.
995D: B7      		OR	A
995E: C40FA6  		CALL	NZ,LIST		;print it also if non-zero.
9961: C1      		POP	BC
9962: 79      	OUTCHR1:LD	A,C		;update cursors position.
9963: 210C9B  		LD	HL,CURPOS
9966: FE7F    		CP	DEL		;rubouts don't do anything here.
9968: C8      		RET	Z
9969: 34      		INC	(HL)		;bump line pointer.
996A: FE20    		CP	' '		;and return if a normal character.
996C: D0      		RET	NC
996D: 35      		DEC	(HL)		;restore and check for the start of the line.
996E: 7E      		LD	A,(HL)
996F: B7      		OR	A
9970: C8      		RET	Z		;ingnore control characters at the start of the line.
9971: 79      		LD	A,C
9972: FE08    		CP	BS		;is it a backspace?
9974: C27999  		JP	NZ,OUTCHR2
9977: 35      		DEC	(HL)		;yes, backup pointer.
9978: C9      		RET	
9979: FE0A    	OUTCHR2:CP	LF		;is it a line feed?
997B: C0      		RET	NZ		;ignore anything else.
997C: 3600    		LD	(HL),0		;reset pointer to start of line.
997E: C9      		RET	
              	;
              	;   Output (A) to the screen. If it is a control character
              	; (other than carriage control), use ^x format.
              	;
997F: 79      	SHOWIT:	LD	A,C
9980: CD1499  		CALL	CHKCHAR		;check character.
9983: D29099  		JP	NC,OUTCON	;not a control, use normal output.
9986: F5      		PUSH	AF
9987: 0E5E    		LD	C,'^'		;for a control character, preceed it with '^'.
9989: CD4899  		CALL	OUTCHAR
998C: F1      		POP	AF
998D: F640    		OR	'@'		;and then use the letter equivelant.
998F: 4F      		LD	C,A
              	;
              	;   Function to output (C) to the console device and expand tabs
              	; if necessary.
              	;
9990: 79      	OUTCON:	LD	A,C
9991: FE09    		CP	TAB		;is it a tab?
9993: C24899  		JP	NZ,OUTCHAR	;use regular output.
9996: 0E20    	OUTCON1:LD	C,' '		;yes it is, use spaces instead.
9998: CD4899  		CALL	OUTCHAR
999B: 3A0C9B  		LD	A,(CURPOS)	;go until the cursor is at a multiple of 8
              	
999E: E607    		AND	07H		;position.
99A0: C29699  		JP	NZ,OUTCON1
99A3: C9      		RET	
              	;
              	;   Echo a backspace character. Erase the prevoius character
              	; on the screen.
              	;
99A4: CDAC99  	BACKUP:	CALL	BACKUP1		;backup the screen 1 place.
99A7: 0E20    		LD	C,' '		;then blank that character.
99A9: CD0CA6  		CALL	CONOUT
99AC: 0E08    	BACKUP1:LD	C,BS		;then back space once more.
99AE: C30CA6  		JP	CONOUT
              	;
              	;   Signal a deleted line. Print a '#' at the end and start
              	; over.
              	;
99B1: 0E23    	NEWLINE:LD	C,'#'
99B3: CD4899  		CALL	OUTCHAR		;print this.
99B6: CDC999  		CALL	OUTCRLF		;start new line.
99B9: 3A0C9B  	NEWLN1:	LD	A,(CURPOS)	;move the cursor to the starting position.
99BC: 210B9B  		LD	HL,STARTING
99BF: BE      		CP	(HL)
99C0: D0      		RET	NC		;there yet?
99C1: 0E20    		LD	C,' '
99C3: CD4899  		CALL	OUTCHAR		;nope, keep going.
99C6: C3B999  		JP	NEWLN1
              	;
              	;   Output a (cr) (lf) to the console device (screen).
              	;
99C9: 0E0D    	OUTCRLF:LD	C,CR
99CB: CD4899  		CALL	OUTCHAR
99CE: 0E0A    		LD	C,LF
99D0: C34899  		JP	OUTCHAR
              	;
              	;   Print message pointed to by (BC). It will end with a '$'.
              	;
99D3: 0A      	PRTMESG:LD	A,(BC)		;check for terminating character.
99D4: FE24    		CP	'$'
99D6: C8      		RET	Z
99D7: 03      		INC	BC
99D8: C5      		PUSH	BC		;otherwise, bump pointer and print it.
99D9: 4F      		LD	C,A
99DA: CD9099  		CALL	OUTCON
99DD: C1      		POP	BC
99DE: C3D399  		JP	PRTMESG
              	;
              	;   Function to execute a buffered read.
              	;
99E1: 3A0C9B  	RDBUFF:	LD	A,(CURPOS)	;use present location as starting one.
99E4: 320B9B  		LD	(STARTING),A
99E7: 2A439B  		LD	HL,(PARAMS)	;get the maximum buffer space.
99EA: 4E      		LD	C,(HL)
99EB: 23      		INC	HL		;point to first available space.
99EC: E5      		PUSH	HL		;and save.
99ED: 0600    		LD	B,0		;keep a character count.
99EF: C5      	RDBUF1:	PUSH	BC
99F0: E5      		PUSH	HL
99F1: CDFB98  	RDBUF2:	CALL	GETCHAR		;get the next input character.
99F4: E67F    		AND	7FH		;strip bit 7.
99F6: E1      		POP	HL		;reset registers.
99F7: C1      		POP	BC
99F8: FE0D    		CP	CR		;en of the line?
99FA: CAC19A  		JP	Z,RDBUF17
99FD: FE0A    		CP	LF
99FF: CAC19A  		JP	Z,RDBUF17
9A02: FE08    		CP	BS		;how about a backspace?
9A04: C2169A  		JP	NZ,RDBUF3
9A07: 78      		LD	A,B		;yes, but ignore at the beginning of the line.
9A08: B7      		OR	A
9A09: CAEF99  		JP	Z,RDBUF1
9A0C: 05      		DEC	B		;ok, update counter.
9A0D: 3A0C9B  		LD	A,(CURPOS)	;if we backspace to the start of the line,
9A10: 320A9B  		LD	(OUTFLAG),A	;treat as a cancel (control-x).
9A13: C3709A  		JP	RDBUF10
9A16: FE7F    	RDBUF3:	CP	DEL		;user typed a rubout?
9A18: C2269A  		JP	NZ,RDBUF4
9A1B: 78      		LD	A,B		;ignore at the start of the line.
9A1C: B7      		OR	A
9A1D: CAEF99  		JP	Z,RDBUF1
9A20: 7E      		LD	A,(HL)		;ok, echo the prevoius character.
9A21: 05      		DEC	B		;and reset pointers (counters).
9A22: 2B      		DEC	HL
9A23: C3A99A  		JP	RDBUF15
9A26: FE05    	RDBUF4:	CP	CNTRLE		;physical end of line?
9A28: C2379A  		JP	NZ,RDBUF5
9A2B: C5      		PUSH	BC		;yes, do it.
9A2C: E5      		PUSH	HL
9A2D: CDC999  		CALL	OUTCRLF
9A30: AF      		XOR	A		;and update starting position.
9A31: 320B9B  		LD	(STARTING),A
9A34: C3F199  		JP	RDBUF2
9A37: FE10    	RDBUF5:	CP	CNTRLP		;control-p?
9A39: C2489A  		JP	NZ,RDBUF6
9A3C: E5      		PUSH	HL		;yes, flip the print flag filp-flop byte.
9A3D: 210D9B  		LD	HL,PRTFLAG
9A40: 3E01    		LD	A,1		;PRTFLAG=1-PRTFLAG
9A42: 96      		SUB	(HL)
9A43: 77      		LD	(HL),A
9A44: E1      		POP	HL
9A45: C3EF99  		JP	RDBUF1
9A48: FE18    	RDBUF6:	CP	CNTRLX		;control-x (cancel)?
9A4A: C25F9A  		JP	NZ,RDBUF8
9A4D: E1      		POP	HL
9A4E: 3A0B9B  	RDBUF7:	LD	A,(STARTING)	;yes, backup the cursor to here.
9A51: 210C9B  		LD	HL,CURPOS
9A54: BE      		CP	(HL)
9A55: D2E199  		JP	NC,RDBUFF	;done yet?
9A58: 35      		DEC	(HL)		;no, decrement pointer and output back up one space.
9A59: CDA499  		CALL	BACKUP
9A5C: C34E9A  		JP	RDBUF7
9A5F: FE15    	RDBUF8:	CP	CNTRLU		;cntrol-u (cancel line)?
9A61: C26B9A  		JP	NZ,RDBUF9
9A64: CDB199  		CALL	NEWLINE		;start a new line.
9A67: E1      		POP	HL
9A68: C3E199  		JP	RDBUFF
9A6B: FE12    	RDBUF9:	CP	CNTRLR		;control-r?
9A6D: C2A69A  		JP	NZ,RDBUF14
9A70: C5      	RDBUF10:PUSH	BC		;yes, start a new line and retype the old one.
9A71: CDB199  		CALL	NEWLINE
9A74: C1      		POP	BC
9A75: E1      		POP	HL
9A76: E5      		PUSH	HL
9A77: C5      		PUSH	BC
9A78: 78      	RDBUF11:LD	A,B		;done whole line yet?
9A79: B7      		OR	A
9A7A: CA8A9A  		JP	Z,RDBUF12
9A7D: 23      		INC	HL		;nope, get next character.
9A7E: 4E      		LD	C,(HL)
9A7F: 05      		DEC	B		;count it.
9A80: C5      		PUSH	BC
9A81: E5      		PUSH	HL
9A82: CD7F99  		CALL	SHOWIT		;and display it.
9A85: E1      		POP	HL
9A86: C1      		POP	BC
9A87: C3789A  		JP	RDBUF11
9A8A: E5      	RDBUF12:PUSH	HL		;done with line. If we were displaying
9A8B: 3A0A9B  		LD	A,(OUTFLAG)	;then update cursor position.
9A8E: B7      		OR	A
9A8F: CAF199  		JP	Z,RDBUF2
9A92: 210C9B  		LD	HL,CURPOS	;because this line is shorter, we must
9A95: 96      		SUB	(HL)		;back up the cursor (not the screen however)
9A96: 320A9B  		LD	(OUTFLAG),A	;some number of positions.
9A99: CDA499  	RDBUF13:CALL	BACKUP		;note that as long as (OUTFLAG) is non
9A9C: 210A9B  		LD	HL,OUTFLAG	;zero, the screen will not be changed.
9A9F: 35      		DEC	(HL)
9AA0: C2999A  		JP	NZ,RDBUF13
9AA3: C3F199  		JP	RDBUF2		;now just get the next character.
              	;
              	;   Just a normal character, put this in our buffer and echo.
              	;
9AA6: 23      	RDBUF14:INC	HL
9AA7: 77      		LD	(HL),A		;store character.
9AA8: 04      		INC	B		;and count it.
9AA9: C5      	RDBUF15:PUSH	BC
9AAA: E5      		PUSH	HL
9AAB: 4F      		LD	C,A		;echo it now.
9AAC: CD7F99  		CALL	SHOWIT
9AAF: E1      		POP	HL
9AB0: C1      		POP	BC
9AB1: 7E      		LD	A,(HL)		;was it an abort request?
9AB2: FE03    		CP	CNTRLC		;control-c abort?
9AB4: 78      		LD	A,B
9AB5: C2BD9A  		JP	NZ,RDBUF16
9AB8: FE01    		CP	1		;only if at start of line.
9ABA: CA0000  		JP	Z,0
9ABD: B9      	RDBUF16:CP	C		;nope, have we filled the buffer?
9ABE: DAEF99  		JP	C,RDBUF1
9AC1: E1      	RDBUF17:POP	HL		;yes end the line and return.
9AC2: 70      		LD	(HL),B
9AC3: 0E0D    		LD	C,CR
9AC5: C34899  		JP	OUTCHAR		;output (cr) and return.
              	;
              	;   Function to get a character from the console device.
              	;
9AC8: CD0699  	GETCON:	CALL	GETECHO		;get and echo.
9ACB: C3019B  		JP	SETSTAT		;save status and return.
              	;
              	;   Function to get a character from the tape reader device.
              	;
9ACE: CD15A6  	GETRDR:	CALL	READER		;get a character from reader, set status and return.
9AD1: C3019B  		JP	SETSTAT
              	;
              	;  Function to perform direct console i/o. If (C) contains (FF)
              	; then this is an input request. If (C) contains (FE) then
              	; this is a status request. Otherwise we are to output (C).
              	;
9AD4: 79      	DIRCIO:	LD	A,C		;test for (FF).
9AD5: 3C      		INC	A
9AD6: CAE09A  		JP	Z,DIRC1
9AD9: 3C      		INC	A		;test for (FE).
9ADA: CA06A6  		JP	Z,CONST
9ADD: C30CA6  		JP	CONOUT		;just output (C).
9AE0: CD06A6  	DIRC1:	CALL	CONST		;this is an input request.
9AE3: B7      		OR	A
9AE4: CA91A5  		JP	Z,GOBACK1	;not ready? Just return (directly).
9AE7: CD09A6  		CALL	CONIN		;yes, get character.
9AEA: C3019B  		JP	SETSTAT		;set status and return.
              	;
              	;   Function to return the i/o byte.
              	;
9AED: 3A0300  	GETIOB:	LD	A,(IOBYTE)
9AF0: C3019B  		JP	SETSTAT
              	;
              	;   Function to set the i/o byte.
              	;
9AF3: 210300  	SETIOB:	LD	HL,IOBYTE
9AF6: 71      		LD	(HL),C
9AF7: C9      		RET	
              	;
              	;   Function to print the character string pointed to by (DE)
              	; on the console device. The string ends with a '$'.
              	;
9AF8: EB      	PRTSTR:	EX	DE,HL
9AF9: 4D      		LD	C,L
9AFA: 44      		LD	B,H		;now (BC) points to it.
9AFB: C3D399  		JP	PRTMESG
              	;
              	;   Function to interigate the console device.
              	;
9AFE: CD2399  	GETCSTS:CALL	CKCONSOL
              	;
              	;   Get here to set the status and return to the cleanup
              	; section. Then back to the user.
              	;
9B01: 32459B  	SETSTAT:LD	(STATUS),A
9B04: C9      	RTN:	RET	
              	;
              	;   Set the status to 1 (read or write error code).
              	;
9B05: 3E01    	IOERR1:	LD	A,1
9B07: C3019B  		JP	SETSTAT
              	;
9B0A: 00      	OUTFLAG:DEFB	0		;output flag (non zero means no output).
9B0B: 02      	STARTING: DEFB	2		;starting position for cursor.
9B0C: 00      	CURPOS:	DEFB	0		;cursor position (0=start of line).
9B0D: 00      	PRTFLAG:DEFB	0		;printer flag (control-p toggle). List if non zero.
9B0E: 00      	CHARBUF:DEFB	0		;single input character buffer.
              	;
              	;   Stack area for BDOS calls.
              	;
9B0F: 0000    	USRSTACK: DEFW	0		;save users stack pointer here.
              	;
9B11: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9B15: 00...   	
9B29: 00000000		DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
9B2D: 00...   	
9B41:         	STKAREA EQU	$		;end of stack area.
              	;
9B41: 00      	USERNO:	DEFB	0		;current user number.
9B42: 00      	ACTIVE:	DEFB	0		;currently active drive.
9B43: 0000    	PARAMS:	DEFW	0		;save (DE) parameters here on entry.
9B45: 0000    	STATUS:	DEFW	0		;status returned from bdos function.
              	;
              	;   Select error occured, jump to error routine.
              	;
9B47: 210B98  	SLCTERR:LD	HL,BADSLCT
              	;
              	;   Jump to (HL) indirectly.
              	;
9B4A: 5E      	JUMPHL:	LD	E,(HL)
9B4B: 23      		INC	HL
9B4C: 56      		LD	D,(HL)		;now (DE) contain the desired address.
9B4D: EB      		EX	DE,HL
9B4E: E9      		JP	(HL)
              	;
              	;   Block move. (DE) to (HL), (C) bytes total.
              	;
9B4F: 0C      	DE2HL:	INC	C		;is count down to zero?
9B50: 0D      	DE2HL1:	DEC	C
9B51: C8      		RET	Z		;yes, we are done.
9B52: 1A      		LD	A,(DE)		;no, move one more byte.
9B53: 77      		LD	(HL),A
9B54: 13      		INC	DE
9B55: 23      		INC	HL
9B56: C3509B  		JP	DE2HL1		;and repeat.
              	;
              	;   Select the desired drive.
              	;
9B59: 3A429B  	SELECT:	LD	A,(ACTIVE)	;get active disk.
9B5C: 4F      		LD	C,A
9B5D: CD1BA6  		CALL	SELDSK		;select it.
9B60: 7C      		LD	A,H		;valid drive?
9B61: B5      		OR	L		;valid drive?
9B62: C8      		RET	Z		;return if not.
              	;
              	;   Here, the BIOS returned the address of the parameter block
              	; in (HL). We will extract the necessary pointers and save them.
              	;
9B63: 5E      		LD	E,(HL)		;yes, get address of translation table into (DE).
9B64: 23      		INC	HL
9B65: 56      		LD	D,(HL)
9B66: 23      		INC	HL
9B67: 22B3A5  		LD	(SCRATCH1),HL	;save pointers to scratch areas.
9B6A: 23      		INC	HL
9B6B: 23      		INC	HL
9B6C: 22B5A5  		LD	(SCRATCH2),HL	;ditto.
9B6F: 23      		INC	HL
9B70: 23      		INC	HL
9B71: 22B7A5  		LD	(SCRATCH3),HL	;ditto.
9B74: 23      		INC	HL
9B75: 23      		INC	HL
9B76: EB      		EX	DE,HL		;now save the translation table address.
9B77: 22D0A5  		LD	(XLATE),HL
9B7A: 21B9A5  		LD	HL,DIRBUF	;put the next 8 bytes here.
9B7D: 0E08    		LD	C,8		;they consist of the directory buffer
9B7F: CD4F9B  		CALL	DE2HL		;pointer, parameter block pointer,
9B82: 2ABBA5  		LD	HL,(DISKPB)	;check and allocation vectors.
9B85: EB      		EX	DE,HL
9B86: 21C1A5  		LD	HL,SECTORS	;move parameter block into our ram.
9B89: 0E0F    		LD	C,15		;it is 15 bytes long.
9B8B: CD4F9B  		CALL	DE2HL
9B8E: 2AC6A5  		LD	HL,(DSKSIZE)	;check disk size.
9B91: 7C      		LD	A,H		;more than 256 blocks on this?
9B92: 21DDA5  		LD	HL,BIGDISK
9B95: 36FF    		LD	(HL),0FFH	;set to samll.
9B97: B7      		OR	A
9B98: CA9D9B  		JP	Z,SELECT1
9B9B: 3600    		LD	(HL),0		;wrong, set to large.
9B9D: 3EFF    	SELECT1:LD	A,0FFH		;clear the zero flag.
9B9F: B7      		OR	A
9BA0: C9      		RET	
              	;
              	;   Routine to home the disk track head and clear pointers.
              	;
9BA1: CD18A6  	HOMEDRV:CALL	HOME		;home the head.
9BA4: AF      		XOR	A
9BA5: 2AB5A5  		LD	HL,(SCRATCH2)	;set our track pointer also.
9BA8: 77      		LD	(HL),A
9BA9: 23      		INC	HL
9BAA: 77      		LD	(HL),A
9BAB: 2AB7A5  		LD	HL,(SCRATCH3)	;and our sector pointer.
9BAE: 77      		LD	(HL),A
9BAF: 23      		INC	HL
9BB0: 77      		LD	(HL),A
9BB1: C9      		RET	
              	;
              	;   Do the actual disk read and check the error return status.
              	;
9BB2: CD27A6  	DOREAD:	CALL	READ
9BB5: C3BB9B  		JP	IORET
              	;
              	;   Do the actual disk write and handle any bios error.
              	;
9BB8: CD2AA6  	DOWRITE:CALL	WRITE
9BBB: B7      	IORET:	OR	A
9BBC: C8      		RET	Z		;return unless an error occured.
9BBD: 210998  		LD	HL,BADSCTR	;bad read/write on this sector.
9BC0: C34A9B  		JP	JUMPHL
              	;
              	;   Routine to select the track and sector that the desired
              	; block number falls in.
              	;
9BC3: 2AEAA5  	TRKSEC:	LD	HL,(FILEPOS)	;get position of last accessed file
9BC6: 0E02    		LD	C,2		;in directory and compute sector #.
9BC8: CDEA9C  		CALL	SHIFTR		;sector #=file-position/4.
9BCB: 22E5A5  		LD	(BLKNMBR),HL	;save this as the block number of interest.
9BCE: 22ECA5  		LD	(CKSUMTBL),HL	;what's it doing here too?
              	;
              	;   if the sector number has already been set (BLKNMBR), enter
              	; at this point.
              	;
9BD1: 21E5A5  	TRKSEC1:LD	HL,BLKNMBR
9BD4: 4E      		LD	C,(HL)		;move sector number into (BC).
9BD5: 23      		INC	HL
9BD6: 46      		LD	B,(HL)
9BD7: 2AB7A5  		LD	HL,(SCRATCH3)	;get current sector number and
9BDA: 5E      		LD	E,(HL)		;move this into (DE).
9BDB: 23      		INC	HL
9BDC: 56      		LD	D,(HL)
9BDD: 2AB5A5  		LD	HL,(SCRATCH2)	;get current track number.
9BE0: 7E      		LD	A,(HL)		;and this into (HL).
9BE1: 23      		INC	HL
9BE2: 66      		LD	H,(HL)
9BE3: 6F      		LD	L,A
9BE4: 79      	TRKSEC2:LD	A,C		;is desired sector before current one?
9BE5: 93      		SUB	E
9BE6: 78      		LD	A,B
9BE7: 9A      		SBC	A,D
9BE8: D2FA9B  		JP	NC,TRKSEC3
9BEB: E5      		PUSH	HL		;yes, decrement sectors by one track.
9BEC: 2AC1A5  		LD	HL,(SECTORS)	;get sectors per track.
9BEF: 7B      		LD	A,E
9BF0: 95      		SUB	L
9BF1: 5F      		LD	E,A
9BF2: 7A      		LD	A,D
9BF3: 9C      		SBC	A,H
9BF4: 57      		LD	D,A		;now we have backed up one full track.
9BF5: E1      		POP	HL
9BF6: 2B      		DEC	HL		;adjust track counter.
9BF7: C3E49B  		JP	TRKSEC2
9BFA: E5      	TRKSEC3:PUSH	HL		;desired sector is after current one.
9BFB: 2AC1A5  		LD	HL,(SECTORS)	;get sectors per track.
9BFE: 19      		ADD	HL,DE		;bump sector pointer to next track.
9BFF: DA0F9C  		JP	C,TRKSEC4
9C02: 79      		LD	A,C		;is desired sector now before current one?
9C03: 95      		SUB	L
9C04: 78      		LD	A,B
9C05: 9C      		SBC	A,H
9C06: DA0F9C  		JP	C,TRKSEC4
9C09: EB      		EX	DE,HL		;not yes, increment track counter
9C0A: E1      		POP	HL		;and continue until it is.
9C0B: 23      		INC	HL
9C0C: C3FA9B  		JP	TRKSEC3
              	;
              	;   here we have determined the track number that contains the
              	; desired sector.
              	;
9C0F: E1      	TRKSEC4:POP	HL		;get track number (HL).
9C10: C5      		PUSH	BC
9C11: D5      		PUSH	DE
9C12: E5      		PUSH	HL
9C13: EB      		EX	DE,HL
9C14: 2ACEA5  		LD	HL,(OFFSET)	;adjust for first track offset.
9C17: 19      		ADD	HL,DE
9C18: 44      		LD	B,H
9C19: 4D      		LD	C,L
9C1A: CD1EA6  		CALL	SETTRK		;select this track.
9C1D: D1      		POP	DE		;reset current track pointer.
9C1E: 2AB5A5  		LD	HL,(SCRATCH2)
9C21: 73      		LD	(HL),E
9C22: 23      		INC	HL
9C23: 72      		LD	(HL),D
9C24: D1      		POP	DE
9C25: 2AB7A5  		LD	HL,(SCRATCH3)	;reset the first sector on this track.
9C28: 73      		LD	(HL),E
9C29: 23      		INC	HL
9C2A: 72      		LD	(HL),D
9C2B: C1      		POP	BC
9C2C: 79      		LD	A,C		;now subtract the desired one.
9C2D: 93      		SUB	E		;to make it relative (1-# sectors/track).
9C2E: 4F      		LD	C,A
9C2F: 78      		LD	A,B
9C30: 9A      		SBC	A,D
9C31: 47      		LD	B,A
9C32: 2AD0A5  		LD	HL,(XLATE)	;translate this sector according to this table.
9C35: EB      		EX	DE,HL
9C36: CD30A6  		CALL	SECTRN		;let the bios translate it.
9C39: 4D      		LD	C,L
9C3A: 44      		LD	B,H
9C3B: C321A6  		JP	SETSEC		;and select it.
              	;
              	;   Compute block number from record number (SAVNREC) and
              	; extent number (SAVEXT).
              	;
9C3E: 21C3A5  	GETBLOCK: LD	HL,BLKSHFT	;get logical to physical conversion.
9C41: 4E      		LD	C,(HL)		;note that this is base 2 log of ratio.
9C42: 3AE3A5  		LD	A,(SAVNREC)	;get record number.
9C45: B7      	GETBLK1:OR	A		;compute (A)=(A)/2^BLKSHFT.
9C46: 1F      		RRA	
9C47: 0D      		DEC	C
9C48: C2459C  		JP	NZ,GETBLK1
9C4B: 47      		LD	B,A		;save result in (B).
9C4C: 3E08    		LD	A,8
9C4E: 96      		SUB	(HL)
9C4F: 4F      		LD	C,A		;compute (C)=8-BLKSHFT.
9C50: 3AE2A5  		LD	A,(SAVEXT)
9C53: 0D      	GETBLK2:DEC	C		;compute (A)=SAVEXT*2^(8-BLKSHFT).
9C54: CA5C9C  		JP	Z,GETBLK3
9C57: B7      		OR	A
9C58: 17      		RLA	
9C59: C3539C  		JP	GETBLK2
9C5C: 80      	GETBLK3:ADD	A,B
9C5D: C9      		RET	
              	;
              	;   Routine to extract the (BC) block byte from the fcb pointed
              	; to by (PARAMS). If this is a big-disk, then these are 16 bit
              	; block numbers, else they are 8 bit numbers.
              	; Number is returned in (HL).
              	;
9C5E: 2A439B  	EXTBLK:	LD	HL,(PARAMS)	;get fcb address.
9C61: 111000  		LD	DE,16		;block numbers start 16 bytes into fcb.
9C64: 19      		ADD	HL,DE
9C65: 09      		ADD	HL,BC
9C66: 3ADDA5  		LD	A,(BIGDISK)	;are we using a big-disk?
9C69: B7      		OR	A
9C6A: CA719C  		JP	Z,EXTBLK1
9C6D: 6E      		LD	L,(HL)		;no, extract an 8 bit number from the fcb.
9C6E: 2600    		LD	H,0
9C70: C9      		RET	
9C71: 09      	EXTBLK1:ADD	HL,BC		;yes, extract a 16 bit number.
9C72: 5E      		LD	E,(HL)
9C73: 23      		INC	HL
9C74: 56      		LD	D,(HL)
9C75: EB      		EX	DE,HL		;return in (HL).
9C76: C9      		RET	
              	;
              	;   Compute block number.
              	;
9C77: CD3E9C  	COMBLK:	CALL	GETBLOCK
9C7A: 4F      		LD	C,A
9C7B: 0600    		LD	B,0
9C7D: CD5E9C  		CALL	EXTBLK
9C80: 22E5A5  		LD	(BLKNMBR),HL
9C83: C9      		RET	
              	;
              	;   Check for a zero block number (unused).
              	;
9C84: 2AE5A5  	CHKBLK:	LD	HL,(BLKNMBR)
9C87: 7D      		LD	A,L		;is it zero?
9C88: B4      		OR	H
9C89: C9      		RET	
              	;
              	;   Adjust physical block (BLKNMBR) and convert to logical
              	; sector (LOGSECT). This is the starting sector of this block.
              	; The actual sector of interest is then added to this and the
              	; resulting sector number is stored back in (BLKNMBR). This
              	; will still have to be adjusted for the track number.
              	;
9C8A: 3AC3A5  	LOGICAL:LD	A,(BLKSHFT)	;get log2(physical/logical sectors).
9C8D: 2AE5A5  		LD	HL,(BLKNMBR)	;get physical sector desired.
9C90: 29      	LOGICL1:ADD	HL,HL		;compute logical sector number.
9C91: 3D      		DEC	A		;note logical sectors are 128 bytes long.
9C92: C2909C  		JP	NZ,LOGICL1
9C95: 22E7A5  		LD	(LOGSECT),HL	;save logical sector.
9C98: 3AC4A5  		LD	A,(BLKMASK)	;get block mask.
9C9B: 4F      		LD	C,A
9C9C: 3AE3A5  		LD	A,(SAVNREC)	;get next sector to access.
9C9F: A1      		AND	C		;extract the relative position within physical block.
9CA0: B5      		OR	L		;and add it too logical sector.
9CA1: 6F      		LD	L,A
9CA2: 22E5A5  		LD	(BLKNMBR),HL	;and store.
9CA5: C9      		RET	
              	;
              	;   Set (HL) to point to extent byte in fcb.
              	;
9CA6: 2A439B  	SETEXT:	LD	HL,(PARAMS)
9CA9: 110C00  		LD	DE,12		;it is the twelth byte.
9CAC: 19      		ADD	HL,DE
9CAD: C9      		RET	
              	;
              	;   Set (HL) to point to record count byte in fcb and (DE) to
              	; next record number byte.
              	;
9CAE: 2A439B  	SETHLDE:LD	HL,(PARAMS)
9CB1: 110F00  		LD	DE,15		;record count byte (#15).
9CB4: 19      		ADD	HL,DE
9CB5: EB      		EX	DE,HL
9CB6: 211100  		LD	HL,17		;next record number (#32).
9CB9: 19      		ADD	HL,DE
9CBA: C9      		RET	
              	;
              	;   Save current file data from fcb.
              	;
9CBB: CDAE9C  	STRDATA:CALL	SETHLDE
9CBE: 7E      		LD	A,(HL)		;get and store record count byte.
9CBF: 32E3A5  		LD	(SAVNREC),A
9CC2: EB      		EX	DE,HL
9CC3: 7E      		LD	A,(HL)		;get and store next record number byte.
9CC4: 32E1A5  		LD	(SAVNXT),A
9CC7: CDA69C  		CALL	SETEXT		;point to extent byte.
9CCA: 3AC5A5  		LD	A,(EXTMASK)	;get extent mask.
9CCD: A6      		AND	(HL)
9CCE: 32E2A5  		LD	(SAVEXT),A	;and save extent here.
9CD1: C9      		RET	
              	;
              	;   Set the next record to access. If (MODE) is set to 2, then
              	; the last record byte (SAVNREC) has the correct number to access.
              	; For sequential access, (MODE) will be equal to 1.
              	;
9CD2: CDAE9C  	SETNREC:CALL	SETHLDE
9CD5: 3AD5A5  		LD	A,(MODE)	;get sequential flag (=1).
9CD8: FE02    		CP	2		;a 2 indicates that no adder is needed.
9CDA: C2DE9C  		JP	NZ,STNREC1
9CDD: AF      		XOR	A		;clear adder (random access?).
9CDE: 4F      	STNREC1:LD	C,A
9CDF: 3AE3A5  		LD	A,(SAVNREC)	;get last record number.
9CE2: 81      		ADD	A,C		;increment record count.
9CE3: 77      		LD	(HL),A		;and set fcb's next record byte.
9CE4: EB      		EX	DE,HL
9CE5: 3AE1A5  		LD	A,(SAVNXT)	;get next record byte from storage.
9CE8: 77      		LD	(HL),A		;and put this into fcb as number of records used.
9CE9: C9      		RET	
              	;
              	;   Shift (HL) right (C) bits.
              	;
9CEA: 0C      	SHIFTR:	INC	C
9CEB: 0D      	SHIFTR1:DEC	C
9CEC: C8      		RET	Z
9CED: 7C      		LD	A,H
9CEE: B7      		OR	A
9CEF: 1F      		RRA	
9CF0: 67      		LD	H,A
9CF1: 7D      		LD	A,L
9CF2: 1F      		RRA	
9CF3: 6F      		LD	L,A
9CF4: C3EB9C  		JP	SHIFTR1
              	;
              	;   Compute the check-sum for the directory buffer. Return
              	; integer sum in (A).
              	;
9CF7: 0E80    	CHECKSUM: LD	C,128		;length of buffer.
9CF9: 2AB9A5  		LD	HL,(DIRBUF)	;get its location.
9CFC: AF      		XOR	A		;clear summation byte.
9CFD: 86      	CHKSUM1:ADD	A,(HL)		;and compute sum ignoring carries.
9CFE: 23      		INC	HL
9CFF: 0D      		DEC	C
9D00: C2FD9C  		JP	NZ,CHKSUM1
9D03: C9      		RET	
              	;
              	;   Shift (HL) left (C) bits.
              	;
9D04: 0C      	SHIFTL:	INC	C
9D05: 0D      	SHIFTL1:DEC	C
9D06: C8      		RET	Z
9D07: 29      		ADD	HL,HL		;shift left 1 bit.
9D08: C3059D  		JP	SHIFTL1
              	;
              	;   Routine to set a bit in a 16 bit value contained in (BC).
              	; The bit set depends on the current drive selection.
              	;
9D0B: C5      	SETBIT:	PUSH	BC		;save 16 bit word.
9D0C: 3A429B  		LD	A,(ACTIVE)	;get active drive.
9D0F: 4F      		LD	C,A
9D10: 210100  		LD	HL,1
9D13: CD049D  		CALL	SHIFTL		;shift bit 0 into place.
9D16: C1      		POP	BC		;now 'or' this with the original word.
9D17: 79      		LD	A,C
9D18: B5      		OR	L
9D19: 6F      		LD	L,A		;low byte done, do high byte.
9D1A: 78      		LD	A,B
9D1B: B4      		OR	H
9D1C: 67      		LD	H,A
9D1D: C9      		RET	
              	;
              	;   Extract the write protect status bit for the current drive.
              	; The result is returned in (A), bit 0.
              	;
9D1E: 2AADA5  	GETWPRT:LD	HL,(WRTPRT)	;get status bytes.
9D21: 3A429B  		LD	A,(ACTIVE)	;which drive is current?
9D24: 4F      		LD	C,A
9D25: CDEA9C  		CALL	SHIFTR		;shift status such that bit 0 is the
9D28: 7D      		LD	A,L		;one of interest for this drive.
9D29: E601    		AND	01H		;and isolate it.
9D2B: C9      		RET	
              	;
              	;   Function to write protect the current disk.
              	;
9D2C: 21ADA5  	WRTPRTD:LD	HL,WRTPRT	;point to status word.
9D2F: 4E      		LD	C,(HL)		;set (BC) equal to the status.
9D30: 23      		INC	HL
9D31: 46      		LD	B,(HL)
9D32: CD0B9D  		CALL	SETBIT		;and set this bit according to current drive.
9D35: 22ADA5  		LD	(WRTPRT),HL	;then save.
9D38: 2AC8A5  		LD	HL,(DIRSIZE)	;now save directory size limit.
9D3B: 23      		INC	HL		;remember the last one.
9D3C: EB      		EX	DE,HL
9D3D: 2AB3A5  		LD	HL,(SCRATCH1)	;and store it here.
9D40: 73      		LD	(HL),E		;put low byte.
9D41: 23      		INC	HL
9D42: 72      		LD	(HL),D		;then high byte.
9D43: C9      		RET	
              	;
              	;   Check for a read only file.
              	;
9D44: CD5E9D  	CHKROFL:CALL	FCB2HL		;set (HL) to file entry in directory buffer.
9D47: 110900  	CKROF1:	LD	DE,9		;look at bit 7 of the ninth byte.
9D4A: 19      		ADD	HL,DE
9D4B: 7E      		LD	A,(HL)
9D4C: 17      		RLA	
9D4D: D0      		RET	NC		;return if ok.
9D4E: 210F98  		LD	HL,ROFILE	;else, print error message and terminate.
9D51: C34A9B  		JP	JUMPHL
              	;
              	;   Check the write protect status of the active disk.
              	;
9D54: CD1E9D  	CHKWPRT:CALL	GETWPRT
9D57: C8      		RET	Z		;return if ok.
9D58: 210D98  		LD	HL,RODISK	;else print message and terminate.
9D5B: C34A9B  		JP	JUMPHL
              	;
              	;   Routine to set (HL) pointing to the proper entry in the
              	; directory buffer.
              	;
9D5E: 2AB9A5  	FCB2HL:	LD	HL,(DIRBUF)	;get address of buffer.
9D61: 3AE9A5  		LD	A,(FCBPOS)	;relative position of file.
              	;
              	;   Routine to add (A) to (HL).
              	;
9D64: 85      	ADDA2HL:ADD	A,L
9D65: 6F      		LD	L,A
9D66: D0      		RET	NC
9D67: 24      		INC	H		;take care of any carry.
9D68: C9      		RET	
              	;
              	;   Routine to get the 's2' byte from the fcb supplied in
              	; the initial parameter specification.
              	;
9D69: 2A439B  	GETS2:	LD	HL,(PARAMS)	;get address of fcb.
9D6C: 110E00  		LD	DE,14		;relative position of 's2'.
9D6F: 19      		ADD	HL,DE
9D70: 7E      		LD	A,(HL)		;extract this byte.
9D71: C9      		RET	
              	;
              	;   Clear the 's2' byte in the fcb.
              	;
9D72: CD699D  	CLEARS2:CALL	GETS2		;this sets (HL) pointing to it.
9D75: 3600    		LD	(HL),0		;now clear it.
9D77: C9      		RET	
              	;
              	;   Set bit 7 in the 's2' byte of the fcb.
              	;
9D78: CD699D  	SETS2B7:CALL	GETS2		;get the byte.
9D7B: F680    		OR	80H		;and set bit 7.
9D7D: 77      		LD	(HL),A		;then store.
9D7E: C9      		RET	
              	;
              	;   Compare (FILEPOS) with (SCRATCH1) and set flags based on
              	; the difference. This checks to see if there are more file
              	; names in the directory. We are at (FILEPOS) and there are
              	; (SCRATCH1) of them to check.
              	;
9D7F: 2AEAA5  	MOREFLS:LD	HL,(FILEPOS)	;we are here.
9D82: EB      		EX	DE,HL
9D83: 2AB3A5  		LD	HL,(SCRATCH1)	;and don't go past here.
9D86: 7B      		LD	A,E		;compute difference but don't keep.
9D87: 96      		SUB	(HL)
9D88: 23      		INC	HL
9D89: 7A      		LD	A,D
9D8A: 9E      		SBC	A,(HL)		;set carry if no more names.
9D8B: C9      		RET	
              	;
              	;   Call this routine to prevent (SCRATCH1) from being greater
              	; than (FILEPOS).
              	;
9D8C: CD7F9D  	CHKNMBR:CALL	MOREFLS		;SCRATCH1 too big?
9D8F: D8      		RET	C
9D90: 13      		INC	DE		;yes, reset it to (FILEPOS).
9D91: 72      		LD	(HL),D
9D92: 2B      		DEC	HL
9D93: 73      		LD	(HL),E
9D94: C9      		RET	
              	;
              	;   Compute (HL)=(DE)-(HL)
              	;
9D95: 7B      	SUBHL:	LD	A,E		;compute difference.
9D96: 95      		SUB	L
9D97: 6F      		LD	L,A		;store low byte.
9D98: 7A      		LD	A,D
9D99: 9C      		SBC	A,H
9D9A: 67      		LD	H,A		;and then high byte.
9D9B: C9      		RET	
              	;
              	;   Set the directory checksum byte.
              	;
9D9C: 0EFF    	SETDIR:	LD	C,0FFH
              	;
              	;   Routine to set or compare the directory checksum byte. If
              	; (C)=0ffh, then this will set the checksum byte. Else the byte
              	; will be checked. If the check fails (the disk has been changed),
              	; then this disk will be write protected.
              	;
9D9E: 2AECA5  	CHECKDIR: LD	HL,(CKSUMTBL)
9DA1: EB      		EX	DE,HL
9DA2: 2ACCA5  		LD	HL,(ALLOC1)
9DA5: CD959D  		CALL	SUBHL
9DA8: D0      		RET	NC		;ok if (CKSUMTBL) > (ALLOC1), so return.
9DA9: C5      		PUSH	BC
9DAA: CDF79C  		CALL	CHECKSUM	;else compute checksum.
9DAD: 2ABDA5  		LD	HL,(CHKVECT)	;get address of checksum table.
9DB0: EB      		EX	DE,HL
9DB1: 2AECA5  		LD	HL,(CKSUMTBL)
9DB4: 19      		ADD	HL,DE		;set (HL) to point to byte for this drive.
9DB5: C1      		POP	BC
9DB6: 0C      		INC	C		;set or check ?
9DB7: CAC49D  		JP	Z,CHKDIR1
9DBA: BE      		CP	(HL)		;check them.
9DBB: C8      		RET	Z		;return if they are the same.
9DBC: CD7F9D  		CALL	MOREFLS		;not the same, do we care?
9DBF: D0      		RET	NC
9DC0: CD2C9D  		CALL	WRTPRTD		;yes, mark this as write protected.
9DC3: C9      		RET	
9DC4: 77      	CHKDIR1:LD	(HL),A		;just set the byte.
9DC5: C9      		RET	
              	;
              	;   Do a write to the directory of the current disk.
              	;
9DC6: CD9C9D  	DIRWRITE: CALL	SETDIR		;set checksum byte.
9DC9: CDE09D  		CALL	DIRDMA		;set directory dma address.
9DCC: 0E01    		LD	C,1		;tell the bios to actually write.
9DCE: CDB89B  		CALL	DOWRITE		;then do the write.
9DD1: C3DA9D  		JP	DEFDMA
              	;
              	;   Read from the directory.
              	;
9DD4: CDE09D  	DIRREAD:CALL	DIRDMA		;set the directory dma address.
9DD7: CDB29B  		CALL	DOREAD		;and read it.
              	;
              	;   Routine to set the dma address to the users choice.
              	;
9DDA: 21B1A5  	DEFDMA:	LD	HL,USERDMA	;reset the default dma address and return.
9DDD: C3E39D  		JP	DIRDMA1
              	;
              	;   Routine to set the dma address for directory work.
              	;
9DE0: 21B9A5  	DIRDMA:	LD	HL,DIRBUF
              	;
              	;   Set the dma address. On entry, (HL) points to
              	; word containing the desired dma address.
              	;
9DE3: 4E      	DIRDMA1:LD	C,(HL)
9DE4: 23      		INC	HL
9DE5: 46      		LD	B,(HL)		;setup (BC) and go to the bios to set it.
9DE6: C324A6  		JP	SETDMA
              	;
              	;   Move the directory buffer into user's dma space.
              	;
9DE9: 2AB9A5  	MOVEDIR:LD	HL,(DIRBUF)	;buffer is located here, and
9DEC: EB      		EX	DE,HL
9DED: 2AB1A5  		LD	HL,(USERDMA)	; put it here.
9DF0: 0E80    		LD	C,128		;this is its length.
9DF2: C34F9B  		JP	DE2HL		;move it now and return.
              	;
              	;   Check (FILEPOS) and set the zero flag if it equals 0ffffh.
              	;
9DF5: 21EAA5  	CKFILPOS: LD	HL,FILEPOS
9DF8: 7E      		LD	A,(HL)
9DF9: 23      		INC	HL
9DFA: BE      		CP	(HL)		;are both bytes the same?
9DFB: C0      		RET	NZ
9DFC: 3C      		INC	A		;yes, but are they each 0ffh?
9DFD: C9      		RET	
              	;
              	;   Set location (FILEPOS) to 0ffffh.
              	;
9DFE: 21FFFF  	STFILPOS: LD	HL,0FFFFH
9E01: 22EAA5  		LD	(FILEPOS),HL
9E04: C9      		RET	
              	;
              	;   Move on to the next file position within the current
              	; directory buffer. If no more exist, set pointer to 0ffffh
              	; and the calling routine will check for this. Enter with (C)
              	; equal to 0ffh to cause the checksum byte to be set, else we
              	; will check this disk and set write protect if checksums are
              	; not the same (applies only if another directory sector must
              	; be read).
              	;
9E05: 2AC8A5  	NXENTRY:LD	HL,(DIRSIZE)	;get directory entry size limit.
9E08: EB      		EX	DE,HL
9E09: 2AEAA5  		LD	HL,(FILEPOS)	;get current count.
9E0C: 23      		INC	HL		;go on to the next one.
9E0D: 22EAA5  		LD	(FILEPOS),HL
9E10: CD959D  		CALL	SUBHL		;(HL)=(DIRSIZE)-(FILEPOS)
9E13: D2199E  		JP	NC,NXENT1	;is there more room left?
9E16: C3FE9D  		JP	STFILPOS	;no. Set this flag and return.
9E19: 3AEAA5  	NXENT1:	LD	A,(FILEPOS)	;get file position within directory.
9E1C: E603    		AND	03H		;only look within this sector (only 4 entries fit).
9E1E: 0605    		LD	B,5		;convert to relative position (32 bytes each).
9E20: 87      	NXENT2:	ADD	A,A		;note that this is not efficient code.
9E21: 05      		DEC	B		;5 'ADD A's would be better.
9E22: C2209E  		JP	NZ,NXENT2
9E25: 32E9A5  		LD	(FCBPOS),A	;save it as position of fcb.
9E28: B7      		OR	A
9E29: C0      		RET	NZ		;return if we are within buffer.
9E2A: C5      		PUSH	BC
9E2B: CDC39B  		CALL	TRKSEC		;we need the next directory sector.
9E2E: CDD49D  		CALL	DIRREAD
9E31: C1      		POP	BC
9E32: C39E9D  		JP	CHECKDIR
              	;
              	;   Routine to to get a bit from the disk space allocation
              	; map. It is returned in (A), bit position 0. On entry to here,
              	; set (BC) to the block number on the disk to check.
              	; On return, (D) will contain the original bit position for
              	; this block number and (HL) will point to the address for it.
              	;
9E35: 79      	CKBITMAP: LD	A,C		;determine bit number of interest.
9E36: E607    		AND	07H		;compute (D)=(E)=(C and 7)+1.
9E38: 3C      		INC	A
9E39: 5F      		LD	E,A		;save particular bit number.
9E3A: 57      		LD	D,A
              	;
              	;   compute (BC)=(BC)/8.
              	;
9E3B: 79      		LD	A,C
9E3C: 0F      		RRCA			;now shift right 3 bits.
9E3D: 0F      		RRCA	
9E3E: 0F      		RRCA	
9E3F: E61F    		AND	1FH		;and clear bits 7,6,5.
9E41: 4F      		LD	C,A
9E42: 78      		LD	A,B
9E43: 87      		ADD	A,A		;now shift (B) into bits 7,6,5.
9E44: 87      		ADD	A,A
9E45: 87      		ADD	A,A
9E46: 87      		ADD	A,A
9E47: 87      		ADD	A,A
9E48: B1      		OR	C		;and add in (C).
9E49: 4F      		LD	C,A		;ok, (C) ha been completed.
9E4A: 78      		LD	A,B		;is there a better way of doing this?
9E4B: 0F      		RRCA	
9E4C: 0F      		RRCA	
9E4D: 0F      		RRCA	
9E4E: E61F    		AND	1FH
9E50: 47      		LD	B,A		;and now (B) is completed.
              	;
              	;   use this as an offset into the disk space allocation
              	; table.
              	;
9E51: 2ABFA5  		LD	HL,(ALOCVECT)
9E54: 09      		ADD	HL,BC
9E55: 7E      		LD	A,(HL)		;now get correct byte.
9E56: 07      	CKBMAP1:RLCA			;get correct bit into position 0.
9E57: 1D      		DEC	E
9E58: C2569E  		JP	NZ,CKBMAP1
9E5B: C9      		RET	
              	;
              	;   Set or clear the bit map such that block number (BC) will be marked
              	; as used. On entry, if (E)=0 then this bit will be cleared, if it equals
              	; 1 then it will be set (don't use anyother values).
              	;
9E5C: D5      	STBITMAP: PUSH	DE
9E5D: CD359E  		CALL	CKBITMAP	;get the byte of interest.
9E60: E6FE    		AND	0FEH		;clear the affected bit.
9E62: C1      		POP	BC
9E63: B1      		OR	C		;and now set it acording to (C).
              	;
              	;  entry to restore the original bit position and then store
              	; in table. (A) contains the value, (D) contains the bit
              	; position (1-8), and (HL) points to the address within the
              	; space allocation table for this byte.
              	;
9E64: 0F      	STBMAP1:RRCA			;restore original bit position.
9E65: 15      		DEC	D
9E66: C2649E  		JP	NZ,STBMAP1
9E69: 77      		LD	(HL),A		;and stor byte in table.
9E6A: C9      		RET	
              	;
              	;   Set/clear space used bits in allocation map for this file.
              	; On entry, (C)=1 to set the map and (C)=0 to clear it.
              	;
9E6B: CD5E9D  	SETFILE:CALL	FCB2HL		;get address of fcb
9E6E: 111000  		LD	DE,16
9E71: 19      		ADD	HL,DE		;get to block number bytes.
9E72: C5      		PUSH	BC
9E73: 0E11    		LD	C,17		;check all 17 bytes (max) of table.
9E75: D1      	SETFL1:	POP	DE
9E76: 0D      		DEC	C		;done all bytes yet?
9E77: C8      		RET	Z
9E78: D5      		PUSH	DE
9E79: 3ADDA5  		LD	A,(BIGDISK)	;check disk size for 16 bit block numbers.
9E7C: B7      		OR	A
9E7D: CA889E  		JP	Z,SETFL2
9E80: C5      		PUSH	BC		;only 8 bit numbers. set (BC) to this one.
9E81: E5      		PUSH	HL
9E82: 4E      		LD	C,(HL)		;get low byte from table, always
9E83: 0600    		LD	B,0		;set high byte to zero.
9E85: C38E9E  		JP	SETFL3
9E88: 0D      	SETFL2:	DEC	C		;for 16 bit block numbers, adjust counter.
9E89: C5      		PUSH	BC
9E8A: 4E      		LD	C,(HL)		;now get both the low and high bytes.
9E8B: 23      		INC	HL
9E8C: 46      		LD	B,(HL)
9E8D: E5      		PUSH	HL
9E8E: 79      	SETFL3:	LD	A,C		;block used?
9E8F: B0      		OR	B
9E90: CA9D9E  		JP	Z,SETFL4
9E93: 2AC6A5  		LD	HL,(DSKSIZE)	;is this block number within the
9E96: 7D      		LD	A,L		;space on the disk?
9E97: 91      		SUB	C
9E98: 7C      		LD	A,H
9E99: 98      		SBC	A,B
9E9A: D45C9E  		CALL	NC,STBITMAP	;yes, set the proper bit.
9E9D: E1      	SETFL4:	POP	HL		;point to next block number in fcb.
9E9E: 23      		INC	HL
9E9F: C1      		POP	BC
9EA0: C3759E  		JP	SETFL1
              	;
              	;   Construct the space used allocation bit map for the active
              	; drive. If a file name starts with '$' and it is under the
              	; current user number, then (STATUS) is set to minus 1. Otherwise
              	; it is not set at all.
              	;
9EA3: 2AC6A5  	BITMAP:	LD	HL,(DSKSIZE)	;compute size of allocation table.
9EA6: 0E03    		LD	C,3
9EA8: CDEA9C  		CALL	SHIFTR		;(HL)=(HL)/8.
9EAB: 23      		INC	HL		;at lease 1 byte.
9EAC: 44      		LD	B,H
9EAD: 4D      		LD	C,L		;set (BC) to the allocation table length.
              	;
              	;   Initialize the bitmap for this drive. Right now, the first
              	; two bytes are specified by the disk parameter block. However
              	; a patch could be entered here if it were necessary to setup
              	; this table in a special mannor. For example, the bios could
              	; determine locations of 'bad blocks' and set them as already
              	; 'used' in the map.
              	;
9EAE: 2ABFA5  		LD	HL,(ALOCVECT)	;now zero out the table now.
9EB1: 3600    	BITMAP1:LD	(HL),0
9EB3: 23      		INC	HL
9EB4: 0B      		DEC	BC
9EB5: 78      		LD	A,B
9EB6: B1      		OR	C
9EB7: C2B19E  		JP	NZ,BITMAP1
9EBA: 2ACAA5  		LD	HL,(ALLOC0)	;get initial space used by directory.
9EBD: EB      		EX	DE,HL
9EBE: 2ABFA5  		LD	HL,(ALOCVECT)	;and put this into map.
9EC1: 73      		LD	(HL),E
9EC2: 23      		INC	HL
9EC3: 72      		LD	(HL),D
              	;
              	;   End of initialization portion.
              	;
9EC4: CDA19B  		CALL	HOMEDRV		;now home the drive.
9EC7: 2AB3A5  		LD	HL,(SCRATCH1)
9ECA: 3603    		LD	(HL),3		;force next directory request to read
9ECC: 23      		INC	HL		;in a sector.
9ECD: 3600    		LD	(HL),0
9ECF: CDFE9D  		CALL	STFILPOS	;clear initial file position also.
9ED2: 0EFF    	BITMAP2:LD	C,0FFH		;read next file name in directory
9ED4: CD059E  		CALL	NXENTRY		;and set checksum byte.
9ED7: CDF59D  		CALL	CKFILPOS	;is there another file?
9EDA: C8      		RET	Z
9EDB: CD5E9D  		CALL	FCB2HL		;yes, get its address.
9EDE: 3EE5    		LD	A,0E5H
9EE0: BE      		CP	(HL)		;empty file entry?
9EE1: CAD29E  		JP	Z,BITMAP2
9EE4: 3A419B  		LD	A,(USERNO)	;no, correct user number?
9EE7: BE      		CP	(HL)
9EE8: C2F69E  		JP	NZ,BITMAP3
9EEB: 23      		INC	HL
9EEC: 7E      		LD	A,(HL)		;yes, does name start with a '$'?
9EED: D624    		SUB	'$'
9EEF: C2F69E  		JP	NZ,BITMAP3
9EF2: 3D      		DEC	A		;yes, set atatus to minus one.
9EF3: 32459B  		LD	(STATUS),A
9EF6: 0E01    	BITMAP3:LD	C,1		;now set this file's space as used in bit map.
9EF8: CD6B9E  		CALL	SETFILE
9EFB: CD8C9D  		CALL	CHKNMBR		;keep (SCRATCH1) in bounds.
9EFE: C3D29E  		JP	BITMAP2
              	;
              	;   Set the status (STATUS) and return.
              	;
9F01: 3AD4A5  	STSTATUS: LD	A,(FNDSTAT)
9F04: C3019B  		JP	SETSTAT
              	;
              	;   Check extents in (A) and (C). Set the zero flag if they
              	; are the same. The number of 16k chunks of disk space that
              	; the directory extent covers is expressad is (EXTMASK+1).
              	; No registers are modified.
              	;
9F07: C5      	SAMEXT:	PUSH	BC
9F08: F5      		PUSH	AF
9F09: 3AC5A5  		LD	A,(EXTMASK)	;get extent mask and use it to
9F0C: 2F      		CPL			;to compare both extent numbers.
9F0D: 47      		LD	B,A		;save resulting mask here.
9F0E: 79      		LD	A,C		;mask first extent and save in (C).
9F0F: A0      		AND	B
9F10: 4F      		LD	C,A
9F11: F1      		POP	AF		;now mask second extent and compare
9F12: A0      		AND	B		;with the first one.
9F13: 91      		SUB	C
9F14: E61F    		AND	1FH		;(* only check buts 0-4 *)
9F16: C1      		POP	BC		;the zero flag is set if they are the same.
9F17: C9      		RET			;restore (BC) and return.
              	;
              	;   Search for the first occurence of a file name. On entry,
              	; register (C) should contain the number of bytes of the fcb
              	; that must match.
              	;
9F18: 3EFF    	FINDFST:LD	A,0FFH
9F1A: 32D4A5  		LD	(FNDSTAT),A
9F1D: 21D8A5  		LD	HL,COUNTER	;save character count.
9F20: 71      		LD	(HL),C
9F21: 2A439B  		LD	HL,(PARAMS)	;get filename to match.
9F24: 22D9A5  		LD	(SAVEFCB),HL	;and save.
9F27: CDFE9D  		CALL	STFILPOS	;clear initial file position (set to 0ffffh).
9F2A: CDA19B  		CALL	HOMEDRV		;home the drive.
              	;
              	;   Entry to locate the next occurence of a filename within the
              	; directory. The disk is not expected to have been changed. If
              	; it was, then it will be write protected.
              	;
9F2D: 0E00    	FINDNXT:LD	C,0		;write protect the disk if changed.
9F2F: CD059E  		CALL	NXENTRY		;get next filename entry in directory.
9F32: CDF59D  		CALL	CKFILPOS	;is file position = 0ffffh?
9F35: CA949F  		JP	Z,FNDNXT6	;yes, exit now then.
9F38: 2AD9A5  		LD	HL,(SAVEFCB)	;set (DE) pointing to filename to match.
9F3B: EB      		EX	DE,HL
9F3C: 1A      		LD	A,(DE)
9F3D: FEE5    		CP	0E5H		;empty directory entry?
9F3F: CA4A9F  		JP	Z,FNDNXT1	;(* are we trying to reserect erased entries? *)
9F42: D5      		PUSH	DE
9F43: CD7F9D  		CALL	MOREFLS		;more files in directory?
9F46: D1      		POP	DE
9F47: D2949F  		JP	NC,FNDNXT6	;no more. Exit now.
9F4A: CD5E9D  	FNDNXT1:CALL	FCB2HL		;get address of this fcb in directory.
9F4D: 3AD8A5  		LD	A,(COUNTER)	;get number of bytes (characters) to check.
9F50: 4F      		LD	C,A
9F51: 0600    		LD	B,0		;initialize byte position counter.
9F53: 79      	FNDNXT2:LD	A,C		;are we done with the compare?
9F54: B7      		OR	A
9F55: CA839F  		JP	Z,FNDNXT5
9F58: 1A      		LD	A,(DE)		;no, check next byte.
9F59: FE3F    		CP	'?'		;don't care about this character?
9F5B: CA7C9F  		JP	Z,FNDNXT4
9F5E: 78      		LD	A,B		;get bytes position in fcb.
9F5F: FE0D    		CP	13		;don't care about the thirteenth byte either.
9F61: CA7C9F  		JP	Z,FNDNXT4
9F64: FE0C    		CP	12		;extent byte?
9F66: 1A      		LD	A,(DE)
9F67: CA739F  		JP	Z,FNDNXT3
9F6A: 96      		SUB	(HL)		;otherwise compare characters.
9F6B: E67F    		AND	7FH
9F6D: C22D9F  		JP	NZ,FINDNXT	;not the same, check next entry.
9F70: C37C9F  		JP	FNDNXT4		;so far so good, keep checking.
9F73: C5      	FNDNXT3:PUSH	BC		;check the extent byte here.
9F74: 4E      		LD	C,(HL)
9F75: CD079F  		CALL	SAMEXT
9F78: C1      		POP	BC
9F79: C22D9F  		JP	NZ,FINDNXT	;not the same, look some more.
              	;
              	;   So far the names compare. Bump pointers to the next byte
              	; and continue until all (C) characters have been checked.
              	;
9F7C: 13      	FNDNXT4:INC	DE		;bump pointers.
9F7D: 23      		INC	HL
9F7E: 04      		INC	B
9F7F: 0D      		DEC	C		;adjust character counter.
9F80: C3539F  		JP	FNDNXT2
9F83: 3AEAA5  	FNDNXT5:LD	A,(FILEPOS)	;return the position of this entry.
9F86: E603    		AND	03H
9F88: 32459B  		LD	(STATUS),A
9F8B: 21D4A5  		LD	HL,FNDSTAT
9F8E: 7E      		LD	A,(HL)
9F8F: 17      		RLA	
9F90: D0      		RET	NC
9F91: AF      		XOR	A
9F92: 77      		LD	(HL),A
9F93: C9      		RET	
              	;
              	;   Filename was not found. Set appropriate status.
              	;
9F94: CDFE9D  	FNDNXT6:CALL	STFILPOS	;set (FILEPOS) to 0ffffh.
9F97: 3EFF    		LD	A,0FFH		;say not located.
9F99: C3019B  		JP	SETSTAT
              	;
              	;   Erase files from the directory. Only the first byte of the
              	; fcb will be affected. It is set to (E5).
              	;
9F9C: CD549D  	ERAFILE:CALL	CHKWPRT		;is disk write protected?
9F9F: 0E0C    		LD	C,12		;only compare file names.
9FA1: CD189F  		CALL	FINDFST		;get first file name.
9FA4: CDF59D  	ERAFIL1:CALL	CKFILPOS	;any found?
9FA7: C8      		RET	Z		;nope, we must be done.
9FA8: CD449D  		CALL	CHKROFL		;is file read only?
9FAB: CD5E9D  		CALL	FCB2HL		;nope, get address of fcb and
9FAE: 36E5    		LD	(HL),0E5H	;set first byte to 'empty'.
9FB0: 0E00    		LD	C,0		;clear the space from the bit map.
9FB2: CD6B9E  		CALL	SETFILE
9FB5: CDC69D  		CALL	DIRWRITE	;now write the directory sector back out.
9FB8: CD2D9F  		CALL	FINDNXT		;find the next file name.
9FBB: C3A49F  		JP	ERAFIL1		;and repeat process.
              	;
              	;   Look through the space allocation map (bit map) for the
              	; next available block. Start searching at block number (BC-1).
              	; The search procedure is to look for an empty block that is
              	; before the starting block. If not empty, look at a later
              	; block number. In this way, we return the closest empty block
              	; on either side of the 'target' block number. This will speed
              	; access on random devices. For serial devices, this should be
              	; changed to look in the forward direction first and then start
              	; at the front and search some more.
              	;
              	;   On return, (DE)= block number that is empty and (HL) =0
              	; if no empry block was found.
              	;
9FBE: 50      	FNDSPACE: LD	D,B		;set (DE) as the block that is checked.
9FBF: 59      		LD	E,C
              	;
              	;   Look before target block. Registers (BC) are used as the lower
              	; pointer and (DE) as the upper pointer.
              	;
9FC0: 79      	FNDSPA1:LD	A,C		;is block 0 specified?
9FC1: B0      		OR	B
9FC2: CAD19F  		JP	Z,FNDSPA2
9FC5: 0B      		DEC	BC		;nope, check previous block.
9FC6: D5      		PUSH	DE
9FC7: C5      		PUSH	BC
9FC8: CD359E  		CALL	CKBITMAP
9FCB: 1F      		RRA			;is this block empty?
9FCC: D2EC9F  		JP	NC,FNDSPA3	;yes. use this.
              	;
              	;   Note that the above logic gets the first block that it finds
              	; that is empty. Thus a file could be written 'backward' making
              	; it very slow to access. This could be changed to look for the
              	; first empty block and then continue until the start of this
              	; empty space is located and then used that starting block.
              	; This should help speed up access to some files especially on
              	; a well used disk with lots of fairly small 'holes'.
              	;
9FCF: C1      		POP	BC		;nope, check some more.
9FD0: D1      		POP	DE
              	;
              	;   Now look after target block.
              	;
9FD1: 2AC6A5  	FNDSPA2:LD	HL,(DSKSIZE)	;is block (DE) within disk limits?
9FD4: 7B      		LD	A,E
9FD5: 95      		SUB	L
9FD6: 7A      		LD	A,D
9FD7: 9C      		SBC	A,H
9FD8: D2F49F  		JP	NC,FNDSPA4
9FDB: 13      		INC	DE		;yes, move on to next one.
9FDC: C5      		PUSH	BC
9FDD: D5      		PUSH	DE
9FDE: 42      		LD	B,D
9FDF: 4B      		LD	C,E
9FE0: CD359E  		CALL	CKBITMAP	;check it.
9FE3: 1F      		RRA			;empty?
9FE4: D2EC9F  		JP	NC,FNDSPA3
9FE7: D1      		POP	DE		;nope, continue searching.
9FE8: C1      		POP	BC
9FE9: C3C09F  		JP	FNDSPA1
              	;
              	;   Empty block found. Set it as used and return with (HL)
              	; pointing to it (true?).
              	;
9FEC: 17      	FNDSPA3:RLA			;reset byte.
9FED: 3C      		INC	A		;and set bit 0.
9FEE: CD649E  		CALL	STBMAP1		;update bit map.
9FF1: E1      		POP	HL		;set return registers.
9FF2: D1      		POP	DE
9FF3: C9      		RET	
              	;
              	;   Free block was not found. If (BC) is not zero, then we have
              	; not checked all of the disk space.
              	;
9FF4: 79      	FNDSPA4:LD	A,C
9FF5: B0      		OR	B
9FF6: C2C09F  		JP	NZ,FNDSPA1
9FF9: 210000  		LD	HL,0		;set 'not found' status.
9FFC: C9      		RET	
              	;
              	;   Move a complete fcb entry into the directory and write it.
              	;
9FFD: 0E00    	FCBSET:	LD	C,0
9FFF: 1E20    		LD	E,32		;length of each entry.
              	;
              	;   Move (E) bytes from the fcb pointed to by (PARAMS) into
              	; fcb in directory starting at relative byte (C). This updated
              	; directory buffer is then written to the disk.
              	;
A001: D5      	UPDATE:	PUSH	DE
A002: 0600    		LD	B,0		;set (BC) to relative byte position.
A004: 2A439B  		LD	HL,(PARAMS)	;get address of fcb.
A007: 09      		ADD	HL,BC		;compute starting byte.
A008: EB      		EX	DE,HL
A009: CD5E9D  		CALL	FCB2HL		;get address of fcb to update in directory.
A00C: C1      		POP	BC		;set (C) to number of bytes to change.
A00D: CD4F9B  		CALL	DE2HL
A010: CDC39B  	UPDATE1:CALL	TRKSEC		;determine the track and sector affected.
A013: C3C69D  		JP	DIRWRITE	;then write this sector out.
              	;
              	;   Routine to change the name of all files on the disk with a
              	; specified name. The fcb contains the current name as the
              	; first 12 characters and the new name 16 bytes into the fcb.
              	;
A016: CD549D  	CHGNAMES: CALL	CHKWPRT		;check for a write protected disk.
A019: 0E0C    		LD	C,12		;match first 12 bytes of fcb only.
A01B: CD189F  		CALL	FINDFST		;get first name.
A01E: 2A439B  		LD	HL,(PARAMS)	;get address of fcb.
A021: 7E      		LD	A,(HL)		;get user number.
A022: 111000  		LD	DE,16		;move over to desired name.
A025: 19      		ADD	HL,DE
A026: 77      		LD	(HL),A		;keep same user number.
A027: CDF59D  	CHGNAM1:CALL	CKFILPOS	;any matching file found?
A02A: C8      		RET	Z		;no, we must be done.
A02B: CD449D  		CALL	CHKROFL		;check for read only file.
A02E: 0E10    		LD	C,16		;start 16 bytes into fcb.
A030: 1E0C    		LD	E,12		;and update the first 12 bytes of directory.
A032: CD01A0  		CALL	UPDATE
A035: CD2D9F  		CALL	FINDNXT		;get te next file name.
A038: C327A0  		JP	CHGNAM1		;and continue.
              	;
              	;   Update a files attributes. The procedure is to search for
              	; every file with the same name as shown in fcb (ignoring bit 7)
              	; and then to update it (which includes bit 7). No other changes
              	; are made.
              	;
A03B: 0E0C    	SAVEATTR: LD	C,12		;match first 12 bytes.
A03D: CD189F  		CALL	FINDFST		;look for first filename.
A040: CDF59D  	SAVATR1:CALL	CKFILPOS	;was one found?
A043: C8      		RET	Z		;nope, we must be done.
A044: 0E00    		LD	C,0		;yes, update the first 12 bytes now.
A046: 1E0C    		LD	E,12
A048: CD01A0  		CALL	UPDATE		;update filename and write directory.
A04B: CD2D9F  		CALL	FINDNXT		;and get the next file.
A04E: C340A0  		JP	SAVATR1		;then continue until done.
              	;
              	;  Open a file (name specified in fcb).
              	;
A051: 0E0F    	OPENIT:	LD	C,15		;compare the first 15 bytes.
A053: CD189F  		CALL	FINDFST		;get the first one in directory.
A056: CDF59D  		CALL	CKFILPOS	;any at all?
A059: C8      		RET	Z
A05A: CDA69C  	OPENIT1:CALL	SETEXT		;point to extent byte within users fcb.
A05D: 7E      		LD	A,(HL)		;and get it.
A05E: F5      		PUSH	AF		;save it and address.
A05F: E5      		PUSH	HL
A060: CD5E9D  		CALL	FCB2HL		;point to fcb in directory.
A063: EB      		EX	DE,HL
A064: 2A439B  		LD	HL,(PARAMS)	;this is the users copy.
A067: 0E20    		LD	C,32		;move it into users space.
A069: D5      		PUSH	DE
A06A: CD4F9B  		CALL	DE2HL
A06D: CD789D  		CALL	SETS2B7		;set bit 7 in 's2' byte (unmodified).
A070: D1      		POP	DE		;now get the extent byte from this fcb.
A071: 210C00  		LD	HL,12
A074: 19      		ADD	HL,DE
A075: 4E      		LD	C,(HL)		;into (C).
A076: 210F00  		LD	HL,15		;now get the record count byte into (B).
A079: 19      		ADD	HL,DE
A07A: 46      		LD	B,(HL)
A07B: E1      		POP	HL		;keep the same extent as the user had originally.
A07C: F1      		POP	AF
A07D: 77      		LD	(HL),A
A07E: 79      		LD	A,C		;is it the same as in the directory fcb?
A07F: BE      		CP	(HL)
A080: 78      		LD	A,B		;if yes, then use the same record count.
A081: CA8BA0  		JP	Z,OPENIT2
A084: 3E00    		LD	A,0		;if the user specified an extent greater than
A086: DA8BA0  		JP	C,OPENIT2	;the one in the directory, then set record count to 0.
A089: 3E80    		LD	A,128		;otherwise set to maximum.
A08B: 2A439B  	OPENIT2:LD	HL,(PARAMS)	;set record count in users fcb to (A).
A08E: 110F00  		LD	DE,15
A091: 19      		ADD	HL,DE		;compute relative position.
A092: 77      		LD	(HL),A		;and set the record count.
A093: C9      		RET	
              	;
              	;   Move two bytes from (DE) to (HL) if (and only if) (HL)
              	; point to a zero value (16 bit).
              	;   Return with zero flag set it (DE) was moved. Registers (DE)
              	; and (HL) are not changed. However (A) is.
              	;
A094: 7E      	MOVEWORD: LD	A,(HL)		;check for a zero word.
A095: 23      		INC	HL
A096: B6      		OR	(HL)		;both bytes zero?
A097: 2B      		DEC	HL
A098: C0      		RET	NZ		;nope, just return.
A099: 1A      		LD	A,(DE)		;yes, move two bytes from (DE) into
A09A: 77      		LD	(HL),A		;this zero space.
A09B: 13      		INC	DE
A09C: 23      		INC	HL
A09D: 1A      		LD	A,(DE)
A09E: 77      		LD	(HL),A
A09F: 1B      		DEC	DE		;don't disturb these registers.
A0A0: 2B      		DEC	HL
A0A1: C9      		RET	
              	;
              	;   Get here to close a file specified by (fcb).
              	;
A0A2: AF      	CLOSEIT:XOR	A		;clear status and file position bytes.
A0A3: 32459B  		LD	(STATUS),A
A0A6: 32EAA5  		LD	(FILEPOS),A
A0A9: 32EBA5  		LD	(FILEPOS+1),A
A0AC: CD1E9D  		CALL	GETWPRT		;get write protect bit for this drive.
A0AF: C0      		RET	NZ		;just return if it is set.
A0B0: CD699D  		CALL	GETS2		;else get the 's2' byte.
A0B3: E680    		AND	80H		;and look at bit 7 (file unmodified?).
A0B5: C0      		RET	NZ		;just return if set.
A0B6: 0E0F    		LD	C,15		;else look up this file in directory.
A0B8: CD189F  		CALL	FINDFST
A0BB: CDF59D  		CALL	CKFILPOS	;was it found?
A0BE: C8      		RET	Z		;just return if not.
A0BF: 011000  		LD	BC,16		;set (HL) pointing to records used section.
A0C2: CD5E9D  		CALL	FCB2HL
A0C5: 09      		ADD	HL,BC
A0C6: EB      		EX	DE,HL
A0C7: 2A439B  		LD	HL,(PARAMS)	;do the same for users specified fcb.
A0CA: 09      		ADD	HL,BC
A0CB: 0E10    		LD	C,16		;this many bytes are present in this extent.
A0CD: 3ADDA5  	CLOSEIT1: LD	A,(BIGDISK)	;8 or 16 bit record numbers?
A0D0: B7      		OR	A
A0D1: CAE8A0  		JP	Z,CLOSEIT4
A0D4: 7E      		LD	A,(HL)		;just 8 bit. Get one from users fcb.
A0D5: B7      		OR	A
A0D6: 1A      		LD	A,(DE)		;now get one from directory fcb.
A0D7: C2DBA0  		JP	NZ,CLOSEIT2
A0DA: 77      		LD	(HL),A		;users byte was zero. Update from directory.
A0DB: B7      	CLOSEIT2: OR	A
A0DC: C2E1A0  		JP	NZ,CLOSEIT3
A0DF: 7E      		LD	A,(HL)		;directories byte was zero, update from users fcb.
A0E0: 12      		LD	(DE),A
A0E1: BE      	CLOSEIT3: CP	(HL)		;if neither one of these bytes were zero,
A0E2: C21FA1  		JP	NZ,CLOSEIT7	;then close error if they are not the same.
A0E5: C3FDA0  		JP	CLOSEIT5	;ok so far, get to next byte in fcbs.
A0E8: CD94A0  	CLOSEIT4: CALL	MOVEWORD	;update users fcb if it is zero.
A0EB: EB      		EX	DE,HL
A0EC: CD94A0  		CALL	MOVEWORD	;update directories fcb if it is zero.
A0EF: EB      		EX	DE,HL
A0F0: 1A      		LD	A,(DE)		;if these two values are no different,
A0F1: BE      		CP	(HL)		;then a close error occured.
A0F2: C21FA1  		JP	NZ,CLOSEIT7
A0F5: 13      		INC	DE		;check second byte.
A0F6: 23      		INC	HL
A0F7: 1A      		LD	A,(DE)
A0F8: BE      		CP	(HL)
A0F9: C21FA1  		JP	NZ,CLOSEIT7
A0FC: 0D      		DEC	C		;remember 16 bit values.
A0FD: 13      	CLOSEIT5: INC	DE		;bump to next item in table.
A0FE: 23      		INC	HL
A0FF: 0D      		DEC	C		;there are 16 entries only.
A100: C2CDA0  		JP	NZ,CLOSEIT1	;continue if more to do.
A103: 01ECFF  		LD	BC,0FFECH	;backup 20 places (extent byte).
A106: 09      		ADD	HL,BC
A107: EB      		EX	DE,HL
A108: 09      		ADD	HL,BC
A109: 1A      		LD	A,(DE)
A10A: BE      		CP	(HL)		;directory's extent already greater than the
A10B: DA17A1  		JP	C,CLOSEIT6	;users extent?
A10E: 77      		LD	(HL),A		;no, update directory extent.
A10F: 010300  		LD	BC,3		;and update the record count byte in
A112: 09      		ADD	HL,BC		;directories fcb.
A113: EB      		EX	DE,HL
A114: 09      		ADD	HL,BC
A115: 7E      		LD	A,(HL)		;get from user.
A116: 12      		LD	(DE),A		;and put in directory.
A117: 3EFF    	CLOSEIT6: LD	A,0FFH		;set 'was open and is now closed' byte.
A119: 32D2A5  		LD	(CLOSEFLG),A
A11C: C310A0  		JP	UPDATE1		;update the directory now.
A11F: 21459B  	CLOSEIT7: LD	HL,STATUS	;set return status and then return.
A122: 35      		DEC	(HL)
A123: C9      		RET	
              	;
              	;   Routine to get the next empty space in the directory. It
              	; will then be cleared for use.
              	;
A124: CD549D  	GETEMPTY: CALL	CHKWPRT		;make sure disk is not write protected.
A127: 2A439B  		LD	HL,(PARAMS)	;save current parameters (fcb).
A12A: E5      		PUSH	HL
A12B: 21ACA5  		LD	HL,EMPTYFCB	;use special one for empty space.
A12E: 22439B  		LD	(PARAMS),HL
A131: 0E01    		LD	C,1		;search for first empty spot in directory.
A133: CD189F  		CALL	FINDFST		;(* only check first byte *)
A136: CDF59D  		CALL	CKFILPOS	;none?
A139: E1      		POP	HL
A13A: 22439B  		LD	(PARAMS),HL	;restore original fcb address.
A13D: C8      		RET	Z		;return if no more space.
A13E: EB      		EX	DE,HL
A13F: 210F00  		LD	HL,15		;point to number of records for this file.
A142: 19      		ADD	HL,DE
A143: 0E11    		LD	C,17		;and clear all of this space.
A145: AF      		XOR	A
A146: 77      	GETMT1:	LD	(HL),A
A147: 23      		INC	HL
A148: 0D      		DEC	C
A149: C246A1  		JP	NZ,GETMT1
A14C: 210D00  		LD	HL,13		;clear the 's1' byte also.
A14F: 19      		ADD	HL,DE
A150: 77      		LD	(HL),A
A151: CD8C9D  		CALL	CHKNMBR		;keep (SCRATCH1) within bounds.
A154: CDFD9F  		CALL	FCBSET		;write out this fcb entry to directory.
A157: C3789D  		JP	SETS2B7		;set 's2' byte bit 7 (unmodified at present).
              	;
              	;   Routine to close the current extent and open the next one
              	; for reading.
              	;
A15A: AF      	GETNEXT:XOR	A
A15B: 32D2A5  		LD	(CLOSEFLG),A	;clear close flag.
A15E: CDA2A0  		CALL	CLOSEIT		;close this extent.
A161: CDF59D  		CALL	CKFILPOS
A164: C8      		RET	Z		;not there???
A165: 2A439B  		LD	HL,(PARAMS)	;get extent byte.
A168: 010C00  		LD	BC,12
A16B: 09      		ADD	HL,BC
A16C: 7E      		LD	A,(HL)		;and increment it.
A16D: 3C      		INC	A
A16E: E61F    		AND	1FH		;keep within range 0-31.
A170: 77      		LD	(HL),A
A171: CA83A1  		JP	Z,GTNEXT1	;overflow?
A174: 47      		LD	B,A		;mask extent byte.
A175: 3AC5A5  		LD	A,(EXTMASK)
A178: A0      		AND	B
A179: 21D2A5  		LD	HL,CLOSEFLG	;check close flag (0ffh is ok).
A17C: A6      		AND	(HL)
A17D: CA8EA1  		JP	Z,GTNEXT2	;if zero, we must read in next extent.
A180: C3ACA1  		JP	GTNEXT3		;else, it is already in memory.
A183: 010200  	GTNEXT1:LD	BC,2		;Point to the 's2' byte.
A186: 09      		ADD	HL,BC
A187: 34      		INC	(HL)		;and bump it.
A188: 7E      		LD	A,(HL)		;too many extents?
A189: E60F    		AND	0FH
A18B: CAB6A1  		JP	Z,GTNEXT5	;yes, set error code.
              	;
              	;   Get here to open the next extent.
              	;
A18E: 0E0F    	GTNEXT2:LD	C,15		;set to check first 15 bytes of fcb.
A190: CD189F  		CALL	FINDFST		;find the first one.
A193: CDF59D  		CALL	CKFILPOS	;none available?
A196: C2ACA1  		JP	NZ,GTNEXT3
A199: 3AD3A5  		LD	A,(RDWRTFLG)	;no extent present. Can we open an empty one?
A19C: 3C      		INC	A		;0ffh means reading (so not possible).
A19D: CAB6A1  		JP	Z,GTNEXT5	;or an error.
A1A0: CD24A1  		CALL	GETEMPTY	;we are writing, get an empty entry.
A1A3: CDF59D  		CALL	CKFILPOS	;none?
A1A6: CAB6A1  		JP	Z,GTNEXT5	;error if true.
A1A9: C3AFA1  		JP	GTNEXT4		;else we are almost done.
A1AC: CD5AA0  	GTNEXT3:CALL	OPENIT1		;open this extent.
A1AF: CDBB9C  	GTNEXT4:CALL	STRDATA		;move in updated data (rec #, extent #, etc.)
A1B2: AF      		XOR	A		;clear status and return.
A1B3: C3019B  		JP	SETSTAT
              	;
              	;   Error in extending the file. Too many extents were needed
              	; or not enough space on the disk.
              	;
A1B6: CD059B  	GTNEXT5:CALL	IOERR1		;set error code, clear bit 7 of 's2'
A1B9: C3789D  		JP	SETS2B7		;so this is not written on a close.
              	;
              	;   Read a sequential file.
              	;
A1BC: 3E01    	RDSEQ:	LD	A,1		;set sequential access mode.
A1BE: 32D5A5  		LD	(MODE),A
A1C1: 3EFF    	RDSEQ1:	LD	A,0FFH		;don't allow reading unwritten space.
A1C3: 32D3A5  		LD	(RDWRTFLG),A
A1C6: CDBB9C  		CALL	STRDATA		;put rec# and ext# into fcb.
A1C9: 3AE3A5  		LD	A,(SAVNREC)	;get next record to read.
A1CC: 21E1A5  		LD	HL,SAVNXT	;get number of records in extent.
A1CF: BE      		CP	(HL)		;within this extent?
A1D0: DAE6A1  		JP	C,RDSEQ2
A1D3: FE80    		CP	128		;no. Is this extent fully used?
A1D5: C2FBA1  		JP	NZ,RDSEQ3	;no. End-of-file.
A1D8: CD5AA1  		CALL	GETNEXT		;yes, open the next one.
A1DB: AF      		XOR	A		;reset next record to read.
A1DC: 32E3A5  		LD	(SAVNREC),A
A1DF: 3A459B  		LD	A,(STATUS)	;check on open, successful?
A1E2: B7      		OR	A
A1E3: C2FBA1  		JP	NZ,RDSEQ3	;no, error.
A1E6: CD779C  	RDSEQ2:	CALL	COMBLK		;ok. compute block number to read.
A1E9: CD849C  		CALL	CHKBLK		;check it. Within bounds?
A1EC: CAFBA1  		JP	Z,RDSEQ3	;no, error.
A1EF: CD8A9C  		CALL	LOGICAL		;convert (BLKNMBR) to logical sector (128 byte).
A1F2: CDD19B  		CALL	TRKSEC1		;set the track and sector for this block #.
A1F5: CDB29B  		CALL	DOREAD		;and read it.
A1F8: C3D29C  		JP	SETNREC		;and set the next record to be accessed.
              	;
              	;   Read error occured. Set status and return.
              	;
A1FB: C3059B  	RDSEQ3:	JP	IOERR1
              	;
              	;   Write the next sequential record.
              	;
A1FE: 3E01    	WTSEQ:	LD	A,1		;set sequential access mode.
A200: 32D5A5  		LD	(MODE),A
A203: 3E00    	WTSEQ1:	LD	A,0		;allow an addition empty extent to be opened.
A205: 32D3A5  		LD	(RDWRTFLG),A
A208: CD549D  		CALL	CHKWPRT		;check write protect status.
A20B: 2A439B  		LD	HL,(PARAMS)
A20E: CD479D  		CALL	CKROF1		;check for read only file, (HL) already set to fcb.
A211: CDBB9C  		CALL	STRDATA		;put updated data into fcb.
A214: 3AE3A5  		LD	A,(SAVNREC)	;get record number to write.
A217: FE80    		CP	128		;within range?
A219: D2059B  		JP	NC,IOERR1	;no, error(?).
A21C: CD779C  		CALL	COMBLK		;compute block number.
A21F: CD849C  		CALL	CHKBLK		;check number.
A222: 0E00    		LD	C,0		;is there one to write to?
A224: C26EA2  		JP	NZ,WTSEQ6	;yes, go do it.
A227: CD3E9C  		CALL	GETBLOCK	;get next block number within fcb to use.
A22A: 32D7A5  		LD	(RELBLOCK),A	;and save.
A22D: 010000  		LD	BC,0		;start looking for space from the start
A230: B7      		OR	A		;if none allocated as yet.
A231: CA3BA2  		JP	Z,WTSEQ2
A234: 4F      		LD	C,A		;extract previous block number from fcb
A235: 0B      		DEC	BC		;so we can be closest to it.
A236: CD5E9C  		CALL	EXTBLK
A239: 44      		LD	B,H
A23A: 4D      		LD	C,L
A23B: CDBE9F  	WTSEQ2:	CALL	FNDSPACE	;find the next empty block nearest number (BC).
A23E: 7D      		LD	A,L		;check for a zero number.
A23F: B4      		OR	H
A240: C248A2  		JP	NZ,WTSEQ3
A243: 3E02    		LD	A,2		;no more space?
A245: C3019B  		JP	SETSTAT
A248: 22E5A5  	WTSEQ3:	LD	(BLKNMBR),HL	;save block number to access.
A24B: EB      		EX	DE,HL		;put block number into (DE).
A24C: 2A439B  		LD	HL,(PARAMS)	;now we must update the fcb for this
A24F: 011000  		LD	BC,16		;newly allocated block.
A252: 09      		ADD	HL,BC
A253: 3ADDA5  		LD	A,(BIGDISK)	;8 or 16 bit block numbers?
A256: B7      		OR	A
A257: 3AD7A5  		LD	A,(RELBLOCK)	;(* update this entry *)
A25A: CA64A2  		JP	Z,WTSEQ4	;zero means 16 bit ones.
A25D: CD649D  		CALL	ADDA2HL		;(HL)=(HL)+(A)
A260: 73      		LD	(HL),E		;store new block number.
A261: C36CA2  		JP	WTSEQ5
A264: 4F      	WTSEQ4:	LD	C,A		;compute spot in this 16 bit table.
A265: 0600    		LD	B,0
A267: 09      		ADD	HL,BC
A268: 09      		ADD	HL,BC
A269: 73      		LD	(HL),E		;stuff block number (DE) there.
A26A: 23      		INC	HL
A26B: 72      		LD	(HL),D
A26C: 0E02    	WTSEQ5:	LD	C,2		;set (C) to indicate writing to un-used disk space.
A26E: 3A459B  	WTSEQ6:	LD	A,(STATUS)	;are we ok so far?
A271: B7      		OR	A
A272: C0      		RET	NZ
A273: C5      		PUSH	BC		;yes, save write flag for bios (register C).
A274: CD8A9C  		CALL	LOGICAL		;convert (BLKNMBR) over to loical sectors.
A277: 3AD5A5  		LD	A,(MODE)	;get access mode flag (1=sequential,
A27A: 3D      		DEC	A		;0=random, 2=special?).
A27B: 3D      		DEC	A
A27C: C2BBA2  		JP	NZ,WTSEQ9
              	;
              	;   Special random i/o from function #40. Maybe for M/PM, but the
              	; current block, if it has not been written to, will be zeroed
              	; out and then written (reason?).
              	;
A27F: C1      		POP	BC
A280: C5      		PUSH	BC
A281: 79      		LD	A,C		;get write status flag (2=writing unused space).
A282: 3D      		DEC	A
A283: 3D      		DEC	A
A284: C2BBA2  		JP	NZ,WTSEQ9
A287: E5      		PUSH	HL
A288: 2AB9A5  		LD	HL,(DIRBUF)	;zero out the directory buffer.
A28B: 57      		LD	D,A		;note that (A) is zero here.
A28C: 77      	WTSEQ7:	LD	(HL),A
A28D: 23      		INC	HL
A28E: 14      		INC	D		;do 128 bytes.
A28F: F28CA2  		JP	P,WTSEQ7
A292: CDE09D  		CALL	DIRDMA		;tell the bios the dma address for directory access.
A295: 2AE7A5  		LD	HL,(LOGSECT)	;get sector that starts current block.
A298: 0E02    		LD	C,2		;set 'writing to unused space' flag.
A29A: 22E5A5  	WTSEQ8:	LD	(BLKNMBR),HL	;save sector to write.
A29D: C5      		PUSH	BC
A29E: CDD19B  		CALL	TRKSEC1		;determine its track and sector numbers.
A2A1: C1      		POP	BC
A2A2: CDB89B  		CALL	DOWRITE		;now write out 128 bytes of zeros.
A2A5: 2AE5A5  		LD	HL,(BLKNMBR)	;get sector number.
A2A8: 0E00    		LD	C,0		;set normal write flag.
A2AA: 3AC4A5  		LD	A,(BLKMASK)	;determine if we have written the entire
A2AD: 47      		LD	B,A		;physical block.
A2AE: A5      		AND	L
A2AF: B8      		CP	B
A2B0: 23      		INC	HL		;prepare for the next one.
A2B1: C29AA2  		JP	NZ,WTSEQ8	;continue until (BLKMASK+1) sectors written.
A2B4: E1      		POP	HL		;reset next sector number.
A2B5: 22E5A5  		LD	(BLKNMBR),HL
A2B8: CDDA9D  		CALL	DEFDMA		;and reset dma address.
              	;
              	;   Normal disk write. Set the desired track and sector then
              	; do the actual write.
              	;
A2BB: CDD19B  	WTSEQ9:	CALL	TRKSEC1		;determine track and sector for this write.
A2BE: C1      		POP	BC		;get write status flag.
A2BF: C5      		PUSH	BC
A2C0: CDB89B  		CALL	DOWRITE		;and write this out.
A2C3: C1      		POP	BC
A2C4: 3AE3A5  		LD	A,(SAVNREC)	;get number of records in file.
A2C7: 21E1A5  		LD	HL,SAVNXT	;get last record written.
A2CA: BE      		CP	(HL)
A2CB: DAD2A2  		JP	C,WTSEQ10
A2CE: 77      		LD	(HL),A		;we have to update record count.
A2CF: 34      		INC	(HL)
A2D0: 0E02    		LD	C,2
              	;
              	;*   This area has been patched to correct disk update problem
              	;* when using blocking and de-blocking in the BIOS.
              	;
A2D2: 00      	WTSEQ10:NOP			;was 'dcr c'
A2D3: 00      		NOP			;was 'dcr c'
A2D4: 210000  		LD	HL,0		;was 'jnz wtseq99'
              	;
              	; *   End of patch.
              	;
A2D7: F5      		PUSH	AF
A2D8: CD699D  		CALL	GETS2		;set 'extent written to' flag.
A2DB: E67F    		AND	7FH		;(* clear bit 7 *)
A2DD: 77      		LD	(HL),A
A2DE: F1      		POP	AF		;get record count for this extent.
A2DF: FE7F    	WTSEQ99:CP	127		;is it full?
A2E1: C200A3  		JP	NZ,WTSEQ12
A2E4: 3AD5A5  		LD	A,(MODE)	;yes, are we in sequential mode?
A2E7: FE01    		CP	1
A2E9: C200A3  		JP	NZ,WTSEQ12
A2EC: CDD29C  		CALL	SETNREC		;yes, set next record number.
A2EF: CD5AA1  		CALL	GETNEXT		;and get next empty space in directory.
A2F2: 21459B  		LD	HL,STATUS	;ok?
A2F5: 7E      		LD	A,(HL)
A2F6: B7      		OR	A
A2F7: C2FEA2  		JP	NZ,WTSEQ11
A2FA: 3D      		DEC	A		;yes, set record count to -1.
A2FB: 32E3A5  		LD	(SAVNREC),A
A2FE: 3600    	WTSEQ11:LD	(HL),0		;clear status.
A300: C3D29C  	WTSEQ12:JP	SETNREC		;set next record to access.
              	;
              	;   For random i/o, set the fcb for the desired record number
              	; based on the 'r0,r1,r2' bytes. These bytes in the fcb are
              	; used as follows:
              	;
              	;       fcb+35            fcb+34            fcb+33
              	;  |     'r-2'      |      'r-1'      |      'r-0'     |
              	;  |7             0 | 7             0 | 7             0|
              	;  |0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0 | 0 0 0 0 0 0 0 0|
              	;  |    overflow   | | extra |  extent   |   record #  |
              	;  | ______________| |_extent|__number___|_____________|
              	;                     also 's2'
              	;
              	;   On entry, register (C) contains 0ffh if this is a read
              	; and thus we can not access unwritten disk space. Otherwise,
              	; another extent will be opened (for writing) if required.
              	;
A303: AF      	POSITION: XOR	A		;set random i/o flag.
A304: 32D5A5  		LD	(MODE),A
              	;
              	;   Special entry (function #40). M/PM ?
              	;
A307: C5      	POSITN1:PUSH	BC		;save read/write flag.
A308: 2A439B  		LD	HL,(PARAMS)	;get address of fcb.
A30B: EB      		EX	DE,HL
A30C: 212100  		LD	HL,33		;now get byte 'r0'.
A30F: 19      		ADD	HL,DE
A310: 7E      		LD	A,(HL)
A311: E67F    		AND	7FH		;keep bits 0-6 for the record number to access.
A313: F5      		PUSH	AF
A314: 7E      		LD	A,(HL)		;now get bit 7 of 'r0' and bits 0-3 of 'r1'.
A315: 17      		RLA	
A316: 23      		INC	HL
A317: 7E      		LD	A,(HL)
A318: 17      		RLA	
A319: E61F    		AND	1FH		;and save this in bits 0-4 of (C).
A31B: 4F      		LD	C,A		;this is the extent byte.
A31C: 7E      		LD	A,(HL)		;now get the extra extent byte.
A31D: 1F      		RRA	
A31E: 1F      		RRA	
A31F: 1F      		RRA	
A320: 1F      		RRA	
A321: E60F    		AND	0FH
A323: 47      		LD	B,A		;and save it in (B).
A324: F1      		POP	AF		;get record number back to (A).
A325: 23      		INC	HL		;check overflow byte 'r2'.
A326: 6E      		LD	L,(HL)
A327: 2C      		INC	L
A328: 2D      		DEC	L
A329: 2E06    		LD	L,6		;prepare for error.
A32B: C28BA3  		JP	NZ,POSITN5	;out of disk space error.
A32E: 212000  		LD	HL,32		;store record number into fcb.
A331: 19      		ADD	HL,DE
A332: 77      		LD	(HL),A
A333: 210C00  		LD	HL,12		;and now check the extent byte.
A336: 19      		ADD	HL,DE
A337: 79      		LD	A,C
A338: 96      		SUB	(HL)		;same extent as before?
A339: C247A3  		JP	NZ,POSITN2
A33C: 210E00  		LD	HL,14		;yes, check extra extent byte 's2' also.
A33F: 19      		ADD	HL,DE
A340: 78      		LD	A,B
A341: 96      		SUB	(HL)
A342: E67F    		AND	7FH
A344: CA7FA3  		JP	Z,POSITN3	;same, we are almost done then.
              	;
              	;  Get here when another extent is required.
              	;
A347: C5      	POSITN2:PUSH	BC
A348: D5      		PUSH	DE
A349: CDA2A0  		CALL	CLOSEIT		;close current extent.
A34C: D1      		POP	DE
A34D: C1      		POP	BC
A34E: 2E03    		LD	L,3		;prepare for error.
A350: 3A459B  		LD	A,(STATUS)
A353: 3C      		INC	A
A354: CA84A3  		JP	Z,POSITN4	;close error.
A357: 210C00  		LD	HL,12		;put desired extent into fcb now.
A35A: 19      		ADD	HL,DE
A35B: 71      		LD	(HL),C
A35C: 210E00  		LD	HL,14		;and store extra extent byte 's2'.
A35F: 19      		ADD	HL,DE
A360: 70      		LD	(HL),B
A361: CD51A0  		CALL	OPENIT		;try and get this extent.
A364: 3A459B  		LD	A,(STATUS)	;was it there?
A367: 3C      		INC	A
A368: C27FA3  		JP	NZ,POSITN3
A36B: C1      		POP	BC		;no. can we create a new one (writing?).
A36C: C5      		PUSH	BC
A36D: 2E04    		LD	L,4		;prepare for error.
A36F: 0C      		INC	C
A370: CA84A3  		JP	Z,POSITN4	;nope, reading unwritten space error.
A373: CD24A1  		CALL	GETEMPTY	;yes we can, try to find space.
A376: 2E05    		LD	L,5		;prepare for error.
A378: 3A459B  		LD	A,(STATUS)
A37B: 3C      		INC	A
A37C: CA84A3  		JP	Z,POSITN4	;out of space?
              	;
              	;   Normal return location. Clear error code and return.
              	;
A37F: C1      	POSITN3:POP	BC		;restore stack.
A380: AF      		XOR	A		;and clear error code byte.
A381: C3019B  		JP	SETSTAT
              	;
              	;   Error. Set the 's2' byte to indicate this (why?).
              	;
A384: E5      	POSITN4:PUSH	HL
A385: CD699D  		CALL	GETS2
A388: 36C0    		LD	(HL),0C0H
A38A: E1      		POP	HL
              	;
              	;   Return with error code (presently in L).
              	;
A38B: C1      	POSITN5:POP	BC
A38C: 7D      		LD	A,L		;get error code.
A38D: 32459B  		LD	(STATUS),A
A390: C3789D  		JP	SETS2B7
              	;
              	;   Read a random record.
              	;
A393: 0EFF    	READRAN:LD	C,0FFH		;set 'read' status.
A395: CD03A3  		CALL	POSITION	;position the file to proper record.
A398: CCC1A1  		CALL	Z,RDSEQ1	;and read it as usual (if no errors).
A39B: C9      		RET	
              	;
              	;   Write to a random record.
              	;
A39C: 0E00    	WRITERAN: LD	C,0		;set 'writing' flag.
A39E: CD03A3  		CALL	POSITION	;position the file to proper record.
A3A1: CC03A2  		CALL	Z,WTSEQ1	;and write as usual (if no errors).
A3A4: C9      		RET	
              	;
              	;   Compute the random record number. Enter with (HL) pointing
              	; to a fcb an (DE) contains a relative location of a record
              	; number. On exit, (C) contains the 'r0' byte, (B) the 'r1'
              	; byte, and (A) the 'r2' byte.
              	;
              	;   On return, the zero flag is set if the record is within
              	; bounds. Otherwise, an overflow occured.
              	;
A3A5: EB      	COMPRAND: EX	DE,HL		;save fcb pointer in (DE).
A3A6: 19      		ADD	HL,DE		;compute relative position of record #.
A3A7: 4E      		LD	C,(HL)		;get record number into (BC).
A3A8: 0600    		LD	B,0
A3AA: 210C00  		LD	HL,12		;now get extent.
A3AD: 19      		ADD	HL,DE
A3AE: 7E      		LD	A,(HL)		;compute (BC)=(record #)+(extent)*128.
A3AF: 0F      		RRCA			;move lower bit into bit 7.
A3B0: E680    		AND	80H		;and ignore all other bits.
A3B2: 81      		ADD	A,C		;add to our record number.
A3B3: 4F      		LD	C,A
A3B4: 3E00    		LD	A,0		;take care of any carry.
A3B6: 88      		ADC	A,B
A3B7: 47      		LD	B,A
A3B8: 7E      		LD	A,(HL)		;now get the upper bits of extent into
A3B9: 0F      		RRCA			;bit positions 0-3.
A3BA: E60F    		AND	0FH		;and ignore all others.
A3BC: 80      		ADD	A,B		;add this in to 'r1' byte.
A3BD: 47      		LD	B,A
A3BE: 210E00  		LD	HL,14		;get the 's2' byte (extra extent).
A3C1: 19      		ADD	HL,DE
A3C2: 7E      		LD	A,(HL)
A3C3: 87      		ADD	A,A		;and shift it left 4 bits (bits 4-7).
A3C4: 87      		ADD	A,A
A3C5: 87      		ADD	A,A
A3C6: 87      		ADD	A,A
A3C7: F5      		PUSH	AF		;save carry flag (bit 0 of flag byte).
A3C8: 80      		ADD	A,B		;now add extra extent into 'r1'.
A3C9: 47      		LD	B,A
A3CA: F5      		PUSH	AF		;and save carry (overflow byte 'r2').
A3CB: E1      		POP	HL		;bit 0 of (L) is the overflow indicator.
A3CC: 7D      		LD	A,L
A3CD: E1      		POP	HL		;and same for first carry flag.
A3CE: B5      		OR	L		;either one of these set?
A3CF: E601    		AND	01H		;only check the carry flags.
A3D1: C9      		RET	
              	;
              	;   Routine to setup the fcb (bytes 'r0', 'r1', 'r2') to
              	; reflect the last record used for a random (or other) file.
              	; This reads the directory and looks at all extents computing
              	; the largerst record number for each and keeping the maximum
              	; value only. Then 'r0', 'r1', and 'r2' will reflect this
              	; maximum record number. This is used to compute the space used
              	; by a random file.
              	;
A3D2: 0E0C    	RANSIZE:LD	C,12		;look thru directory for first entry with
A3D4: CD189F  		CALL	FINDFST		;this name.
A3D7: 2A439B  		LD	HL,(PARAMS)	;zero out the 'r0, r1, r2' bytes.
A3DA: 112100  		LD	DE,33
A3DD: 19      		ADD	HL,DE
A3DE: E5      		PUSH	HL
A3DF: 72      		LD	(HL),D		;note that (D)=0.
A3E0: 23      		INC	HL
A3E1: 72      		LD	(HL),D
A3E2: 23      		INC	HL
A3E3: 72      		LD	(HL),D
A3E4: CDF59D  	RANSIZ1:CALL	CKFILPOS	;is there an extent to process?
A3E7: CA0CA4  		JP	Z,RANSIZ3	;no, we are done.
A3EA: CD5E9D  		CALL	FCB2HL		;set (HL) pointing to proper fcb in dir.
A3ED: 110F00  		LD	DE,15		;point to last record in extent.
A3F0: CDA5A3  		CALL	COMPRAND	;and compute random parameters.
A3F3: E1      		POP	HL
A3F4: E5      		PUSH	HL		;now check these values against those
A3F5: 5F      		LD	E,A		;already in fcb.
A3F6: 79      		LD	A,C		;the carry flag will be set if those
A3F7: 96      		SUB	(HL)		;in the fcb represent a larger size than
A3F8: 23      		INC	HL		;this extent does.
A3F9: 78      		LD	A,B
A3FA: 9E      		SBC	A,(HL)
A3FB: 23      		INC	HL
A3FC: 7B      		LD	A,E
A3FD: 9E      		SBC	A,(HL)
A3FE: DA06A4  		JP	C,RANSIZ2
A401: 73      		LD	(HL),E		;we found a larger (in size) extent.
A402: 2B      		DEC	HL		;stuff these values into fcb.
A403: 70      		LD	(HL),B
A404: 2B      		DEC	HL
A405: 71      		LD	(HL),C
A406: CD2D9F  	RANSIZ2:CALL	FINDNXT		;now get the next extent.
A409: C3E4A3  		JP	RANSIZ1		;continue til all done.
A40C: E1      	RANSIZ3:POP	HL		;we are done, restore the stack and
A40D: C9      		RET			;return.
              	;
              	;   Function to return the random record position of a given
              	; file which has been read in sequential mode up to now.
              	;
A40E: 2A439B  	SETRAN:	LD	HL,(PARAMS)	;point to fcb.
A411: 112000  		LD	DE,32		;and to last used record.
A414: CDA5A3  		CALL	COMPRAND	;compute random position.
A417: 212100  		LD	HL,33		;now stuff these values into fcb.
A41A: 19      		ADD	HL,DE
A41B: 71      		LD	(HL),C		;move 'r0'.
A41C: 23      		INC	HL
A41D: 70      		LD	(HL),B		;and 'r1'.
A41E: 23      		INC	HL
A41F: 77      		LD	(HL),A		;and lastly 'r2'.
A420: C9      		RET	
              	;
              	;   This routine select the drive specified in (ACTIVE) and
              	; update the login vector and bitmap table if this drive was
              	; not already active.
              	;
A421: 2AAFA5  	LOGINDRV: LD	HL,(LOGIN)	;get the login vector.
A424: 3A429B  		LD	A,(ACTIVE)	;get the default drive.
A427: 4F      		LD	C,A
A428: CDEA9C  		CALL	SHIFTR		;position active bit for this drive
A42B: E5      		PUSH	HL		;into bit 0.
A42C: EB      		EX	DE,HL
A42D: CD599B  		CALL	SELECT		;select this drive.
A430: E1      		POP	HL
A431: CC479B  		CALL	Z,SLCTERR	;valid drive?
A434: 7D      		LD	A,L		;is this a newly activated drive?
A435: 1F      		RRA	
A436: D8      		RET	C
A437: 2AAFA5  		LD	HL,(LOGIN)	;yes, update the login vector.
A43A: 4D      		LD	C,L
A43B: 44      		LD	B,H
A43C: CD0B9D  		CALL	SETBIT
A43F: 22AFA5  		LD	(LOGIN),HL	;and save.
A442: C3A39E  		JP	BITMAP		;now update the bitmap.
              	;
              	;   Function to set the active disk number.
              	;
A445: 3AD6A5  	SETDSK:	LD	A,(EPARAM)	;get parameter passed and see if this
A448: 21429B  		LD	HL,ACTIVE	;represents a change in drives.
A44B: BE      		CP	(HL)
A44C: C8      		RET	Z
A44D: 77      		LD	(HL),A		;yes it does, log it in.
A44E: C321A4  		JP	LOGINDRV
              	;
              	;   This is the 'auto disk select' routine. The firsst byte
              	; of the fcb is examined for a drive specification. If non
              	; zero then the drive will be selected and loged in.
              	;
A451: 3EFF    	AUTOSEL:LD	A,0FFH		;say 'auto-select activated'.
A453: 32DEA5  		LD	(AUTO),A
A456: 2A439B  		LD	HL,(PARAMS)	;get drive specified.
A459: 7E      		LD	A,(HL)
A45A: E61F    		AND	1FH		;look at lower 5 bits.
A45C: 3D      		DEC	A		;adjust for (1=A, 2=B) etc.
A45D: 32D6A5  		LD	(EPARAM),A	;and save for the select routine.
A460: FE1E    		CP	1EH		;check for 'no change' condition.
A462: D275A4  		JP	NC,AUTOSL1	;yes, don't change.
A465: 3A429B  		LD	A,(ACTIVE)	;we must change, save currently active
A468: 32DFA5  		LD	(OLDDRV),A	;drive.
A46B: 7E      		LD	A,(HL)		;and save first byte of fcb also.
A46C: 32E0A5  		LD	(AUTOFLAG),A	;this must be non-zero.
A46F: E6E0    		AND	0E0H		;whats this for (bits 6,7 are used for
A471: 77      		LD	(HL),A		;something)?
A472: CD45A4  		CALL	SETDSK		;select and log in this drive.
A475: 3A419B  	AUTOSL1:LD	A,(USERNO)	;move user number into fcb.
A478: 2A439B  		LD	HL,(PARAMS)	;(* upper half of first byte *)
A47B: B6      		OR	(HL)
A47C: 77      		LD	(HL),A
A47D: C9      		RET			;and return (all done).
              	;
              	;   Function to return the current cp/m version number.
              	;
A47E: 3E22    	GETVER:	LD	A,022H		;version 2.2
A480: C3019B  		JP	SETSTAT
              	;
              	;   Function to reset the disk system.
              	;
A483: 210000  	RSTDSK:	LD	HL,0		;clear write protect status and log
A486: 22ADA5  		LD	(WRTPRT),HL	;in vector.
A489: 22AFA5  		LD	(LOGIN),HL
A48C: AF      		XOR	A		;select drive 'A'.
A48D: 32429B  		LD	(ACTIVE),A
A490: 218000  		LD	HL,TBUFF	;setup default dma address.
A493: 22B1A5  		LD	(USERDMA),HL
A496: CDDA9D  		CALL	DEFDMA
A499: C321A4  		JP	LOGINDRV	;now log in drive 'A'.
              	;
              	;   Function to open a specified file.
              	;
A49C: CD729D  	OPENFIL:CALL	CLEARS2		;clear 's2' byte.
A49F: CD51A4  		CALL	AUTOSEL		;select proper disk.
A4A2: C351A0  		JP	OPENIT		;and open the file.
              	;
              	;   Function to close a specified file.
              	;
A4A5: CD51A4  	CLOSEFIL: CALL	AUTOSEL		;select proper disk.
A4A8: C3A2A0  		JP	CLOSEIT		;and close the file.
              	;
              	;   Function to return the first occurence of a specified file
              	; name. If the first byte of the fcb is '?' then the name will
              	; not be checked (get the first entry no matter what).
              	;
A4AB: 0E00    	GETFST:	LD	C,0		;prepare for special search.
A4AD: EB      		EX	DE,HL
A4AE: 7E      		LD	A,(HL)		;is first byte a '?'?
A4AF: FE3F    		CP	'?'
A4B1: CAC2A4  		JP	Z,GETFST1	;yes, just get very first entry (zero length match).
A4B4: CDA69C  		CALL	SETEXT		;get the extension byte from fcb.
A4B7: 7E      		LD	A,(HL)		;is it '?'? if yes, then we want
A4B8: FE3F    		CP	'?'		;an entry with a specific 's2' byte.
A4BA: C4729D  		CALL	NZ,CLEARS2	;otherwise, look for a zero 's2' byte.
A4BD: CD51A4  		CALL	AUTOSEL		;select proper drive.
A4C0: 0E0F    		LD	C,15		;compare bytes 0-14 in fcb (12&13 excluded).
A4C2: CD189F  	GETFST1:CALL	FINDFST		;find an entry and then move it into
A4C5: C3E99D  		JP	MOVEDIR		;the users dma space.
              	;
              	;   Function to return the next occurence of a file name.
              	;
A4C8: 2AD9A5  	GETNXT:	LD	HL,(SAVEFCB)	;restore pointers. note that no
A4CB: 22439B  		LD	(PARAMS),HL	;other dbos calls are allowed.
A4CE: CD51A4  		CALL	AUTOSEL		;no error will be returned, but the
A4D1: CD2D9F  		CALL	FINDNXT		;results will be wrong.
A4D4: C3E99D  		JP	MOVEDIR
              	;
              	;   Function to delete a file by name.
              	;
A4D7: CD51A4  	DELFILE:CALL	AUTOSEL		;select proper drive.
A4DA: CD9C9F  		CALL	ERAFILE		;erase the file.
A4DD: C3019F  		JP	STSTATUS	;set status and return.
              	;
              	;   Function to execute a sequential read of the specified
              	; record number.
              	;
A4E0: CD51A4  	READSEQ:CALL	AUTOSEL		;select proper drive then read.
A4E3: C3BCA1  		JP	RDSEQ
              	;
              	;   Function to write the net sequential record.
              	;
A4E6: CD51A4  	WRTSEQ:	CALL	AUTOSEL		;select proper drive then write.
A4E9: C3FEA1  		JP	WTSEQ
              	;
              	;   Create a file function.
              	;
A4EC: CD729D  	FCREATE:CALL	CLEARS2		;clear the 's2' byte on all creates.
A4EF: CD51A4  		CALL	AUTOSEL		;select proper drive and get the next
A4F2: C324A1  		JP	GETEMPTY	;empty directory space.
              	;
              	;   Function to rename a file.
              	;
A4F5: CD51A4  	RENFILE:CALL	AUTOSEL		;select proper drive and then switch
A4F8: CD16A0  		CALL	CHGNAMES	;file names.
A4FB: C3019F  		JP	STSTATUS
              	;
              	;   Function to return the login vector.
              	;
A4FE: 2AAFA5  	GETLOG:	LD	HL,(LOGIN)
A501: C329A5  		JP	GETPRM1
              	;
              	;   Function to return the current disk assignment.
              	;
A504: 3A429B  	GETCRNT:LD	A,(ACTIVE)
A507: C3019B  		JP	SETSTAT
              	;
              	;   Function to set the dma address.
              	;
A50A: EB      	PUTDMA:	EX	DE,HL
A50B: 22B1A5  		LD	(USERDMA),HL	;save in our space and then get to
A50E: C3DA9D  		JP	DEFDMA		;the bios with this also.
              	;
              	;   Function to return the allocation vector.
              	;
A511: 2ABFA5  	GETALOC:LD	HL,(ALOCVECT)
A514: C329A5  		JP	GETPRM1
              	;
              	;   Function to return the read-only status vector.
              	;
A517: 2AADA5  	GETROV:	LD	HL,(WRTPRT)
A51A: C329A5  		JP	GETPRM1
              	;
              	;   Function to set the file attributes (read-only, system).
              	;
A51D: CD51A4  	SETATTR:CALL	AUTOSEL		;select proper drive then save attributes.
A520: CD3BA0  		CALL	SAVEATTR
A523: C3019F  		JP	STSTATUS
              	;
              	;   Function to return the address of the disk parameter block
              	; for the current drive.
              	;
A526: 2ABBA5  	GETPARM:LD	HL,(DISKPB)
A529: 22459B  	GETPRM1:LD	(STATUS),HL
A52C: C9      		RET	
              	;
              	;   Function to get or set the user number. If (E) was (FF)
              	; then this is a request to return the current user number.
              	; Else set the user number from (E).
              	;
A52D: 3AD6A5  	GETUSER:LD	A,(EPARAM)	;get parameter.
A530: FEFF    		CP	0FFH		;get user number?
A532: C23BA5  		JP	NZ,SETUSER
A535: 3A419B  		LD	A,(USERNO)	;yes, just do it.
A538: C3019B  		JP	SETSTAT
A53B: E61F    	SETUSER:AND	1FH		;no, we should set it instead. keep low
A53D: 32419B  		LD	(USERNO),A	;bits (0-4) only.
A540: C9      		RET	
              	;
              	;   Function to read a random record from a file.
              	;
A541: CD51A4  	RDRANDOM: CALL	AUTOSEL		;select proper drive and read.
A544: C393A3  		JP	READRAN
              	;
              	;   Function to compute the file size for random files.
              	;
A547: CD51A4  	WTRANDOM: CALL	AUTOSEL		;select proper drive and write.
A54A: C39CA3  		JP	WRITERAN
              	;
              	;   Function to compute the size of a random file.
              	;
A54D: CD51A4  	FILESIZE: CALL	AUTOSEL		;select proper drive and check file length
A550: C3D2A3  		JP	RANSIZE
              	;
              	;   Function #37. This allows a program to log off any drives.
              	; On entry, set (DE) to contain a word with bits set for those
              	; drives that are to be logged off. The log-in vector and the
              	; write protect vector will be updated. This must be a M/PM
              	; special function.
              	;
A553: 2A439B  	LOGOFF:	LD	HL,(PARAMS)	;get drives to log off.
A556: 7D      		LD	A,L		;for each bit that is set, we want
A557: 2F      		CPL			;to clear that bit in (LOGIN)
A558: 5F      		LD	E,A		;and (WRTPRT).
A559: 7C      		LD	A,H
A55A: 2F      		CPL	
A55B: 2AAFA5  		LD	HL,(LOGIN)	;reset the login vector.
A55E: A4      		AND	H
A55F: 57      		LD	D,A
A560: 7D      		LD	A,L
A561: A3      		AND	E
A562: 5F      		LD	E,A
A563: 2AADA5  		LD	HL,(WRTPRT)
A566: EB      		EX	DE,HL
A567: 22AFA5  		LD	(LOGIN),HL	;and save.
A56A: 7D      		LD	A,L		;now do the write protect vector.
A56B: A3      		AND	E
A56C: 6F      		LD	L,A
A56D: 7C      		LD	A,H
A56E: A2      		AND	D
A56F: 67      		LD	H,A
A570: 22ADA5  		LD	(WRTPRT),HL	;and save. all done.
A573: C9      		RET	
              	;
              	;   Get here to return to the user.
              	;
A574: 3ADEA5  	GOBACK:	LD	A,(AUTO)	;was auto select activated?
A577: B7      		OR	A
A578: CA91A5  		JP	Z,GOBACK1
A57B: 2A439B  		LD	HL,(PARAMS)	;yes, but was a change made?
A57E: 3600    		LD	(HL),0		;(* reset first byte of fcb *)
A580: 3AE0A5  		LD	A,(AUTOFLAG)
A583: B7      		OR	A
A584: CA91A5  		JP	Z,GOBACK1
A587: 77      		LD	(HL),A		;yes, reset first byte properly.
A588: 3ADFA5  		LD	A,(OLDDRV)	;and get the old drive and select it.
A58B: 32D6A5  		LD	(EPARAM),A
A58E: CD45A4  		CALL	SETDSK
A591: 2A0F9B  	GOBACK1:LD	HL,(USRSTACK)	;reset the users stack pointer.
A594: F9      		LD	SP,HL
A595: 2A459B  		LD	HL,(STATUS)	;get return status.
A598: 7D      		LD	A,L		;force version 1.4 compatability.
A599: 44      		LD	B,H
A59A: C9      		RET			;and go back to user.
              	;
              	;   Function #40. This is a special entry to do random i/o.
              	; For the case where we are writing to unused disk space, this
              	; space will be zeroed out first. This must be a M/PM special
              	; purpose function, because why would any normal program even
              	; care about the previous contents of a sector about to be
              	; written over.
              	;
A59B: CD51A4  	WTSPECL:CALL	AUTOSEL		;select proper drive.
A59E: 3E02    		LD	A,2		;use special write mode.
A5A0: 32D5A5  		LD	(MODE),A
A5A3: 0E00    		LD	C,0		;set write indicator.
A5A5: CD07A3  		CALL	POSITN1		;position the file.
A5A8: CC03A2  		CALL	Z,WTSEQ1	;and write (if no errors).
A5AB: C9      		RET	
              	;
              	;**************************************************************
              	;*
              	;*     BDOS data storage pool.
              	;*
              	;**************************************************************
              	;
A5AC: E5      	EMPTYFCB: DEFB	0E5H		;empty directory segment indicator.
A5AD: 0000    	WRTPRT:	DEFW	0		;write protect status for all 16 drives.
A5AF: 0000    	LOGIN:	DEFW	0		;drive active word (1 bit per drive).
A5B1: 8000    	USERDMA:DEFW	080H		;user's dma address (defaults to 80h).
              	;
              	;   Scratch areas from parameter block.
              	;
A5B3: 0000    	SCRATCH1: DEFW	0		;relative position within dir segment for file (0-3).
A5B5: 0000    	SCRATCH2: DEFW	0		;last selected track number.
A5B7: 0000    	SCRATCH3: DEFW	0		;last selected sector number.
              	;
              	;   Disk storage areas from parameter block.
              	;
A5B9: 0000    	DIRBUF:	DEFW	0		;address of directory buffer to use.
A5BB: 0000    	DISKPB:	DEFW	0		;contains address of disk parameter block.
A5BD: 0000    	CHKVECT:DEFW	0		;address of check vector.
A5BF: 0000    	ALOCVECT: DEFW	0		;address of allocation vector (bit map).
              	;
              	;   Parameter block returned from the bios.
              	;
A5C1: 0000    	SECTORS:DEFW	0		;sectors per track from bios.
A5C3: 00      	BLKSHFT:DEFB	0		;block shift.
A5C4: 00      	BLKMASK:DEFB	0		;block mask.
A5C5: 00      	EXTMASK:DEFB	0		;extent mask.
A5C6: 0000    	DSKSIZE:DEFW	0		;disk size from bios (number of blocks-1).
A5C8: 0000    	DIRSIZE:DEFW	0		;directory size.
A5CA: 0000    	ALLOC0:	DEFW	0		;storage for first bytes of bit map (dir space used).
A5CC: 0000    	ALLOC1:	DEFW	0
A5CE: 0000    	OFFSET:	DEFW	0		;first usable track number.
A5D0: 0000    	XLATE:	DEFW	0		;sector translation table address.
              	;
              	;
A5D2: 00      	CLOSEFLG: DEFB	0		;close flag (=0ffh is extent written ok).
A5D3: 00      	RDWRTFLG: DEFB	0		;read/write flag (0ffh=read, 0=write).
A5D4: 00      	FNDSTAT:DEFB	0		;filename found status (0=found first entry).
A5D5: 00      	MODE:	DEFB	0		;I/o mode select (0=random, 1=sequential, 2=special random).
A5D6: 00      	EPARAM:	DEFB	0		;storage for register (E) on entry to bdos.
A5D7: 00      	RELBLOCK: DEFB	0		;relative position within fcb of block number written.
A5D8: 00      	COUNTER:DEFB	0		;byte counter for directory name searches.
A5D9: 00000000	SAVEFCB:DEFW	0,0		;save space for address of fcb (for directory searches).
A5DD: 00      	BIGDISK:DEFB	0		;if =0 then disk is > 256 blocks long.
A5DE: 00      	AUTO:	DEFB	0		;if non-zero, then auto select activated.
A5DF: 00      	OLDDRV:	DEFB	0		;on auto select, storage for previous drive.
A5E0: 00      	AUTOFLAG: DEFB	0		;if non-zero, then auto select changed drives.
A5E1: 00      	SAVNXT:	DEFB	0		;storage for next record number to access.
A5E2: 00      	SAVEXT:	DEFB	0		;storage for extent number of file.
A5E3: 0000    	SAVNREC:DEFW	0		;storage for number of records in file.
A5E5: 0000    	BLKNMBR:DEFW	0		;block number (physical sector) used within a file or logical sect
A5E7: 0000    	LOGSECT:DEFW	0		;starting logical (128 byte) sector of block (physical sector).
A5E9: 00      	FCBPOS:	DEFB	0		;relative position within buffer for fcb of file of interest.
A5EA: 0000    	FILEPOS:DEFW	0		;files position within directory (0 to max entries -1).
              	;
              	;   Disk directory buffer checksum bytes. One for each of the
              	; 16 possible drives.
              	;
A5EC: 00000000	CKSUMTBL: DEFB	0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
A5F0: 00...   	
              	;
              	;   Extra space ?
              	;
A5FC: 00000000		DEFB	0,0,0,0
              	;
              	;**************************************************************
              	;*
              	;*        B I O S   J U M P   T A B L E
              	;*
              	;**************************************************************
              	;
A600: C30000  	BOOT:	JP	0		;NOTE WE USE FAKE DESTINATIONS
A603: C30000  	WBOOT:	JP	0
A606: C30000  	CONST:	JP	0
A609: C30000  	CONIN:	JP	0
A60C: C30000  	CONOUT:	JP	0
A60F: C30000  	LIST:	JP	0
A612: C30000  	PUNCH:	JP	0
A615: C30000  	READER:	JP	0
A618: C30000  	HOME:	JP	0
A61B: C30000  	SELDSK:	JP	0
A61E: C30000  	SETTRK:	JP	0
A621: C30000  	SETSEC:	JP	0
A624: C30000  	SETDMA:	JP	0
A627: C30000  	READ:	JP	0
A62A: C30000  	WRITE:	JP	0
A62D: C30000  	PRSTAT:	JP	0
A630: C30000  	SECTRN:	JP	0
              	;
              	;*
              	;******************   E N D   O F   C P / M   *****************
              	;*
A633:         	END
              	
***ERROR*** No such file or directory: file = "/pub/Develop/Projects/zasm-4.0/Test/Z80/original/CPM22." (fd108)


; +++ segments +++

#CODE          = $9000 = 36864,  size = $1633 =  5683

; +++ global symbols +++

ACTIVE   = $9B42 = 39746          CPM22.asm:1700
ADDA2HL  = $9D64 = 40292          CPM22.asm:2129
ADDHL    = $9259 = 37465          CPM22.asm:432
ALLOC0   = $A5CA = 42442          CPM22.asm:3677
ALLOC1   = $A5CC = 42444          CPM22.asm:3678
ALOCVECT = $A5BF = 42431          CPM22.asm:3667
AUTO     = $A5DE = 42462          CPM22.asm:3692
AUTOFLAG = $A5E0 = 42464          CPM22.asm:3694
AUTOSEL  = $A451 = 42065          CPM22.asm:3407
AUTOSL1  = $A475 = 42101          CPM22.asm:3423
BACKUP   = $99A4 = 39332          CPM22.asm:1460
BACKUP1  = $99AC = 39340          CPM22.asm:1463
BADLOAD  = $977A = 38778          CPM22.asm:1191
BADSCTR  = $9809 = 38921          CPM22.asm:1244
BADSEC   = $98CA = 39114          CPM22.asm:1315
BADSEL   = $98D5 = 39125          CPM22.asm:1316
BADSLCT  = $980B = 38923          CPM22.asm:1245
BATCH    = $97AB = 38827          CPM22.asm:1214
BATCHFCB = $97AC = 38828          CPM22.asm:1215
BDOSDRV  = $98C6 = 39110          CPM22.asm:1314
BDOSERR  = $98BA = 39098          CPM22.asm:1313
BIGDISK  = $A5DD = 42461          CPM22.asm:3691
BITMAP   = $9EA3 = 40611          CPM22.asm:2422
BITMAP1  = $9EB1 = 40625          CPM22.asm:2437
BITMAP2  = $9ED2 = 40658          CPM22.asm:2458
BITMAP3  = $9EF6 = 40694          CPM22.asm:2475
BLKMASK  = $A5C4 = 42436          CPM22.asm:3673
BLKNMBR  = $A5E5 = 42469          CPM22.asm:3698
BLKSHFT  = $A5C3 = 42435          CPM22.asm:3672
BOOT     = $A600 = 42496          CPM22.asm:3718 (unused)
BS       = $0008 =     8          CPM22.asm:28
CBASE    = $9000 = 36864          CPM22.asm:45
CCPSTACK = $97AB = 38827          CPM22.asm:1210
CDRIVE   = $97EF = 38895          CPM22.asm:1221
CHARBUF  = $9B0E = 39694          CPM22.asm:1689
CHECK    = $9230 = 37424          CPM22.asm:398
CHECKDIR = $9D9E = 40350          CPM22.asm:2202
CHECKSUM = $9CF7 = 40183          CPM22.asm:2041
CHGDRV   = $97F0 = 38896          CPM22.asm:1222
CHGNAM1  = $A027 = 40999          CPM22.asm:2714
CHGNAMES = $A016 = 40982          CPM22.asm:2706
CHKBLK   = $9C84 = 40068          CPM22.asm:1948
CHKCHAR  = $9914 = 39188          CPM22.asm:1357
CHKCON   = $91C2 = 37314          CPM22.asm:323
CHKDIR1  = $9DC4 = 40388          CPM22.asm:2222
CHKNMBR  = $9D8C = 40332          CPM22.asm:2175
CHKROFL  = $9D44 = 40260          CPM22.asm:2105
CHKSUM1  = $9CFD = 40189          CPM22.asm:2044
CHKVECT  = $A5BD = 42429          CPM22.asm:3666
CHKWPRT  = $9D54 = 40276          CPM22.asm:2116
CKBITMAP = $9E35 = 40501          CPM22.asm:2316
CKBMAP1  = $9E56 = 40534          CPM22.asm:2351
CKCON1   = $9942 = 39234          CPM22.asm:1387
CKCON2   = $9945 = 39237          CPM22.asm:1388
CKCONSOL = $9923 = 39203          CPM22.asm:1373
CKFILPOS = $9DF5 = 40437          CPM22.asm:2265
CKROF1   = $9D47 = 40263          CPM22.asm:2106
CKSUMTBL = $A5EC = 42476          CPM22.asm:3706
CLEARBUF = $9358 = 37720          CPM22.asm:598
CLEARS2  = $9D72 = 40306          CPM22.asm:2146
CLOSE    = $90DA = 37082          CPM22.asm:138
CLOSEFIL = $A4A5 = 42149          CPM22.asm:3454
CLOSEFLG = $A5D2 = 42450          CPM22.asm:3683
CLOSEIT  = $A0A2 = 41122          CPM22.asm:2800
CLOSEIT1 = $A0CD = 41165          CPM22.asm:2820
CLOSEIT2 = $A0DB = 41179          CPM22.asm:2828
CLOSEIT3 = $A0E1 = 41185          CPM22.asm:2832
CLOSEIT4 = $A0E8 = 41192          CPM22.asm:2835
CLOSEIT5 = $A0FD = 41213          CPM22.asm:2848
CLOSEIT6 = $A117 = 41239          CPM22.asm:2866
CLOSEIT7 = $A11F = 41247          CPM22.asm:2869
CMDADR   = $93C1 = 37825          CPM22.asm:670
CMDTBL   = $9310 = 37648          CPM22.asm:552
CMMND1   = $9382 = 37762          CPM22.asm:631
CMMND2   = $9398 = 37784          CPM22.asm:642
CNTRLC   = $0003 =     3          CPM22.asm:26
CNTRLE   = $0005 =     5          CPM22.asm:27
CNTRLP   = $0010 =    16          CPM22.asm:33
CNTRLR   = $0012 =    18          CPM22.asm:34
CNTRLS   = $0013 =    19          CPM22.asm:35
CNTRLU   = $0015 =    21          CPM22.asm:36
CNTRLX   = $0018 =    24          CPM22.asm:37
CNTRLZ   = $001A =    26          CPM22.asm:38
COMBLK   = $9C77 = 40055          CPM22.asm:1939
COMFILE  = $9783 = 38787          CPM22.asm:1192
COMMAND  = $935C = 37724          CPM22.asm:608
COMPRAND = $A3A5 = 41893          CPM22.asm:3273
CONIN    = $A609 = 42505          CPM22.asm:3721
CONOUT   = $A60C = 42508          CPM22.asm:3722
CONST    = $A606 = 42502          CPM22.asm:3720
CONVERT  = $9260 = 37472          CPM22.asm:446
CONVFST  = $925E = 37470          CPM22.asm:440
CONVRT1  = $9289 = 37513          CPM22.asm:469
CONVRT2  = $9290 = 37520          CPM22.asm:472
CONVRT3  = $9296 = 37526          CPM22.asm:479
CONVRT4  = $9298 = 37528          CPM22.asm:480
CONVRT5  = $92A9 = 37545          CPM22.asm:487
CONVRT6  = $92AB = 37547          CPM22.asm:489
CONVRT7  = $92AF = 37551          CPM22.asm:491
CONVRT8  = $92B9 = 37561          CPM22.asm:495
COUNTER  = $A5D8 = 42456          CPM22.asm:3689
CR       = $000D =    13          CPM22.asm:32
CREATE   = $9109 = 37129          CPM22.asm:188
CRLF     = $9098 = 37016          CPM22.asm:80
CURPOS   = $9B0C = 39692          CPM22.asm:1687
DE2HL    = $9B4F = 39759          CPM22.asm:1718
DE2HL1   = $9B50 = 39760          CPM22.asm:1719
DECODE   = $93F8 = 37880          CPM22.asm:697
DECODE1  = $9408 = 37896          CPM22.asm:703
DECODE2  = $942A = 37930          CPM22.asm:723 (unused)
DECODE3  = $9433 = 37939          CPM22.asm:728
DECODE4  = $943A = 37946          CPM22.asm:732 (unused)
DEFDMA   = $9DDA = 40410          CPM22.asm:2240
DEL      = $007F =   127          CPM22.asm:39
DELBATCH = $91DD = 37341          CPM22.asm:348
DELETE   = $90EF = 37103          CPM22.asm:159
DELFILE  = $A4D7 = 42199          CPM22.asm:3485
DIRBUF   = $A5B9 = 42425          CPM22.asm:3664
DIRC1    = $9AE0 = 39648          CPM22.asm:1645
DIRCIO   = $9AD4 = 39636          CPM22.asm:1639
DIRDMA   = $9DE0 = 40416          CPM22.asm:2245
DIRDMA1  = $9DE3 = 40419          CPM22.asm:2250
DIRECT   = $9477 = 38007          CPM22.asm:794
DIRECT1  = $9488 = 38024          CPM22.asm:801
DIRECT2  = $948F = 38031          CPM22.asm:805
DIRECT3  = $9498 = 38040          CPM22.asm:809
DIRECT4  = $94CC = 38092          CPM22.asm:836
DIRECT5  = $94D4 = 38100          CPM22.asm:839
DIRECT6  = $94D9 = 38105          CPM22.asm:841
DIRECT7  = $950E = 38158          CPM22.asm:865
DIRECT8  = $950F = 38159          CPM22.asm:866
DIRECT9  = $951B = 38171          CPM22.asm:870
DIRREAD  = $9DD4 = 40404          CPM22.asm:2235
DIRSIZE  = $A5C8 = 42440          CPM22.asm:3676
DIRWRITE = $9DC6 = 40390          CPM22.asm:2227
DISKPB   = $A5BB = 42427          CPM22.asm:3665
DISKRO   = $98E1 = 39137          CPM22.asm:1318
DMASET   = $91D8 = 37336          CPM22.asm:343
DOREAD   = $9BB2 = 39858          CPM22.asm:1789
DOWRITE  = $9BB8 = 39864          CPM22.asm:1794
DRECT63  = $94F7 = 38135          CPM22.asm:855
DRECT65  = $94F9 = 38137          CPM22.asm:856
DSELECT  = $9454 = 37972          CPM22.asm:764
DSKSEL   = $90BD = 37053          CPM22.asm:112
DSKSIZE  = $A5C6 = 42438          CPM22.asm:3675
EMPTYFCB = $A5AC = 42412          CPM22.asm:3651
END      = $A633 = 42547          CPM22.asm:3739 (unused)
ENTRY    = $0005 =     5          CPM22.asm:19
ENTRY1   = $90C3 = 37059          CPM22.asm:119
ENTRY2   = $90F4 = 37108          CPM22.asm:165
EPARAM   = $A5D6 = 42454          CPM22.asm:3687
ERAFIL1  = $9FA4 = 40868          CPM22.asm:2592
ERAFILE  = $9F9C = 40860          CPM22.asm:2589
ERASE    = $951F = 38175          CPM22.asm:879
ERASE1   = $9542 = 38210          CPM22.asm:894
ERROR1   = $9899 = 39065          CPM22.asm:1296
ERROR2   = $98A5 = 39077          CPM22.asm:1302
ERROR3   = $98AB = 39083          CPM22.asm:1305
ERROR4   = $98B1 = 39089          CPM22.asm:1308
ERROR5   = $98B4 = 39092          CPM22.asm:1310
EXISTS   = $9682 = 38530          CPM22.asm:1056
EXTBLK   = $9C5E = 40030          CPM22.asm:1920
EXTBLK1  = $9C71 = 40049          CPM22.asm:1930
EXTMASK  = $A5C5 = 42437          CPM22.asm:3674
EXTRACT  = $944B = 37963          CPM22.asm:754
FBASE    = $9806 = 38918          CPM22.asm:1240 (unused)
FBASE1   = $9811 = 38929          CPM22.asm:1252
FCB      = $97CD = 38861          CPM22.asm:1219
FCB2HL   = $9D5E = 40286          CPM22.asm:2124
FCBPOS   = $A5E9 = 42473          CPM22.asm:3700
FCBSET   = $9FFD = 40957          CPM22.asm:2684
FCREATE  = $A4EC = 42220          CPM22.asm:3502
FF       = $000C =    12          CPM22.asm:31 (unused)
FILEPOS  = $A5EA = 42474          CPM22.asm:3701
FILERO   = $98DC = 39132          CPM22.asm:1317
FILESIZE = $A54D = 42317          CPM22.asm:3576
FINDFST  = $9F18 = 40728          CPM22.asm:2509
FINDNXT  = $9F2D = 40749          CPM22.asm:2522
FNDNXT1  = $9F4A = 40778          CPM22.asm:2535
FNDNXT2  = $9F53 = 40787          CPM22.asm:2539
FNDNXT3  = $9F73 = 40819          CPM22.asm:2555
FNDNXT4  = $9F7C = 40828          CPM22.asm:2564
FNDNXT5  = $9F83 = 40835          CPM22.asm:2569
FNDNXT6  = $9F94 = 40852          CPM22.asm:2582
FNDSPA1  = $9FC0 = 40896          CPM22.asm:2622
FNDSPA2  = $9FD1 = 40913          CPM22.asm:2645
FNDSPA3  = $9FEC = 40940          CPM22.asm:2666
FNDSPA4  = $9FF4 = 40948          CPM22.asm:2676
FNDSPACE = $9FBE = 40894          CPM22.asm:2616
FNDSTAT  = $A5D4 = 42452          CPM22.asm:3685
FUNCTNS  = $9847 = 38983          CPM22.asm:1287
GETALOC  = $A511 = 42257          CPM22.asm:3530
GETBACK  = $9786 = 38790          CPM22.asm:1198
GETBACK1 = $9789 = 38793          CPM22.asm:1199
GETBLK1  = $9C45 = 40005          CPM22.asm:1898
GETBLK2  = $9C53 = 40019          CPM22.asm:1907
GETBLK3  = $9C5C = 40028          CPM22.asm:1912
GETBLOCK = $9C3E = 39998          CPM22.asm:1895
GETCHAR  = $98FB = 39163          CPM22.asm:1335
GETCON   = $9AC8 = 39624          CPM22.asm:1627
GETCRNT  = $A504 = 42244          CPM22.asm:3519
GETCSTS  = $9AFE = 39678          CPM22.asm:1672
GETDSK   = $91D0 = 37328          CPM22.asm:334
GETECHO  = $9906 = 39174          CPM22.asm:1344
GETEMPTY = $A124 = 41252          CPM22.asm:2876
GETEXT   = $92C0 = 37568          CPM22.asm:502
GETEXT1  = $92C8 = 37576          CPM22.asm:506
GETEXT2  = $92D9 = 37593          CPM22.asm:513
GETEXT3  = $92DB = 37595          CPM22.asm:515
GETEXT4  = $92DF = 37599          CPM22.asm:517
GETEXT5  = $92E9 = 37609          CPM22.asm:521
GETEXT6  = $92F0 = 37616          CPM22.asm:525
GETEXT7  = $92F2 = 37618          CPM22.asm:526
GETEXT8  = $9301 = 37633          CPM22.asm:538
GETEXT9  = $9309 = 37641          CPM22.asm:543
GETFST   = $A4AB = 42155          CPM22.asm:3461
GETFST1  = $A4C2 = 42178          CPM22.asm:3472
GETINP   = $9139 = 37177          CPM22.asm:239
GETINP1  = $9196 = 37270          CPM22.asm:295
GETINP2  = $91A7 = 37287          CPM22.asm:304
GETINP3  = $91AB = 37291          CPM22.asm:306
GETINP4  = $91BA = 37306          CPM22.asm:315
GETIOB   = $9AED = 39661          CPM22.asm:1653
GETLOG   = $A4FE = 42238          CPM22.asm:3514
GETMT1   = $A146 = 41286          CPM22.asm:2892
GETNEXT  = $A15A = 41306          CPM22.asm:2906
GETNXT   = $A4C8 = 42184          CPM22.asm:3477
GETPARM  = $A526 = 42278          CPM22.asm:3547
GETPRM1  = $A529 = 42281          CPM22.asm:3548
GETRDR   = $9ACE = 39630          CPM22.asm:1632
GETROV   = $A517 = 42263          CPM22.asm:3535
GETS2    = $9D69 = 40297          CPM22.asm:2138
GETSETUC = $9115 = 37141          CPM22.asm:204
GETUSER  = $A52D = 42285          CPM22.asm:3555
GETUSR   = $9113 = 37139          CPM22.asm:199
GETVER   = $A47E = 42110          CPM22.asm:3431
GETWPRT  = $9D1E = 40222          CPM22.asm:2078
GOBACK   = $A574 = 42356          CPM22.asm:3611
GOBACK1  = $A591 = 42385          CPM22.asm:3623
GTNEXT1  = $A183 = 41347          CPM22.asm:2926
GTNEXT2  = $A18E = 41358          CPM22.asm:2935
GTNEXT3  = $A1AC = 41388          CPM22.asm:2946
GTNEXT4  = $A1AF = 41391          CPM22.asm:2947
GTNEXT5  = $A1B6 = 41398          CPM22.asm:2954
HL2DE    = $9442 = 37954          CPM22.asm:744
HOME     = $A618 = 42520          CPM22.asm:3726
HOMEDRV  = $9BA1 = 39841          CPM22.asm:1775
INBUFF   = $9006 = 36870          CPM22.asm:52
INPOINT  = $9088 = 37000          CPM22.asm:60
IOBYTE   = $0003 =     3          CPM22.asm:17
IOERR1   = $9B05 = 39685          CPM22.asm:1682
IORET    = $9BBB = 39867          CPM22.asm:1795
JUMPHL   = $9B4A = 39754          CPM22.asm:1710
LF       = $000A =    10          CPM22.asm:30
LIST     = $A60F = 42511          CPM22.asm:3723
LOGICAL  = $9C8A = 40074          CPM22.asm:1959
LOGICL1  = $9C90 = 40080          CPM22.asm:1961
LOGIN    = $A5AF = 42415          CPM22.asm:3653
LOGINDRV = $A421 = 42017          CPM22.asm:3375
LOGOFF   = $A553 = 42323          CPM22.asm:3585
LOGSECT  = $A5E7 = 42471          CPM22.asm:3699
MEM      = $002B =    43          CPM22.asm:15
MODE     = $A5D5 = 42453          CPM22.asm:3686
MOREFLS  = $9D7F = 40319          CPM22.asm:2162
MOVE3    = $9440 = 37952          CPM22.asm:740
MOVECD   = $9129 = 37161          CPM22.asm:221
MOVEDIR  = $9DE9 = 40425          CPM22.asm:2257
MOVEWORD = $A094 = 41108          CPM22.asm:2783
NAMEPNT  = $908A = 37002          CPM22.asm:61
NBYTES   = $97F1 = 38897          CPM22.asm:1223
NEWLINE  = $99B1 = 39345          CPM22.asm:1469
NEWLN1   = $99B9 = 39353          CPM22.asm:1472
NFUNCTS  = $0029 =    41          CPM22.asm:1268
NOFILE   = $93F0 = 37872          CPM22.asm:690
NONBLANK = $924F = 37455          CPM22.asm:422
NONE     = $93EA = 37866          CPM22.asm:688
NOSPACE  = $9607 = 38407          CPM22.asm:998
NUMCMDS  = $0006 =     6          CPM22.asm:551
NXENT1   = $9E19 = 40473          CPM22.asm:2295
NXENT2   = $9E20 = 40480          CPM22.asm:2298
NXENTRY  = $9E05 = 40453          CPM22.asm:2287
OFFSET   = $A5CE = 42446          CPM22.asm:3679
OLDDRV   = $A5DF = 42463          CPM22.asm:3693
OPEN     = $90CB = 37067          CPM22.asm:126
OPENFCB  = $90D0 = 37072          CPM22.asm:131
OPENFIL  = $A49C = 42140          CPM22.asm:3448
OPENIT   = $A051 = 41041          CPM22.asm:2740
OPENIT1  = $A05A = 41050          CPM22.asm:2744
OPENIT2  = $A08B = 41099          CPM22.asm:2772
OUTCHAR  = $9948 = 39240          CPM22.asm:1395
OUTCHR1  = $9962 = 39266          CPM22.asm:1409
OUTCHR2  = $9979 = 39289          CPM22.asm:1425
OUTCON   = $9990 = 39312          CPM22.asm:1446
OUTCON1  = $9996 = 39318          CPM22.asm:1449
OUTCRLF  = $99C9 = 39369          CPM22.asm:1482
OUTFLAG  = $9B0A = 39690          CPM22.asm:1685
PARAMS   = $9B43 = 39747          CPM22.asm:1701
PATTRN1  = $9328 = 37672          CPM22.asm:562
PATTRN2  = $9800 = 38912          CPM22.asm:1232
PLINE    = $90A7 = 37031          CPM22.asm:93
PLINE2   = $90AC = 37036          CPM22.asm:96
POSITION = $A303 = 41731          CPM22.asm:3150
POSITN1  = $A307 = 41735          CPM22.asm:3155
POSITN2  = $A347 = 41799          CPM22.asm:3201
POSITN3  = $A37F = 41855          CPM22.asm:3233
POSITN4  = $A384 = 41860          CPM22.asm:3239
POSITN5  = $A38B = 41867          CPM22.asm:3246
PRINT    = $908C = 37004          CPM22.asm:66
PRINTB   = $9092 = 37010          CPM22.asm:72
PRSTAT   = $A62D = 42541          CPM22.asm:3733 (unused)
PRTERR   = $98E5 = 39141          CPM22.asm:1322
PRTFLAG  = $9B0D = 39693          CPM22.asm:1688
PRTMESG  = $99D3 = 39379          CPM22.asm:1489
PRTSTR   = $9AF8 = 39672          CPM22.asm:1665
PUNCH    = $A612 = 42514          CPM22.asm:3724
PUTDMA   = $A50A = 42250          CPM22.asm:3524
RANSIZ1  = $A3E4 = 41956          CPM22.asm:3329
RANSIZ2  = $A406 = 41990          CPM22.asm:3351
RANSIZ3  = $A40C = 41996          CPM22.asm:3353
RANSIZE  = $A3D2 = 41938          CPM22.asm:3318
RDBUF1   = $99EF = 39407          CPM22.asm:1508
RDBUF10  = $9A70 = 39536          CPM22.asm:1570
RDBUF11  = $9A78 = 39544          CPM22.asm:1576
RDBUF12  = $9A8A = 39562          CPM22.asm:1588
RDBUF13  = $9A99 = 39577          CPM22.asm:1595
RDBUF14  = $9AA6 = 39590          CPM22.asm:1603
RDBUF15  = $9AA9 = 39593          CPM22.asm:1606
RDBUF16  = $9ABD = 39613          CPM22.asm:1618
RDBUF17  = $9AC1 = 39617          CPM22.asm:1620
RDBUF2   = $99F1 = 39409          CPM22.asm:1510
RDBUF3   = $9A16 = 39446          CPM22.asm:1527
RDBUF4   = $9A26 = 39462          CPM22.asm:1536
RDBUF5   = $9A37 = 39479          CPM22.asm:1544
RDBUF6   = $9A48 = 39496          CPM22.asm:1553
RDBUF7   = $9A4E = 39502          CPM22.asm:1556
RDBUF8   = $9A5F = 39519          CPM22.asm:1563
RDBUF9   = $9A6B = 39531          CPM22.asm:1568
RDBUFF   = $99E1 = 39393          CPM22.asm:1501
RDERR    = $93DF = 37855          CPM22.asm:684
RDERROR  = $93D9 = 37849          CPM22.asm:682
RDRANDOM = $A541 = 42305          CPM22.asm:3566
RDREC    = $90F9 = 37113          CPM22.asm:172
RDSEQ    = $A1BC = 41404          CPM22.asm:2959
RDSEQ1   = $A1C1 = 41409          CPM22.asm:2961
RDSEQ2   = $A1E6 = 41446          CPM22.asm:2976
RDSEQ3   = $A1FB = 41467          CPM22.asm:2986
RDWRTFLG = $A5D3 = 42451          CPM22.asm:3684
READ     = $A627 = 42535          CPM22.asm:3731
READER   = $A615 = 42517          CPM22.asm:3725
READFCB  = $90FE = 37118          CPM22.asm:177
READRAN  = $A393 = 41875          CPM22.asm:3253
READSEQ  = $A4E0 = 42208          CPM22.asm:3492
RELBLOCK = $A5D7 = 42455          CPM22.asm:3688
RENAM    = $910E = 37134          CPM22.asm:194
RENAME   = $9610 = 38416          CPM22.asm:1006
RENAME1  = $963F = 38463          CPM22.asm:1024
RENAME2  = $9659 = 38489          CPM22.asm:1038
RENAME3  = $965E = 38494          CPM22.asm:1041 (unused)
RENAME4  = $966D = 38509          CPM22.asm:1049
RENAME5  = $9673 = 38515          CPM22.asm:1051
RENAME6  = $9679 = 38521          CPM22.asm:1053
RENFILE  = $A4F5 = 42229          CPM22.asm:3508
RESDSK   = $90B8 = 37048          CPM22.asm:107
RESETDR  = $9466 = 37990          CPM22.asm:778
RODISK   = $980D = 38925          CPM22.asm:1246
ROFILE   = $980F = 38927          CPM22.asm:1247
RSTDSK   = $A483 = 42115          CPM22.asm:3436
RTN      = $9B04 = 39684          CPM22.asm:1678
RTNCODE  = $97EE = 38894          CPM22.asm:1220
SAMEXT   = $9F07 = 40711          CPM22.asm:2490
SAVATR1  = $A040 = 41024          CPM22.asm:2730
SAVE     = $95AD = 38317          CPM22.asm:951
SAVE1    = $95D4 = 38356          CPM22.asm:969
SAVE2    = $95F1 = 38385          CPM22.asm:987
SAVE3    = $95FB = 38395          CPM22.asm:994
SAVE4    = $9601 = 38401          CPM22.asm:996
SAVEATTR = $A03B = 41019          CPM22.asm:2728
SAVEFCB  = $A5D9 = 42457          CPM22.asm:3690
SAVEXT   = $A5E2 = 42466          CPM22.asm:3696
SAVNREC  = $A5E3 = 42467          CPM22.asm:3697
SAVNXT   = $A5E1 = 42465          CPM22.asm:3695
SCRATCH1 = $A5B3 = 42419          CPM22.asm:3658
SCRATCH2 = $A5B5 = 42421          CPM22.asm:3659
SCRATCH3 = $A5B7 = 42423          CPM22.asm:3660
SEARCH   = $932E = 37678          CPM22.asm:570
SEARCH1  = $9333 = 37683          CPM22.asm:572
SEARCH2  = $933C = 37692          CPM22.asm:577
SEARCH3  = $934F = 37711          CPM22.asm:589
SEARCH4  = $9354 = 37716          CPM22.asm:592
SECTORS  = $A5C1 = 42433          CPM22.asm:3671
SECTRN   = $A630 = 42544          CPM22.asm:3734
SELDSK   = $A61B = 42523          CPM22.asm:3727
SELECT   = $9B59 = 39769          CPM22.asm:1729
SELECT1  = $9B9D = 39837          CPM22.asm:1769
SETATTR  = $A51D = 42269          CPM22.asm:3540
SETBIT   = $9D0B = 40203          CPM22.asm:2061
SETCDRV  = $911A = 37146          CPM22.asm:209
SETDIR   = $9D9C = 40348          CPM22.asm:2195
SETDMA   = $A624 = 42532          CPM22.asm:3730
SETDSK   = $A445 = 42053          CPM22.asm:3396
SETEXT   = $9CA6 = 40102          CPM22.asm:1976
SETFILE  = $9E6B = 40555          CPM22.asm:2380
SETFL1   = $9E75 = 40565          CPM22.asm:2385
SETFL2   = $9E88 = 40584          CPM22.asm:2397
SETFL3   = $9E8E = 40590          CPM22.asm:2403
SETFL4   = $9E9D = 40605          CPM22.asm:2412
SETHLDE  = $9CAE = 40110          CPM22.asm:1984
SETIOB   = $9AF3 = 39667          CPM22.asm:1658
SETNREC  = $9CD2 = 40146          CPM22.asm:2010
SETRAN   = $A40E = 41998          CPM22.asm:3359
SETS2B7  = $9D78 = 40312          CPM22.asm:2152
SETSEC   = $A621 = 42529          CPM22.asm:3729
SETSTAT  = $9B01 = 39681          CPM22.asm:1677
SETTRK   = $A61E = 42526          CPM22.asm:3728
SETUSER  = $A53B = 42299          CPM22.asm:3560
SHIFTL   = $9D04 = 40196          CPM22.asm:2052
SHIFTL1  = $9D05 = 40197          CPM22.asm:2053
SHIFTR   = $9CEA = 40170          CPM22.asm:2026
SHIFTR1  = $9CEB = 40171          CPM22.asm:2027
SHOWIT   = $997F = 39295          CPM22.asm:1433
SLCTERR  = $9B47 = 39751          CPM22.asm:1706
SPACE    = $90A2 = 37026          CPM22.asm:87
SRCHFCB  = $90E9 = 37097          CPM22.asm:154
SRCHFST  = $90DF = 37087          CPM22.asm:144
SRCHNXT  = $90E4 = 37092          CPM22.asm:149
STARTING = $9B0B = 39691          CPM22.asm:1686
STATUS   = $9B45 = 39749          CPM22.asm:1702
STBITMAP = $9E5C = 40540          CPM22.asm:2360
STBMAP1  = $9E64 = 40548          CPM22.asm:2371
STDDMA   = $91D5 = 37333          CPM22.asm:339
STFILPOS = $9DFE = 40446          CPM22.asm:2275
STKAREA  = $9B41 = 39745          CPM22.asm:1697
STNREC1  = $9CDE = 40158          CPM22.asm:2015
STRDATA  = $9CBB = 40123          CPM22.asm:1994
STSTATUS = $9F01 = 40705          CPM22.asm:2482
SUBHL    = $9D95 = 40341          CPM22.asm:2185
SYNERR   = $9209 = 37385          CPM22.asm:377
SYNERR1  = $920F = 37391          CPM22.asm:379
SYNERR2  = $9222 = 37410          CPM22.asm:389
TAB      = $0009 =     9          CPM22.asm:29
TBASE    = $0100 =   256          CPM22.asm:22
TBUFF    = $0080 =   128          CPM22.asm:21
TDRIVE   = $0004 =     4          CPM22.asm:18
TFCB     = $005C =    92          CPM22.asm:20
TRKSEC   = $9BC3 = 39875          CPM22.asm:1803
TRKSEC1  = $9BD1 = 39889          CPM22.asm:1812
TRKSEC2  = $9BE4 = 39908          CPM22.asm:1825
TRKSEC3  = $9BFA = 39930          CPM22.asm:1841
TRKSEC4  = $9C0F = 39951          CPM22.asm:1858
TYPE     = $955D = 38237          CPM22.asm:908
TYPE1    = $9574 = 38260          CPM22.asm:916
TYPE2    = $9577 = 38263          CPM22.asm:917 (unused)
TYPE3    = $9587 = 38279          CPM22.asm:926
TYPE4    = $95A0 = 38304          CPM22.asm:939
TYPE5    = $95A7 = 38311          CPM22.asm:942
UNKNOWN  = $96A5 = 38565          CPM22.asm:1080
UNKWN0   = $9771 = 38769          CPM22.asm:1188
UNKWN1   = $96C4 = 38596          CPM22.asm:1095
UNKWN2   = $96CD = 38605          CPM22.asm:1099 (unused)
UNKWN3   = $96E1 = 38625          CPM22.asm:1110
UNKWN4   = $9701 = 38657          CPM22.asm:1129
UNKWN5   = $9730 = 38704          CPM22.asm:1150
UNKWN6   = $973E = 38718          CPM22.asm:1160
UNKWN7   = $9743 = 38723          CPM22.asm:1162
UNKWN8   = $974F = 38735          CPM22.asm:1170
UNKWN9   = $976B = 38763          CPM22.asm:1186
UPDATE   = $A001 = 40961          CPM22.asm:2691
UPDATE1  = $A010 = 40976          CPM22.asm:2699
UPPER    = $9130 = 37168          CPM22.asm:228
USER     = $968E = 38542          CPM22.asm:1064
USERDMA  = $A5B1 = 42417          CPM22.asm:3654
USERNO   = $9B41 = 39745          CPM22.asm:1699
USRSTACK = $9B0F = 39695          CPM22.asm:1693
VERIFY   = $91F5 = 37365          CPM22.asm:363
VERIFY1  = $91FD = 37373          CPM22.asm:366
WBOOT    = $A603 = 42499          CPM22.asm:3719
WRITE    = $A62A = 42538          CPM22.asm:3732
WRITERAN = $A39C = 41884          CPM22.asm:3260
WRTPRT   = $A5AD = 42413          CPM22.asm:3652
WRTPRTD  = $9D2C = 40236          CPM22.asm:2088
WRTREC   = $9104 = 37124          CPM22.asm:183
WRTSEQ   = $A4E6 = 42214          CPM22.asm:3497
WTRANDOM = $A547 = 42311          CPM22.asm:3571
WTSEQ    = $A1FE = 41470          CPM22.asm:2990
WTSEQ1   = $A203 = 41475          CPM22.asm:2992
WTSEQ10  = $A2D2 = 41682          CPM22.asm:3107
WTSEQ11  = $A2FE = 41726          CPM22.asm:3131
WTSEQ12  = $A300 = 41728          CPM22.asm:3132
WTSEQ2   = $A23B = 41531          CPM22.asm:3015
WTSEQ3   = $A248 = 41544          CPM22.asm:3021
WTSEQ4   = $A264 = 41572          CPM22.asm:3033
WTSEQ5   = $A26C = 41580          CPM22.asm:3040
WTSEQ6   = $A26E = 41582          CPM22.asm:3041
WTSEQ7   = $A28C = 41612          CPM22.asm:3064
WTSEQ8   = $A29A = 41626          CPM22.asm:3071
WTSEQ9   = $A2BB = 41659          CPM22.asm:3091
WTSEQ99  = $A2DF = 41695          CPM22.asm:3118 (unused)
WTSPECL  = $A59B = 42395          CPM22.asm:3637
XLATE    = $A5D0 = 42448          CPM22.asm:3680
YESNO    = $9552 = 38226          CPM22.asm:900
_8080_   = $0001 =     1          :1 (unused)
_HALT    = $93CF = 37839          CPM22.asm:675
_end     = $A633 = 42547          CPM22.asm:42 (unused)
_size    = $1633 =  5683          CPM22.asm:42 (unused)


total time: 0.0641 sec.
1 error
