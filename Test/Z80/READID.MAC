
	; added 2015-01-03 by Kio
	; this file is iso latin-1 -- Brazilian language
	; in Zeile 653 fehlt die Instruction, evtl. LD oder auch OR oder ADD ...
	org 08050h-7	



        ASEG
        .phase  08050h-7

        ;header for .BIN file
        DB      0FEh
        DW      08050h
        DW      ENDOFCODE-1
        DW      START

START:   

; --------------------- BEGIN | DECLARATION OF CONSTANTS
DEBUG_REG			EQU 0B000H
GUIADDR             EQU 0A000H    
BUFFERADDR			EQU 0B000H
BUFFERIX			EQU 0BD00H
BUFFERDATA			EQU 0AD00H
; --------------------- END | DECLARATION OF CONSTANTS	
	
			JP CONT
	
; --------------------- BEGIN | DECLARATION OF VARIABLES	
STR_TOSHIBA1:		DB 13,3AH,0,7FH,0E6H,0C0H,0FEH,80H,20H,0F7H,7EH,32H,0,7FH
STR_TOSHIBA1M:		DB 13,0FFH,0,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0FFH,0,0FFH
STR_TOSHIBA2:		DB 9,3EH,2,32H,0,7FH,3CH,32H,0,7FH
STR_TOSHIBA2M:		DB 9,0FFH,0FFH,0FFH,0,0FFH,0FFH,0FFH,0,0FFH
STR_TOSHIBA3:		DB 6,3EH,4,32H,0,7FH,0C9H
STR_TOSHIBA3M:		DB 6,0FFH,0FFH,0FFH,0,0FFH,0FFH
STR_PHILIPS:		DB 13,0E5H,0D5H,0C5H,1,0,7FH,0,0,0,0,32H,0,7FH
STR_PHILIPSM:		DB 13,0FFH,0FFH,0FFH,0FFH,0,0FFH,0,0,0,0,0FFH,0,0FFH
STR_PHILIPS1:		DB 13,0E5H,0D5H,0C5H,0,0,0,0,1,0,7FH,32H,0,7FH
STR_PHILIPS1M:		DB 13,0FFH,0FFH,0FFH,0,0,0,0,0FFH,0,0FFH,0FFH,0,0FFH
STR_PHIL_NAT:		DB 17,0E5H,0D5H,0C5H,1,0,7FH,0,0,0,0,0,0,0,0,32H,0,7FH
STR_PHIL_NATM:		DB 17,0FFH,0FFH,0FFH,0FFH,0,0FFH,0,0,0,0,0,0,0,0,0FFH,0,0FFH
STR_PHILIPS2:		DB 3,32H,0FDH,7FH
STR_PHILIPS2M:		DB 3,0FFH,0FFH,0FFH
STR_NATIONAL:		DB 5,32H,0,7FH,0E3H,0E3H
STR_NATIONALM:		DB 5,0FFH,0,0FFH,0FFH,0FFH
STR_MICROSOL:		DB 4,03EH,0D0H,0D3H,0D0H
STR_MICROSOLM:		DB 4,0FFH,0FFH,0FFH,0FFH
INTERFACE:			DB 0
REG_CMD:			DW 0
REG_TRACK:			DW 0
REG_SECTOR:			DW 0
REG_DATA:			DW 0
REG_SIDE:			DW 0
REG_DRIVE:			DW 0
REG_STATUS:			DW 0
REG_STATUS_2:		DW 0
REG_RESULT_STATUS:	DW 0
REG_CONTROL0:		DW 0
REG_CONTROL1:		DW 0	
STR_WAIT:			DB 'IDENTIFYING FDC... WAIT!,'
STR_CHIP:			DB 'CHIPSET:                  ,'
SLOT:				DB 0
SLOT2:				DW 0
HEXNUMBERS:			DB '0123456789ABCDEF'
INTERDISCO:			DB 0
SLOTS:				DW 0
SLOTINIT:			DB 0
EMULPOS:			DW 0
EMULADDR:			DW 0
EMULBYTES:			DB 0,0,1,2,0AAH,0AAH
EMULSET:			DB 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,0	
QTDSETORES: 		DB 0
NTRILHAS: 			DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NLADOS:			 	DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NSETORES: 			DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
NTAMANHOS: 			DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CRC1: 				DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
CRC2: 				DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
STATUSCODE:			DW 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
DRIVELADO:			DW 0 
TATUAL:				DB 0
CMD_SEEK:			DB 3,0FH,0,0
CMD_READ:			DB 9,46H,0,0,0,8,2,9,50H,0FFH
CMD_SENSE_INT:		DB 1,8
CMD_SENSE_DEV:		DB 2,4,0
CMD_RECALIBRATE:	DB 2,7,0	
CMD_INVALID:		DB 1,0
CMD_READ_ID:		DB 2,4AH,0
CMD_READ_DIAG:		DB 2,42H,0
CMD_SPECIFY:		DB 3,3,0FFH,0FFH
STR_MODE1:			DB 'EMULATION,'
STR_MODE2:			DB 'REAL     ,'
STR_PARENTESES:		DB '[  ],'
MODE:				DB 0
DESLOC:				DB 0
DESLOCMAX:			DB 0
LEITURAS:			DB 0
PNUM:				DW 0
PEND:				DW 0
TEMPADDR:			DW 0
FLAGREAD:			DB 0
PHELPH:				DW 0
MSGHELP:			DB ' [M]    SWITCH MODE',13
					DB ' [',2AH,']    INCREMENT TRACK',13
					DB ' [',2BH,']    DECREMENT TRACK',13
					DB ' [',28H,']    SCROLL UP DATA',13
					DB ' [',29H,']    SCROLL DOWN DATA',13
					DB ' [1]    SWITCH TO SIDE 0',13
					DB ' [2]    SWITCH TO SIDE 1',13,13
					DB ' [TR]   TRACK NUMBER',13
					DB ' [SD]   SIDE NUMBER',13
					DB ' [ST]   SECTOR NUMBER',13
					DB ' [SS]   SECTOR SIZE',13
					DB ' [C1]   CRC 1',13
					DB ' [C2]   CRC 2',13
					DB ' [CD]   CRC ERROR IN DATA FIELD',13
					DB ' [CI]   CRC ERROR IN ID FIELD',13
					DB ' [DD]   DAM DELETED',13
					DB ' [FS]   SECTOR WITH FALSE SIZE',13,13	
					DB '   PRESS ;any;key; TO RETURN',0
; --------------------- END | DECLARATION OF VARIABLES

CONT:   	IN A,(0A8H)
			AND 0F0H
			OUT(0A8H),A
			LD A,(0FFFFH)
			CPL
			AND 0F0H
			LD (0FFFFH),A
			LD A,40
			LD (0F3AEH),A
			LD A,15
			LD (0F3E9H),A
			LD A,1
			LD (0F3EAH),A		
			CALL 6CH
			CALL 0CCH
			LD HL,489
			LD DE,STR_WAIT
			CALL PRINT	
			LD HL,GUIADDR + 400H
			LD DE,800H
			LD BC,800H
			CALL WVRAM
			XOR A
			LD (MODE),A
			LD A,30
			LD (LEITURAS),A
COMECO:		LD HL,0100H
			LD (DRIVELADO),HL
			CALL RESTORE
			LD DE,EMULSET 
			LD (EMULPOS),DE		
			CALL GETINT
			CALL 6CH
			DI
			IN A,(0A8H)
			AND 0F0H
			LD B,A
			RRCA
			RRCA
			RRCA
			RRCA
			OR B
			OUT(0A8H),A
			LD A,(0FFFFH)
			CPL
			AND 0F0H
			LD B,A
			LD A,(0F342H)
			AND 00001100B
			OR B
			LD B,A
			LD A,(0F341H)
			AND 00001100B
			RRCA
			RRCA
			OR B
			LD (0FFFFH),A
			LD C,0
			JP 0005H
; --------------------- BEGIN | PROCEDURE TO SET UP SLOT
SETSLOT:	LD A,(INTERDISCO)
			LD B,A
			AND 3
			LD E,A
			RLCA
			RLCA
			RLCA
			RLCA
			OR E
			RLCA
			RLCA
			LD C,A
			IN A,(0A8H)
			LD H,A
			LD (SLOT),A
			AND 00110011B
			OR C
			OUT(0A8H),A
			LD H,A
			LD A,(0FFFFH)
			CPL
			LD L,A
			LD (SLOT2),HL
			LD A,B
			AND 00001100B
			LD C,A
			LD A,L
			AND 11110011B
			OR C
			LD (0FFFFH),A
			IN A,(0A8H)
			AND 00111111B
			LD B,A
			RLCA
			RLCA
			AND 11000000B
			OR B
			OUT(0A8H),A
			RET
			
BACKSLOT:	LD HL,(SLOT2)
			LD A,H
			OUT(0A8H),A
			LD A,L
			LD (0FFFFH),A
			LD A,(SLOT)
			OUT(0A8H),A
			RET
; --------------------- END | PROCEDURE TO SET UP SLOT			
		
; --------------------- BEGIN | PROCEDURE TO GET FDC FROM THE CONNECTED INTERFACES		
GETINT:     DI
			LD B,4
			LD HL,0FB22H
			LD (SLOTS),HL
GETINTLOOP:	PUSH BC
			LD HL,(SLOTS)
			LD A,(HL)
			LD (INTERDISCO),A
			CALL SETSLOT		
			CALL GETINTERFACE	
			LD HL,GUIADDR
			LD DE,0
			LD BC,3C0H
			CALL WVRAM			
			LD A,(INTERFACE)
			AND A
			JR NZ,GETINTSAI			
			CALL BACKSLOT
			LD HL,(SLOTS)
			INC HL
			INC HL
			LD (SLOTS),HL
			POP BC
			DJNZ GETINTLOOP
			EI
			RET
GETINTSAI:	LD A,(TATUAL)
			LD HL,0
			LD L,A
			LD DE,848
			CALL PRINT2
			LD DE,STR_PARENTESES
			LD HL,850
			CALL PRINT
			LD A,(TATUAL)
			LD HL,851
			CALL PRINTBYTE
			LD A,(DRIVELADO)
			LD HL,876
			CALL PRINTBYTE
			LD HL,860
			LD A,(MODE)
			AND A
			JR Z,GETINTEMUL
			LD DE,STR_MODE2
			JR GETINTPUL
GETINTEMUL:	LD DE,STR_MODE1
GETINTPUL:	CALL PRINT			
			CALL SETNEXTTRACK
			CALL SEEKTRACK
			CALL READADDR
			CALL PRINTID
GETINTLP:	CALL CHGET
			CP 28
			JP Z,GETINTMAIS
			CP 29
			JP Z,GETINTMENO
			CP 30
			JP Z,GETINTSUP
			CP 31
			JP Z,GETINTSDW			
			CP '2'
			JP Z,GETINTL1
			CP '1'
			JP Z,GETINTL0
			CP 'M'
			JP Z,GETINTM
			CP 'H'
			JP Z,HELP
			CP 27
			JP Z,GETINTFIM
			JP GETINTLP
GETINTSUP:	LD A,(DESLOC)
			AND A
			JR Z,GETINTLP
			DEC A
			LD (DESLOC),A
			CALL PRINTID2
			JR GETINTLP
GETINTSDW: 	LD A,(DESLOC)
			LD B,A
			LD A,(DESLOCMAX)
			CP B
			JR Z,GETINTLP
			LD A,B
			INC A
			LD (DESLOC),A
			CALL PRINTID2
			JR GETINTLP
GETINTMAIS:	LD A,(TATUAL)
			CP 79
			JP Z,GETINTLP
			INC A
			LD (TATUAL),A
			JP GETINTSAI
GETINTMENO:	LD A,(TATUAL)
			AND A
			JP Z,GETINTLP
			DEC A
			LD (TATUAL),A
			JP GETINTSAI
GETINTL1:	LD A,1
			LD (DRIVELADO),A
			JP GETINTSAI
GETINTL0:	XOR A
			LD (DRIVELADO),A
			JP GETINTSAI	
GETINTM:	LD A,(MODE)
			CPL
			AND 1
			LD (MODE),A
			JP GETINTSAI
GETINTFIM:	CALL BACKSLOT
			POP BC
			IN A,(0A8H)
			AND 0F0H
			OUT(0A8H),A
			EI
			RET
; --------------------- END | PROCEDURE TO GET FDC FROM THE CONNECTED INTERFACES					
				
; --------------------- END | PROCEDURE TO PRINT STRING		

; --------------------- BEGIN | PROCEDURE TO SEARCH FOR BYTES IN MEMORY USING MASK
SEARCH_BYTES:
			LD IX,4000H
			LD HL,4000H
			LD A,(IY)
			LD B,A
			LD E,A
			LD D,0
			INC IY
			INC A
SEARCHLOOP:	LD (BYTEIY2 + 2),A
			LD A,D
			LD (BYTEIX + 2),A
			LD (BYTEIY + 2),A
BYTEIX:		LD A,(IX + 0)
BYTEIY2:	AND (IY + 0)
BYTEIY:		CP (IY + 0)
			JR NZ,SEARCHNOT
			INC D
			LD A,E
			INC A
			ADD A,D
			DJNZ SEARCHLOOP
			LD A,1
			RET
SEARCHNOT:	DEC HL
			LD A,L
			OR H
			JR Z,SEARCHSAI
			LD D,0
			INC IX
			LD A,E
			LD B,A
			INC A
			JR SEARCHLOOP
SEARCHSAI:	XOR A
			RET	
; --------------------- END | PROCEDURE TO SEARCH FOR BYTES IN MEMORY USING MASK				
	
; --------------------- BEGIN | PROCEDURE TO IDENTIFY THE FDC CHIPSET
GETINTERFACE:
			LD IY,STR_PHILIPS
			CALL SEARCH_BYTES
			AND A
			JR Z,SEARCHNF00
			LD A,1
			LD (INTERFACE),A
			LD A,(IX + 4)
			LD L,A
			LD A,(IX + 5)
			LD H,A
			LD (REG_STATUS_2),HL
			LD A,(IX + 11)
			LD L,A
			LD A,(IX + 12)
			LD H,A
			LD (REG_CMD),HL
			INC HL
			LD (REG_TRACK),HL
			INC HL
			LD (REG_SECTOR),HL
			INC HL
			LD (REG_DATA),HL
			INC HL
			LD (REG_SIDE),HL
			INC HL
			LD (REG_DRIVE),HL
			JP SEARCHEND
SEARCHNF00:	LD IY,STR_PHILIPS1
			CALL SEARCH_BYTES	
			AND A
			JP Z,SEARCHEND0A	
			LD A,1
			LD (INTERFACE),A
			LD A,(IX + 8)
			LD L,A
			LD A,(IX + 9)
			LD H,A
			LD (REG_STATUS_2),HL
			LD A,(IX + 11)
			LD L,A
			LD A,(IX + 12)
			LD H,A
			LD (REG_CMD),HL
			INC HL
			LD (REG_TRACK),HL
			INC HL
			LD (REG_SECTOR),HL
			INC HL
			LD (REG_DATA),HL
			INC HL
			LD (REG_SIDE),HL
			INC HL
			LD (REG_DRIVE),HL
			JP SEARCHEND	
SEARCHEND0A:LD IY,STR_PHIL_NAT
			CALL SEARCH_BYTES	
			AND A
			JP Z,SEARCHEND00	
			LD A,1
			LD (INTERFACE),A
			LD A,(IX + 4)
			LD L,A
			LD A,(IX + 5)
			LD H,A
			LD (REG_STATUS_2),HL
			LD A,(IX + 15)
			LD L,A
			LD A,(IX + 16)
			LD H,A
			LD (REG_CMD),HL
			INC HL
			LD (REG_TRACK),HL
			INC HL
			LD (REG_SECTOR),HL
			INC HL
			LD (REG_DATA),HL
			INC HL
			LD (REG_SIDE),HL
			INC HL
			LD (REG_DRIVE),HL
			LD HL,(REG_STATUS_2)
			LD DE,(REG_SIDE)
			LD A,H
			CP D
			JP NZ,SEARCHEND
			LD A,L
			CP E
			JP NZ,SEARCHEND
			LD A,2
			LD (INTERFACE),A
			LD (REG_DRIVE),DE
			JP SEARCHEND				
SEARCHEND00:LD IY,STR_PHILIPS2
			CALL SEARCH_BYTES	
			AND A
			JP NZ,SEARCHEND0
SEARCHNF1:	LD IY,STR_NATIONAL
			CALL SEARCH_BYTES
			AND A
			JR Z,SEARCHNF2
			LD A,2
			LD (INTERFACE),A
			LD A,(IX + 1)
			LD L,A
			LD A,(IX + 2)
			LD H,A
			LD (REG_CMD),HL
			INC HL
			LD (REG_TRACK),HL
			INC HL
			LD (REG_SECTOR),HL
			INC HL
			LD (REG_DATA),HL
			INC HL
			LD (REG_DRIVE),HL
			LD (REG_STATUS_2),HL
			JP SEARCHEND
SEARCHNF2:	LD IY,STR_TOSHIBA1
			CALL SEARCH_BYTES
			AND A
			JR Z,SEARCHNF3
			LD A,3
			LD (INTERFACE),A	
			LD A,(IX + 1)
			LD L,A
			LD A,(IX + 2)
			LD H,A
			LD (REG_STATUS),HL
			LD A,(IX + 11)
			LD L,A
			LD A,(IX + 12)
			LD H,A
			LD (REG_CMD),HL
			LD (REG_RESULT_STATUS),HL
			LD (REG_DATA),HL
			LD IY,STR_TOSHIBA2
			CALL SEARCH_BYTES
			LD A,(IX + 3)
			LD L,A
			LD A,(IX + 4)
			LD H,A
			LD (REG_CONTROL1),HL
			LD IY,STR_TOSHIBA3
			CALL SEARCH_BYTES
			LD A,(IX + 3)
			LD L,A
			LD A,(IX + 4)
			LD H,A
			LD (REG_CONTROL0),HL
			JP SEARCHEND2
SEARCHNF3:	LD IY,STR_MICROSOL
			CALL SEARCH_BYTES
			AND A
			JR Z,SEARCHNF4
			LD A,4
			LD (INTERFACE),A
			LD HL,0D4H
			LD (REG_DRIVE),HL
			LD (REG_SIDE),HL
			LD (REG_STATUS_2),HL
			LD HL,0D3H
			LD (REG_DATA),HL
			LD HL,0D2H
			LD (REG_SECTOR),HL
			LD HL,0D1H
			LD (REG_TRACK),HL
			LD HL,0D0H
			LD (REG_CMD),HL
			JP SEARCHEND
SEARCHEND0: LD HL,07FFFH
			LD (REG_STATUS_2),HL
			LD A,1
			LD (INTERFACE),A
			JP SEARCHEND0B
SEARCHNF4:	XOR A
			LD (INTERFACE),A
SEARCHEND0B:LD HL,07FFDH
			LD (REG_DRIVE),HL
			DEC HL
			LD (REG_SIDE),HL
			DEC HL
			LD (REG_DATA),HL
			DEC HL
			LD (REG_SECTOR),HL
			DEC HL
			LD (REG_TRACK),HL
			DEC HL
			LD (REG_CMD),HL
SEARCHEND:	LD HL,(REG_DRIVE)
			LD (DEBUG_REG),HL
			LD HL,(REG_SIDE)
			LD (DEBUG_REG + 2),HL
			LD HL,(REG_DATA)
			LD (DEBUG_REG + 4),HL
			LD HL,(REG_SECTOR)
			LD (DEBUG_REG + 6),HL
			LD HL,(REG_TRACK)
			LD (DEBUG_REG + 8),HL
			LD HL,(REG_CMD)
			LD (DEBUG_REG + 10),HL
			LD HL,(REG_STATUS_2)
			LD (DEBUG_REG + 12),HL	
			RET
SEARCHEND2:	LD HL,(REG_STATUS)
			LD (DEBUG_REG),HL
			LD HL,(REG_CMD)
			LD (DEBUG_REG + 2),HL			
			LD HL,(REG_RESULT_STATUS)
			LD (DEBUG_REG + 4),HL	
			LD HL,(REG_DATA)
			LD (DEBUG_REG + 6),HL	
			LD HL,(REG_CONTROL1)
			LD (DEBUG_REG + 8),HL	
			LD HL,(REG_CONTROL0)
			LD (DEBUG_REG + 10),HL				
			RET
; --------------------- END | PROCEDURE TO IDENTIFY THE FDC CHIPSET	

; --------------------- BEGIN | PROCEDURE TO READ A CHARACTER FROM KEYBOARD
; --------------------- BEGIN | MAIN ROUTINE
CHGET:		CALL 9CH
			JR Z,CHGET
			CALL 9FH
			JP ABYTE
; --------------------- END | MAIN ROUTINE
; --------------------- BEGIN | AUXILIARY ROUTINE			
ABYTE:		PUSH AF
			SUB 61H
			JR C,ABSAI
			POP AF
			PUSH AF
			SUB 7BH
			JR NC,ABSAI
			POP AF
			SUB 20H
			RET
ABSAI:		POP AF
			RET		
; --------------------- END | AUXILIARY ROUTINE			
; --------------------- END | PROCEDURE TO READ A CHARACTER FROM KEYBOARD	

; --------------------- BEGIN | PROCEDURE TO TURN OF DRIVE		
DESLIGDRIVE:LD A,(INTERFACE)
			CP 3
			JP Z,DESDRVTOSHIBA
			CP 4
			JR Z,DESDRVCDX2
			LD A,3
			LD IY,(REG_DRIVE)
			LD (IY),A
			RET
DESDRVCDX2:	XOR A
			OUT(0D4H),A
			RET			
DESDRVTOSHIBA:
			A,4
			LD IY,(REG_CONTROL0)
			LD (IY),A		
			RET
; --------------------- END | PROCEDURE TO TURN OF DRIVE		

; --------------------- BEGIN | PROCEDURE TO TURN ON DRIVE
LIGDRIVE:	PUSH HL
			PUSH DE
			PUSH BC
			LD HL,(DRIVELADO)
LIGCONT:	LD A,(INTERFACE)
			CP 2
			JR Z,NATION
			CP 3
			JR Z,LIGTOSHIBA
			CP 4
			JR Z,LIGMICROSOL
			LD A,L
			LD DE,(REG_SIDE)
			LD (DE),A
			LD A,H
			SUB 1
			LD B,A
			LD A,0C4H
			OR B
			LD DE,(REG_DRIVE)
			LD (DE),A
			CALL DELAY2		
			JP LIGDRIVEFIM
NATION:		LD DE,(REG_DRIVE)
			LD A,01001000B
			LD B,A
			LD A,H
			OR B
			LD B,A
			LD A,L
			RLCA
			RLCA
			OR B
			LD (DE),A
			CALL DELAY2		
			JR LIGDRIVEFIM
LIGMICROSOL:RLC L
			RLC L
			RLC L
			RLC L
			LD A,20H
			OR L
			OR H
			OUT(0D4H),A
			CALL DELAY2
			JR LIGDRIVEFIM	
LIGTOSHIBA:	DEC H
			LD A,H
			INC A
			RRCA
			RRCA
			RRCA
			RRCA
			AND 11110000B
			OR 00000100B
			OR H
			LD IY,(REG_CONTROL0)
			LD (IY),A
			CALL DELAY3
LIGDRIVEFIM:POP BC
			POP DE
			POP HL
			RET	
; --------------------- END | PROCEDURE TO TURN ON DRIVE		

; --------------------- BEGIN | PROCEDURE TO EMULATE READ ADDRESS
EMULAID:	PUSH AF
			PUSH DE
			PUSH BC
			PUSH IX
			PUSH IY
			LD (EMULADDR),HL ; SALVA ENDEREÇO DA RAM
			PUSH HL
			LD HL,EMULBYTES 
			POP DE
			LD BC,6
			LDIR ; TRANSFERE OS 6 BYTES EMULADOS PARA A RAM
			LD HL,(EMULADDR) 
			LD DE,6 
			ADD HL,DE ; SOMA 6 AO ENDEREÇO DA RAM PRA RETORNAR
			LD IX,(EMULPOS) ; SETA PONTEIRO PARA O SETOR ATUAL EMULADO
			LD IY,(EMULADDR) ; ENDEREÇO DA RAM
			LD A,(DRIVELADO) 
			LD (IY + 1),A ; COLOCA O LADO ATUAL (VARIÁVEL JÁ SETADA NO MEU PROGRAMA)
			LD A,(TATUAL)
			LD (IY),A ; COLOCA A TRILHA ATUAL (VARIÁVEL JÁ SETADA NO MEU PROGRAMA)
			LD A,(IX)
			LD (IY + 2),A ; COLOCA O SETOR ATUAL
			LD C,A
			LD B,0A7H
			ADD A,B
			LD (IY + 4),A
			LD A,C
			LD B,0B7H
			ADD A,B
			LD (IY + 5),A
			INC IX ; INCREMENTA PONTEIRO DO SETOR
			LD (EMULPOS),IX ; GUARDA PONTEIRO DO SETOR
			LD A,(IX) ; VERIFICA SE O PRÓXIMO SETOR É O FIM
			AND A
			JR NZ,EMULFIM ; RETORNA SE NÃO FOR FIM COM HL JÁ INCREMENTADO
			LD DE,EMULSET ; SE FOR FIM, RESETA PONTEIRO DO SETOR
			LD (EMULPOS),DE
EMULFIM:	POP IY
			POP IX
			POP BC
			POP DE
			POP AF
			RET	
; --------------------- END | PROCEDURE TO EMULATE READ ADDRESS			

; --------------------- BEGIN | PROCEDURE TO PRINT STRING
PRINT:		LD A,(DE)
			CP ','
			RET Z
			PUSH HL
			PUSH DE
			CALL WVBYTE
			POP DE
			POP HL
			INC HL
			INC DE
			JR PRINT			
; --------------------- END | PROCEDURE TO PRINT STRING		

; --------------------- BEGIN | PROCEDURE TO PRINT HEX BYTE
PRINTBYTE:	PUSH AF
			PUSH HL
			PUSH DE
			PUSH BC
			PUSH HL
			LD B,A
			AND 0F0H
			RRCA
			RRCA
			RRCA
			RRCA
			LD HL,HEXNUMBERS
			LD DE,0
			LD E,A
			ADD HL,DE
			LD A,(HL)
			POP HL
			CALL WVBYTE
			INC HL
			PUSH HL
			LD A,B
			AND 0FH
			LD HL,HEXNUMBERS
			LD DE,0
			LD E,A
			ADD HL,DE
			LD A,(HL)
			POP HL
			CALL WVBYTE
			POP BC
			POP DE
			POP HL
			POP AF
			RET
; --------------------- END | PROCEDURE TO PRINT HEX BYTE

; --------------------- BEGIN | PROCEDURE TO CHECK IF SECTOR ALREADY EXIST
FINDSECTOR:	LD IY,NTRILHAS
			LD A,(LEITURAS)
			LD B,A
FINDSECLOOP:LD A,(IY)
			CP (IX)
			JR NZ,NOTFIND
			LD A,(IY + 30)
			CP (IX + 1)
			JR NZ,NOTFIND
			LD A,(IY + 60)
			CP (IX + 2)
			JR NZ,NOTFIND
			LD A,(IY + 90)
			CP (IX + 3)
			JR NZ,NOTFIND
			PUSH IY
			LD DE,120
			ADD IY,DE
			LD A,(IY)
			CP (IX + 4)
			JR NZ,NOTFIND
			LD DE,30
			ADD IY,DE
			LD A,(IY)
			POP IY
			CP (IX + 5)
			JR NZ,NOTFIND			
			LD A,1
			RET
NOTFIND:	INC IY
			DJNZ FINDSECLOOP
			XOR A
			RET
; --------------------- END | PROCEDURE TO CHECK IF SECTOR ALREADY EXIST

; --------------------- BEGIN | PROCEDURE TO CLEAR DATA
CLEARDATA:	LD HL,242
			LD B,12
CLEARL0:	LD C,30
			PUSH HL
CLEARL1:	LD A,' '
			CALL WVBYTE
			INC HL
			DEC C
			JR NZ,CLEARL1
			POP HL
			LD DE,40
			ADD HL,DE
			DJNZ CLEARL0
			RET			
; --------------------- END | PROCEDURE TO CLEAR DATA

; --------------------- BEGIN | PROCEDURE TO CLEAR ERRORS
CLEARDATA2:	LD HL,260
			LD B,12
CLEARL0B:	LD C,6
			PUSH HL
CLEARL1B:	LD A,' '
			CALL WVBYTE
			INC HL
			DEC C
			JR NZ,CLEARL1B
			POP HL
			LD DE,40
			ADD HL,DE
			DJNZ CLEARL0B
			RET			
; --------------------- END | PROCEDURE TO CLEAR ERRORS

; --------------------- BEGIN | PROCEDURE TO GET DISTINCT SECTORS
GERADADOS:	LD A,(LEITURAS)
			LD B,A
			LD C,0
			LD IX,BUFFERADDR
			LD IY,NTRILHAS
GERADADOSLP:LD A,(IX)
			CP 0F7H
			JR Z,GERASAI
			PUSH IX
			PUSH IY
			PUSH BC
			CALL FINDSECTOR
			POP BC
			POP IY
			POP IX
			AND A
			JR NZ,GERAPULA
			LD A,(IX)
			LD (IY),A
			LD A,(IX + 1)
			LD (IY + 30),A
			LD A,(IX + 2)
			LD (IY + 60),A
			LD A,(IX + 3)
			LD (IY + 90),A
			LD A,(IX + 4)
			PUSH IY
			LD DE,120
			ADD IY,DE
			LD (IY),A	
			LD A,(IX + 5)
			LD DE,30
			ADD IY,DE
			LD (IY),A
			POP IY
			INC C
			INC IY
GERAPULA:	PUSH IX
			POP HL
			LD DE,8
			ADD HL,DE
			PUSH HL
			POP IX
			DJNZ GERADADOSLP
GERASAI:	LD A,C
			LD (QTDSETORES),A
			LD HL,0
			LD L,A
			LD DE,765
			CALL PRINT2
			RET
; --------------------- END | PROCEDURE TO GET DISTINCT SECTORS			
			
; --------------------- BEGIN | PROCEDURES TO WAIT DEVICE IS READY					
WAIT:		IN A,(0D0H)
			RRA
			RET NC
			JR WAIT		
			
WAITRES:	LD HL,2
WAITRESBACK:LD DE,0FFFFH
WAITRESBAC2:LD A,E
			OR D
			JR Z,WAITSAI
			DEC DE
			IN A,(0D0H)
			RRA
			RET NC
			JR WAITRESBAC2	
WAITSAI:	DEC HL
			LD A,L
			OR H
			RET Z
			JR WAITRESBACK
			
WAIT2:		LD HL,(REG_CMD)
			LD A,(HL)
			RRA
			RET NC
			JR WAIT2

WAIT2RES:	LD HL,2
WAIT2RESBA:	LD BC,0FFFFH
WAIT2RESBAB:LD A,C
			OR B
			JR Z,WAIT2SAI
			DEC BC
			LD DE,(REG_CMD)
			LD A,(DE)
			RRA
			RET NC
			JR WAIT2RESBAB	
WAIT2SAI:	DEC HL
			LD A,L
			OR H
			RET Z
			JR WAIT2RESBA				
; --------------------- END | PROCEDURES TO WAIT DEVICE IS READY	
			
; --------------------- BEGIN | PROCEDURES TO RESTORE DRIVE
RESTORE:	CALL LIGDRIVE
			LD A,(INTERFACE)
			CP 3
			JP Z,RESTORETOSHIBA
			CP 4
			JR Z,RESTORECDX2
			LD A,1
			LD HL,(REG_CMD)
			LD (HL),A
			CALL DELAY2
			CALL WAIT2RES
			JP DESLIGDRIVE
RESTORECDX2:LD A,1
			OUT(0D0H),A
			CALL DELAY2
			CALL WAITRES
			JP DESLIGDRIVE
RESTORETOSHIBA:
			LD BC,(DRIVELADO)
			DEC B
			LD A,B
			LD (CMD_RECALIBRATE + 2),A	
			LD A,C
			RLCA
			RLCA
			OR B
			LD (CMD_SENSE_DEV + 2),A		
			CALL READY_DRV
READYBACK2:	LD DE,CMD_SENSE_DEV
			CALL WAIT_10_CALL
			CALL GUARDA_CMD
			BIT 5,A
			JR Z,READYBACK2
			CALL READY_FAKE
LOOPINT2:	CALL DELAY3
			LD DE,CMD_RECALIBRATE
			CALL WAIT_10_CALL
			CALL WAIT_10_FULL
			LD DE,CMD_SENSE_INT
			CALL WAIT_10_CALL
			CALL GUARDA_CMD
			LD A,(BUFFERIX)
			BIT 4,A
			JR NZ,LOOPINT2			
RESTCONT:	JP DESLIGDRIVE
; --------------------- END | PROCEDURES TO RESTORE DRIVE

; --------------------- BEGIN | PROCEDURES TO MOVE THE DRIVE´S HEAD TO NEXT TRACK			
SEEKTRACK:	CALL LIGDRIVE
			LD A,(INTERFACE)
			CP 3
			RET Z
			CP 4
			JR Z,SEEKCDX2			
			LD A,10H
			LD HL,(REG_CMD)
			LD (HL),A
			CALL DELAY2
			CALL WAIT2
			CALL INTNOW
			CALL DESLIGDRIVE
			RET
SEEKCDX2:	LD A,11H
			OUT(0D0H),A
			CALL DELAY2
			CALL WAIT
			RET
; --------------------- END | PROCEDURES TO MOVE THE DRIVE´S HEAD TO NEXT TRACK

; --------------------- BEGIN | PROCEDURE TO SET UP NEXT TRACK			
SETNEXTTRACK:
			LD A,(INTERFACE)
			CP 3
			RET Z
			CP 4
			JR Z,SETNEXTCDX2
			LD A,(TATUAL)
			LD HL,(REG_DATA)
			LD (HL),A
			RET
SETNEXTCDX2:LD A,C
			OUT(0D3H),A
			RET
; --------------------- END | PROCEDURE TO SET UP NEXT TRACK		

; --------------------- BEGIN | PROCEDURES TO READ ADDRESS		
READADDR:	LD HL,BUFFERADDR
			LD DE,BUFFERADDR + 1
			LD BC,512
			LD A,0F7H
			LD (HL),A
			LDIR
			LD HL,NTRILHAS
			LD DE,NTRILHAS + 1
			LD BC,209
			XOR A
			LD (HL),A
			LDIR
			DI
			CALL READAD
			CALL GERADADOS
			CALL GETERRORS
			RET
; --------------------- END | PROCEDURES TO READ ADDRESS	

; --------------------- BEGIN | PROCEDURE TO READ DATA USING MICROSOL FDC  		
READ:		LD DE,READOUT
			PUSH DE
			OUT(0D0H),A
			CALL DELAY2
			LD C,0D3H
RRBACK:		IN A,(0D0H)
			RRA
			RET NC
			RRA
			JR NC,RRBACK
			INI
			LD A,(FLAGREAD)
			AND A
			RET NZ
			JR RRBACK
READOUT:	IN A,(0D0H)
			PUSH AF
			CALL INTNOWCDX2
			POP AF
			RET			
; --------------------- END | PROCEDURE TO READ DATA USING MICROSOL FDC 	

; --------------------- BEGIN | PROCEDURES TO READ DATA USING W.DIGITAL AND FUJITSU FDC 			
READ2:		LD DE,READ2SAI
			PUSH DE
			LD DE,(REG_CMD)
			LD (DE),A
			LD DE,0
			LD BC,(REG_STATUS_2)	
READ2BACK1:	DEC DE
			LD A,E
			OR D
			RET Z
			LD A,(BC)
			ADD A,A
			JP C,READ2BACK1
			LD DE,(REG_DATA)
READ2BACK2:	LD A,(BC)
			ADD A,A
			RET C
			JP M,READ2BACK2
			LD A,(DE)
			LD (HL),A
			INC HL
			LD A,(FLAGREAD)
			AND A
			RET NZ
			JP READ2BACK2	
READ2SAI:	LD DE,(REG_CMD)
			LD A,(DE)
			PUSH AF
			CALL INTNOW
			POP AF
			RET			
		
READ4:		LD DE,READ2SAI
			PUSH DE
			LD DE,(REG_CMD)
			LD (DE),A
			LD DE,0
			LD BC,(REG_STATUS_2)
READ4BACK1:	DEC DE
			LD A,E
			OR D
			RET Z
			LD A,(BC)
			ADD A,A
			JP P,READ4BACK1
			LD DE,(REG_DATA)
READ4BACK2:	LD A,(BC)
			ADD A,A
			RET P
			JP C,READ4BACK2
			LD A,(DE)
			LD (HL),A
			INC HL
			LD A,(FLAGREAD)
			AND A
			RET NZ
			JP READ4BACK2			
; --------------------- END | PROCEDURES TO READ DATA USING W.DIGITAL AND FUJITSU FDC 

; --------------------- BEGIN | PROCEDURE TO PRINT ID DATA
PRINTID:	CALL CLEARDATA
PRINTID2:	CALL CLEARDATA2
			LD A,(QTDSETORES)
			AND A
			RET Z
			CALL MENOR14
			LD HL,242
			LD (TEMPADDR),HL
			LD B,A
PRINTDL0:	LD C,6
			PUSH HL
			PUSH IX
PRINTDL1:	LD A,(IX)
			CALL PRINTBYTE
			LD DE,30
			ADD IX,DE
			LD DE,3
			ADD HL,DE
			DEC C
			JR NZ,PRINTDL1
			CALL PRINTERRORS
			POP IX
			INC IX
			POP HL
			LD DE,40
			ADD HL,DE
			DJNZ PRINTDL0
			RET
; --------------------- END | PROCEDURE TO PRINT ID DATA

; --------------------- BEGIN | PROCEDURE TO PRINT DATA ERRORS
PRINTERRORS:PUSH HL
			PUSH DE
			PUSH BC
			LD (TEMPADDR),HL
PRINTEBACK:	LD A,(IX)
			LD C,A
			AND 18H
			CP 18H
			JR Z,CRCID
			CP 08
			JR Z,CRCDATA
			JR PTERROCONT
CRCID:		LD A,0F9H
			INC HL
			INC HL
			CALL WVBYTE
			JR PTERROCONT
CRCDATA:	LD A,0F9H
			CALL WVBYTE
PTERROCONT:	LD A,C
			BIT 5,A
			JR Z,PTERROPULA
			LD HL,(TEMPADDR)
			LD DE,4
			ADD HL,DE
			LD A,0F9H
			CALL WVBYTE
PTERROPULA:	POP BC
			POP DE
			POP HL
			RET
; --------------------- END | PROCEDURE TO PRINT DATA ERRORS

; --------------------- BEGIN | PROCEDURE TO VERIFY IF NUMBER IS BIGGER THAN 15
MENOR14:	PUSH HL
			PUSH BC
			PUSH DE
			LD B,12
			LD D,A
			LD E,B
MENOR14L:	DEC A
			JR Z,MENOR14SAI
			DJNZ MENOR14L
			LD A,D
			SUB E
			LD (DESLOCMAX),A
			LD A,E
MENOR14BACK:PUSH AF
			LD HL,NTRILHAS
			LD DE,0
			LD A,(DESLOC)
			LD E,A
			ADD HL,DE
			PUSH HL
			POP IX
			POP AF
			POP DE
			POP BC
			POP HL
			RET
MENOR14SAI:	XOR A
			LD (DESLOCMAX),A
			LD A,D
			JR MENOR14BACK
; --------------------- END | PROCEDURE TO VERIFY IF NUMBER IS BIGGER THAN 15

; --------------------- BEGIN | PROCEDURE TO CALL 20 TIMES READADDRESS
READAD:		XOR A
			LD (FLAGREAD),A
			LD A,1
			LD (BUFFERADDR - 1),A
			LD A,(LEITURAS)
			LD B,A
			LD HL,BUFFERADDR
			CALL LIGDRIVE
RALOOP:		PUSH BC
			LD A,(MODE)
			AND A
			JP Z,READADEMUL			
READSECTOR:	PUSH HL
			POP IX
			LD A,(INTERFACE)
			CP 2
			JR Z,READ2SET
			CP 3
			JP Z,READADFIM2
			CP 4
			JR Z,READCDX2			
			JR READ4SET
READBAK:	BIT 2,A
			JR NZ,READERRO
			; AND 18H
			; CP 10H
			; JR Z,READADFIM2
			JR READADFIM
READERRO:	PUSH IX
			POP HL
			JR READSECTOR
READ2SET:	LD A,0C0H
			CALL READ2
			JP READBAK			
READ4SET:	LD A,0C0H
			CALL READ4
			JP READBAK
READCDX2:	LD A,0C0H
			CALL READ
			JR READBAK	
READADEMUL:	CALL EMULAID
READADFIM:	POP BC
			INC HL
			INC HL
			DJNZ RALOOP
			CALL DESLIGDRIVE
			RET
READADFIM2: XOR A
			LD (BUFFERADDR - 1),A
			POP BC
			CALL DESLIGDRIVE
			RET
; --------------------- END | PROCEDURE TO CALL 20 TIMES READADDRESS

; --------------------- BEGIN | PROCEDURE TO GET SECTOR ERRORS
GETERRORS:	LD A,(MODE)
			AND A
			RET Z
			LD A,(QTDSETORES)
			AND A
			RET Z
			CALL LIGDRIVE
			LD A,1
			LD (FLAGREAD),A
			LD IX,NTRILHAS
			LD A,(QTDSETORES)
			LD HL,BUFFERDATA
			AND A
			RET Z
			LD B,A
GETELOOP:	PUSH BC
			LD IY,(REG_TRACK)
			LD A,(IX)
			LD (IY),A
			LD IY,(REG_SECTOR)
			LD A,(IX + 60)
			LD (IY),A
			LD A,(INTERFACE)	
			CP 2
			JR Z,READNAT
			CP 3
			JR Z,READTOSHIBA
			CP 4
			JR Z,READCDX2B
			LD A,80H
			CALL READ4
			JR GETECONT
READNAT:	LD A,80H
			CALL READ2
			JR GETECONT
READTOSHIBA:;CALL READ3
			POP BC
			JR GETECONT2
READCDX2B:	LD A,80H
			CALL READ
GETECONT:	LD DE,180
			ADD IX,DE
			LD (IX),A
			POP BC
			INC IX
			DJNZ GETELOOP
GETECONT2:	CALL DESLIGDRIVE	
			RET
; --------------------- END | PROCEDURE TO GET SECTOR ERRORS

; --------------------- BEGIN | ROUTINES TO INTERRUPT COMMANDS
INTWAIT:	EX (SP),HL
			EX (SP),HL
			EX (SP),HL
			EX (SP),HL
			RET
			
INTNOW:		CALL INTWAIT	
			LD A,0D0H
			LD DE,(REG_CMD)
			LD (DE),A
			CALL INTWAIT
INTNOWBACK:	LD A,(DE)
			RRA
			RET NC			
			JR INTNOWBACK
			
INTNOWCDX2:	CALL INTWAIT	
			LD A,0D0H
			OUT(0D0H),A
			CALL INTWAIT
INTNOWBACK2:IN A,(0D0H)
			RRA
			RET NC			
			JR INTNOWBACK2			
; --------------------- END | ROUTINES TO INTERRUPT COMMANDS

; --------------------- BEGIN | PROCEDURES TO DELAY	
DELAY:		PUSH BC
			LD B,6
DELOOP:		EX (SP),HL
			EX (SP),HL
			DJNZ DELOOP
			POP BC
			RET

DELAY2:		PUSH BC
			LD B,30H
LOOPDELAY2:	EX (SP),HL
			EX (SP),HL
			DJNZ LOOPDELAY2
			POP BC
			RET
			
DELAY3:		PUSH BC
			LD B,77H
LOOPDELAY3:	EX (SP),HL
			EX (SP),HL
			DJNZ LOOPDELAY3
			POP BC
			RET					
; --------------------- END | PROCEDURES TO DELAY		

; --------------------- BEGIN | PROCEDURE TO SAVE THE DEVICE STATUS IN MEMORY
GUARDA_CMD:	LD DE,BUFFERIX
			LD IX,(REG_STATUS)
			LD IY,(REG_RESULT_STATUS)
LOOPADD:	LD A,(IX)
			ADD A,A
			JR NC,LOOPADD
			RET P
			LD A,(IY)
			LD (DE),A
			INC DE
			JR LOOPADD
; --------------------- END | PROCEDURES TO SAVE THE DEVICE STATUS IN MEMORY			

; --------------------- BEGIN | PROCEDURE TO WAIT UNTIL DEVICE IS READY 				
WAIT_10_FULL:
			LD IX,(REG_STATUS)
WAIT10FB:	LD A,(IX)
			AND 10H
			JR NZ,WAIT10FB
			RET		
; --------------------- END | PROCEDURE TO WAIT UNTIL DEVICE IS READY 		

; --------------------- BEGIN | PROCEDURES TO EXECUTE COMMAND USING TOSHIBA FDC		
WAIT_10_CALL:PUSH HL
			LD HL,07D0H
			LD IX,(REG_STATUS)
LOOPCOUNT:	LD A,(IX)
			AND 10H
			JR Z,SAI_WAIT1
			DEC HL
			LD A,H
			OR L
			JR NZ,LOOPCOUNT
			POP HL
			RET
SAI_WAIT1:	LD A,(DE)
			LD B,A
			INC DE
			PUSH DE
			POP HL
			CALL EXEC_CMD
			POP HL
			RET
		
EXEC_CMD:	LD IX,(REG_STATUS)
			LD IY,(REG_CMD)
EXECBK:		LD A,(IX)
			AND 0C0H
			CP 80H
			JR NZ,EXECBK
			LD A,(HL)
			LD (IY),A
			INC HL
			DJNZ EXECBK
			RET
; --------------------- END | PROCEDURES TO EXECUTE COMMAND USING TOSHIBA FDC				

; --------------------- BEGIN | PROCEDURE TO READ DATA USING TOSHIBA FDC				
READ_DATA:	LD IX,(REG_STATUS)
			LD IY,(REG_DATA)
LOOPREAD0:	LD A,(IX)
			ADD A,A
			JR NC,LOOPREAD0
			RET P
READDCONT:	LD A,(IY)
			LD (HL),A
			INC HL
			JR LOOPREAD0
; --------------------- END | PROCEDURE TO READ DATA USING TOSHIBA FDC				

; --------------------- BEGIN | PROCEDURE TO WRITE DATA USING TOSHIBA FDC				
WRITE_DATA:	LD DE,(REG_STATUS)
			LD IY,(REG_DATA)
LOOPWRITE0:	LD A,(DE)
			ADD A,A
			JR NC,LOOPWRITE0
			ADD A,A
			RET P
			LD A,(HL)
			LD (IY),A
			INC HL
			JR LOOPWRITE0
; --------------------- END | PROCEDURE TO WRITE DATA USING TOSHIBA FDC			

; --------------------- BEGIN | PROCEDURES TO CHANGE CONTROL1 REGISTER
READY_FAKE:
		LD A,30H
		LD IY,(REG_CONTROL1)
		LD (IY),A
		RET

READY_DRV:
		LD A,20H
		LD IY,(REG_CONTROL1)
		LD (IY),A
		RET	
; --------------------- END | PROCEDURES TO CHANGE CONTROL1 REGISTER	

; --------------------- BEGIN | PROCEDURE TO PRINT A NUMBER IN DECIMAL (2 DIGITS)		
PRINT2:		PUSH AF
			PUSH BC
			LD (PNUM),HL
			LD (PEND),DE
			LD B,0
P2L1:		LD DE,10
			XOR A
			SBC HL,DE
			JR C,P2C1
			LD (PNUM),HL
			INC B
			JR P2L1
P2C1:		LD HL,(PEND)
			PUSH HL
			LD A,B
			ADD A,30H
			CALL WVBYTE
			POP HL
			INC HL
			LD DE,(PNUM)
			LD A,E
			ADD A,30H
			CALL WVBYTE
			POP BC
			POP AF
			RET    
; --------------------- END | PROCEDURE TO PRINT A NUMBER IN DECIMAL (2 DIGITS)	

; --------------------- BEGIN | PROCEDURE TO WRITE BYTE IN VRAM	
WVBYTE:		DI
			PUSH HL
			PUSH DE
			PUSH BC
			PUSH AF
			LD A,L
			OUT (099H),A
			LD A,H
			AND 3FH
			OR 40H
			OUT (099H),A
			EX (SP),HL
			EX (SP),HL
			POP AF
			OUT (098H),A
			POP BC
			POP DE
			POP HL
			RET
; --------------------- END | PROCEDURE TO WRITE BYTE IN VRAM	

; --------------------- BEGIN | PROCEDURE TO READ BYTE IN VRAM	
RVBYTE:		DI
			PUSH HL
			PUSH DE
			PUSH BC
			LD A,L
			OUT (099H),A
			LD A,H
			AND 3FH
			OUT (099H),A
			EX (SP),HL
			EX (SP),HL
			IN A,(098H)
			POP BC
			POP DE
			POP HL
			RET
; --------------------- END | PROCEDURE TO READ BYTE IN VRAM	

; --------------------- BEGIN | PROCEDURE CREATE A MOVING WINDOW
JANELA:		LD (SPEED),IX
			JAN1:CALL WINDOW
			CALL NDELAY
			DEC C
			JR Z,JAN2
			DEC L
			INC E
			JR JAN1
			JAN2:DEC B
			RET Z
			DEC H
			INC D
			CALL WINDOW
			CALL NDELAY
			JR JAN2
; --------------------- END | PROCEDURE CREATE A MOVING WINDOW

; --------------------- BEGIN | MAIN WINDOW PROCEDURE	
WINDOW:		PUSH HL
			PUSH DE
			PUSH BC
			JR WINCONT
EVRAM:DW 0
PONTOS:DW 0
FLAGP:DW 0
XYORI:DW 0
XYDES:DW 0
SPEED:DW 0
WINCONT:	LD (XYORI),HL
			LD (XYDES),DE
			CALL WINCKFI
			JP C,WDFIM
			LD HL,(XYORI)
			LD DE,(XYDES)
			LD E,D
			LD D,H
			PUSH DE
			CALL VRAMPOS
			LD BC,0017H
			LD IX,1819H
			CALL LINHA
			LD HL,(XYORI)
			LD DE,(XYDES)
			LD L,E
			CALL VRAMPOS
			POP DE
			LD BC,0017H
			LD IX,1A1BH
			CALL LINHA
			LD HL,(XYORI)
			LD DE,(XYDES)
			LD D,L
			PUSH DE
			CALL VRAMPOS
			LD BC,0116H
			LD IX,181AH
			CALL LINHA
			LD HL,(XYORI)
			LD DE,(XYDES)
			LD H,D
			CALL VRAMPOS
			POP DE
			LD BC,0116H
			LD IX,191BH
			CALL LINHA
			JR WDFIM
; --------------------- END | MAIN WINDOW PROCEDURE		
		
; --------------------- BEGIN | AUXILIARY WINDOW PROCEDURES		
LINHA:		LD (FLAGP),BC
			LD (PONTOS),DE
			PUSH IX
			POP DE
			LD A,D
			CALL WVBYTE
LOOPL:		CALL INCVRAM
			CALL CHKLIN
			JR C,LINHAF
			LD A,(FLAGP)
			CALL WVBYTE
			JR LOOPL
LINHAF:		PUSH IX
			POP DE
			LD A,E
			JP WVBYTE
	
INCVRAM:	LD BC,(FLAGP)
			LD A,B
			AND A
			JR Z,INCV1
			LD DE,40
			ADD HL,DE
			RET
INCV1:		INC HL
			RET
	
CHKLIN:		LD DE,(PONTOS)
			LD A,E
			DEC A
			SUB D
			JR Z,CHKLF
			XOR A
			JR CKLIP
CHKLF:		SCF
CKLIP:		INC D
			LD (PONTOS),DE
			RET
WDFIM:		CALL WINFIL
			POP BC
			POP DE
			POP HL
			RET
	
VRAMPOS:	PUSH DE
			LD C,L
			LD B,H
			LD HL,0
			LD DE,40
VRLOOP:		LD A,C
			AND A
			JR Z,VRPPUL
			DEC C
			ADD HL,DE
			JR VRLOOP
VRPPUL:		LD DE,0
			LD E,B
			ADD HL,DE
			POP DE
			RET
WINCKFI:	LD A,D
			DEC A
			SUB H
			JR C,WINBAD
			LD A,E
			DEC A
			SUB L
			JR C,WINBAD
			XOR A
			RET
WINBAD:		SCF
			RET
	
WINFIL:		LD HL,(XYORI)
			LD DE,(XYDES)
			LD A,D
			DEC A
			SUB H
			RET Z
			LD A,E
			DEC A
			SUB L
			RET Z
			INC H
			INC L
			CALL VRAMPOS
			PUSH HL
			LD HL,(XYORI)
			LD A,E
			DEC A
			SUB L
			LD C,A
			LD A,D
			DEC A
			SUB H
			LD B,A
			POP HL
			LD (EVRAM),HL
WFLP:		PUSH BC
WFLOOP:		LD A,32
			CALL WVBYTE
			INC HL
			DEC B
			JR NZ,WFLOOP
			LD HL,(EVRAM)
			LD DE,40
			ADD HL,DE
			LD (EVRAM),HL
			POP BC
			DEC C
			JR NZ,WFLP
			RET
; --------------------- END | AUXILIARY WINDOW PROCEDURES					
; --------------------- END | PROCEDURES TO CREATE A WINDOW			
	
; --------------------- BEGIN | PROCEDURE TO DELAY THE WINDOW EFFECT	
NDELAY:		RET
			PUSH BC
			LD BC,(SPEED)
			NDY:LD A,C
			OR B
			JR Z,NDELSAI
			DEC BC
			JR NDY
			NDELSAI:POP BC
			RET
; --------------------- END | PROCEDURE TO DELAY THE WINDOW EFFECT		

; --------------------- BEGIN | PROCEDURE TO DISPLAY THE HELP WINDOW	
HELP:		CALL STELAP
			LD HL,130BH
			LD DE,140CH
			LD BC,120CH
			LD IX,50H
			CALL JANELA 
			LD DE,MSGHELP
			LD HL,84
			CALL PRINTH
			CALL CHGET
			CALL RTELAP
			JP GETINTLP
; --------------------- END | PROCEDURE TO DISPLAY THE HELP WINDOW	

; --------------------- BEGIN | PROCEDURES TO SAVE SCREEN INFORMATION IN VRAM
STELA:		LD HL,0
			LD DE,1000H
			LD BC,3C0H
			JP ROTVRAM
			
STELAP:		LD HL,0
			LD DE,1400H
			LD BC,3C0H
			JP ROTVRAM
; --------------------- END | PROCEDURE TO SAVE SCREEN INFORMATION IN VRAM 

; --------------------- BEGIN | PROCEDURES TO RESTORE SCREEN INFORMATION FROM VRAM 		
RTELA:		LD HL,1000H
			LD DE,0
			LD BC,3C0H
			JP ROTVRAM
						
RTELAP:		LD HL,1400H
			LD DE,0
			LD BC,3C0H
			JP ROTVRAM
; --------------------- END | PROCEDURE TO RESTORE SCREEN INFORMATION FROM VRAM 
		
; --------------------- BEGIN | PROCEDURE TO READ/WRITE BYTES IN VRAM 			
ROTVRAM:	PUSH HL
			PUSH BC
			PUSH DE
			CALL RVBYTE
			POP HL
			PUSH HL
			CALL WVBYTE
			POP DE
			POP BC
			POP HL
			INC HL
			INC DE
			DEC BC
			LD A,C
			OR B
			JR NZ,ROTVRAM
			RET
; --------------------- END | PROCEDURE TO READ/WRITE BYTES IN VRAM		

; --------------------- BEGIN | PROCEDURE TO PRINT A STRING		
PRINTH:		LD (PHELPH),HL
PHLOOP:		LD A,(DE)
			CP 13
			JR Z,PRINTHZ
			AND A
			RET Z
			CALL WVBYTE
			INC HL
			INC DE
			JR PHLOOP
PRINTHZ:	INC DE
			PUSH DE
			LD HL,(PHELPH)
			LD DE,40
			ADD HL,DE
			LD (PHELPH),HL
			POP DE
			JR PHLOOP
; --------------------- END | PROCEDURE TO PRINT A STRING	

; --------------------- BEGIN | PROCEDURE TO READ STRING FROM VRAM (SAME AS 0059H)
RVRAM:		DI
			LD A,L
			OUT (099H),A
			LD A,H
			AND 3FH
			OUT (099H),A
			EX (SP),HL
			EX (SP),HL
RVRL:		IN A,(098H)
			LD (DE),A
			INC DE
			DEC BC
			LD A,C
			OR B
			JR NZ,RVRL
			RET
; --------------------- END | PROCEDURE TO READ STRING FROM VRAM (SAME AS 0059H)			
	
; --------------------- BEGIN | PROCEDURE TO WRITE STRING IN VRAM (SAME AS 005CH)	
WVRAM:		DI
			LD A,E
			OUT (099H),A
			LD A,D
			AND 3FH
			OR 40H
			OUT (099H),A
			EX (SP),HL
			EX (SP),HL
WVRL:		LD A,(HL)
			OUT (098H),A
			DEC BC
			INC HL
			LD A,C
			OR B
			JR NZ,WVRL
			RET
; --------------------- END | PROCEDURE TO WRITE STRING IN VRAM (SAME AS 005CH)		

ENDOFCODE: 


	END     START










