              	; --------------------------------------
              	; zasm: assemble "Altair8800_Monitor.asm"
              	; opts: --asm8080 --reqcolon
              	; date: 2018-05-18 20:49:25
              	; --------------------------------------


              	#!/usr/local/bin/zasm --asm8080 --reqcolon -o original/
              	;================================================
              	;MONITOR 8.4 (2K version)
              	; Upgraded Monitor/Executive program for ALTAIR 8800
              	; Conditional assembly supports SIO-A and 2-SIO cards
              	;
              	; (C) John Garza 2009
              	; Non-commercial use for hobbyists granted
              	;================================================
              	
F000:         		ORG		0F000H			; Location of ROM chip containing this monitor
              	
              	;------------------
              	; SET I/O CARD HERE
              	
0000:         	SIOA	EQU		0
0001:         	SIO2	EQU		1
0000:         	SS1		EQU		0
              	
              	;------------------
              	; STACK LOCATION
              	
0050:         	STACK   EQU     50H			; Stack Location (80 bytes available)
              	
              	;------------------
              	; Other storage
              	
0052:         	RCVSNO	EQU		STACK+2			; SECT # RECEIVED (XMODEM)
0053:         	SECTNO	EQU		STACK+3			; CURRENT SECTOR NUMBER (XMODEM)
0054:         	ERRCT	EQU		STACK+4			; ERROR COUNT(XMODEM)
0056:         	dest	EQU		STACK+6			; destination address pointer 2BYTES (XMODEM)
              	;--
005D:         	IBUFP   EQU     STACK+13        ; Buffer Pointer 2BYTES
005F:         	IBUFC   EQU     IBUFP+2         ; Buffer Count 2BYTES
0060:         	IBUFF   EQU     IBUFP+3         ; Input Buffer
0010:         	IBL		EQU		16				; Input Buffer Length
              	
              	;------------------
              	;RS-232 EQUATES for SIO-A (COM 2502 chip)
              	IF SIOA
              	
              		TTS     equ     00h     ;MITS SIO-A channel A status port
              		TTI     equ     01h     ;MITS SIO-A data input port (yes input=output)
              		TTO     equ     01h     ;MITS SIO-A data output port
              		TTYDA   equ     20h     ;tty data available (ready to receive?) for MITS SIO-A
              		TTYTR   equ     02h     ;tty terminal ready (ready to transmit?) for MITS SIO-A
              	
              	ENDIF
              	;------------------
              	;RS-232 EQUATES for 2SIO (6850 chip)
              	IF SIO2
              	
0010:         		TTS     equ     10h     ;MITS 2SIO status/control port
0011:         		TTI     equ     11h     ;MITS 2SIO data input port (yes input=output)
0011:         		TTO     equ     11h     ;MITS 2SIO data output port
0001:         		TTYDA   equ     01h     ;tty data available (ready to receive?) for MITS 2SIO
0002:         		TTYTR   equ     02h     ;tty terminal ready (ready to transmit?) for MITS 2SIO
              	
              	ENDIF
              	;------------------
              	;RS-232 EQUATES for Compupro SS-1 card
              	IF SS1
              	
              		TTS     equ     5Dh     ; status/control port
              		TTI     equ     5Ch     ; data input port (yes input=output)
              		TTO     equ     5Ch     ; data output port
              		TTYDA   equ     01h     ; tty data available (ready to receive?)
              		TTYTR   equ     02h     ; tty terminal ready (ready to transmit?)
              	
              	ENDIF
              	
              	
              	;---------------------------------------------------------
              	; SERIAL IO PARAMETERS FOR COMPUPRO SYSTEM SUPPORT 1:
              	;
              	;SSBASE    EQU    50H           ;BASE ADDRESS
              	;SSMODE    EQU    SSBASE+0EH    ;UART MODE PORT
              	;SSCMND    EQU    SSBASE+0FH    ;UART COMMAND PORT
              	;TTSTAT    EQU    SSBASE+0DH    ;TTY STATUS PORT
              	;TTDATA    EQU    SSBASE+0CH    ;TTY DATA PORT
              	;TTTBE     EQU    01H           ;TRANSMITTER BUFFER EMPTY
              	;TTRDA     EQU    02H           ;RECEIVER DATA AVAILABLE
              	;---------------------------------------------------------
              	
              	
              	;------------------
              	;ASCII characters used
              	
0000:         	NUL				EQU		0		; NULL (ZERO)
000D:         	CR				EQU		0DH		; Carriage return
000A:         	LF				EQU		0AH		; Line feed
0008:         	CTRH            EQU     8       ; Ctl H Backspace
007F:         	DEL             EQU     127     ; Delete char
0009:         	TAB             EQU     9       ; Tab char
0018:         	CTRX            EQU     24      ; Ctl X Cancel
0013:         	CTRS            EQU     19      ; Ctl S Suspend
0011:         	CTRQ            EQU     17      ; Ctl Q Resume
00F7:         	APOS            EQU     (39-'0') AND 0FFH  ;apostrophe
              	
              	;------------------
              	;xmdm values
              	
0001:         	SOH				EQU		1		; Start of Header
0006:         	ACK             EQU     06H     ; Acknowledge
0015:         	NAK             EQU     15H     ; Negative acknowledge
001A:         	EOF             EQU     1AH     ; End of file - ^Z
0004:         	EOT             EQU     04H     ; End of transmission
000A:         	ERRLIM			EQU		10		; Max allowable errors
0080:         	DMABUF			EQU		80H		; DMA Buffer location
              	
              	
              	;================================================
              	
F000:         	cldst:                          ; COLD START
              	
F000: 315000  	        LXI     SP,STACK        ; Initialize stack for welcome msg
              	
F003: CDECF5  	        CALL    ilprt           ;Display welcome message
F006: 0A0D416C	        db      lf,cr,'Altair 8800 Monitor 8.4',00h
F00A: 74616972	
F00E: 20383830	
F012: 30204D6F	
F016: 6E69746F	
F01A: 7220382E	
F01E: 3400    	
F020: CDECF5  	        CALL    ilprt           ;Display welcome message
F023: 0A0D2843	        db      lf,cr,'(C) 2009 John Garza',lf,cr,00h
F027: 29203230	
F02B: 3039204A	
F02F: 6F686E20	
F033: 4761727A	
F037: 610A0D00	
              	
F03B:         	wrmst:
F03B: 315000  	        LXI     SP,STACK        ;Re-Initialize stack
              	
F03E: 213BF0  	        LXI     H,wrmst         ;Put return addr on stack
F041: E5      	        PUSH    H               ; so command routines can do a RET
              	
F042: CDFBF5  	        CALL    inpln           ;Get command string
F045: CD52F6  	        CALL    getch           ;Get first char from command
              	
              	        ; Process the command
              	
F048: FE44    	        CPI     'D'     ; Deposit data into memory
F04A: CA78F0  	        JZ      enter   ;
              	
F04D: FE45    	        CPI     'E'     ; Examine memory to console
F04F: CAFFF0  	        JZ      dump    ;
              	
F052: FE42    	        CPI     'B'     ; Block Move
F054: CAC7F1  	        JZ      block   ;
              	
F057: FE4A    	        CPI     'J'     ; Jump - execute external code (no return)
F059: CAC2F1  	        JZ      go      ;
              	
F05C: FE4C    	        CPI     'L'     ; MBL - Microsoft Boot Loader for BASIC
F05E: CAF5F1  	        JZ      mbl     ;
              	
F061: FE4D    	        CPI     'M'     ; Memory Test
F063: CA88F2  	        JZ      mem     ;
              	
F066: FE58    	        CPI     'X'     ; Xmodem receive
F068: CAFAF2  	        JZ      xmdm
              	
F06B: FE5A    	        CPI     'Z'     ; Block Move to Zero & RUN
F06D: CA69F2  	        JZ      bmzr    ;
              	
F070: FE3F    	        CPI     '?'     ; Help screen
F072: CA87F4  	        JZ      help    ;
              	
              	
F075: C33BF0  	        JMP     wrmst   ; Go back for another command
              	
              	;--------------------------------------
              	;Command Main Routines
              	;--------------------------------------
              	
              	;------------------
              	;Memory Load routine
              	; Load hex or ascii into mem from console
              	; Check data was written, apostrophe precedes ascii
              	; CR passes over a location
              	
F078:         	enter:
F078: CDECF5  	        CALL	ilprt
F07B: 0A0D4D65	        db		lf,cr,'Memory Load: apostrophe for ASCII, CR skips addr, Ctrl-X exits',lf,cr,00h
F07F: 6D6F7279	
F083: 204C6F61	
F087: 643A2061	
F08B: 706F7374	
F08F: 726F7068	
F093: 6520666F	
F097: 72204153	
F09B: 4349492C	
F09F: 20435220	
F0A3: 736B6970	
F0A7: 73206164	
F0AB: 64722C20	
F0AF: 4374726C	
F0B3: 2D582065	
F0B7: 78697473	
F0BB: 0A0D00  	
              	
F0BE: CD57F1  	load:   CALL    readhl  ;Addr
F0C1: CD99F1  	load2:  CALL    outhl   ;Print it
F0C4: CD30F1  	        CALL    pasci   ;Ascii
F0C7: CDA1F1  	        CALL    outsp
F0CA: 4E      	        MOV     C,M     ;Orig byte
F0CB: CD9EF1  	        CALL    outhex  ;Hex
F0CE: E5      	        PUSH    H       ;Save pointer
F0CF: CD02F6  	        CALL    inpl2   ;Input
F0D2: CD57F1  	        CALL    readhl  ; Byte
F0D5: 45      	        MOV     B,L     ; To B
F0D6: E1      	        POP     H
F0D7: FEF7    	        CPI     APOS
F0D9: CAE8F0  	        JZ      load6   ;Ascii input
F0DC: 79      	        MOV     A,C     ;How many?
F0DD: B7      	        ORA     A       ;None?
F0DE: CAE4F0  	        JZ      load3   ;Yes
F0E1: CDEFF0  	load4:  CALL    chekm   ;Into mem
F0E4: 23      	load3:  INX     H       ;Pointer
F0E5: C3C1F0  	        JMP     load2
              	
              	        ;load ascii char
              	
F0E8: CD52F6  	load6:  CALL    getch
F0EB: 47      	        MOV     B,A
F0EC: C3E1F0  	        JMP     load4
              	
              	        ;copy byte from B to memory
              	        ; and see that it got there
              	
F0EF: 70      	chekm:  MOV     M,B     ;Put in mem
F0F0: 7E      	        MOV     A,M     ;Read back into A
F0F1: B8      	        CMP     B       ;Same?
F0F2: C8      	        RZ              ;Yes
F0F3:         	errp:
F0F3: F1      			POP		PSW		;RAISE STACK
F0F4:         	errb:
F0F4: 3E42    			MVI		A,'B'	;'B' = 'BAD'
F0F6:         	err2:
F0F6: CD91F6  			CALL	outt
F0F9: CDA1F1  			CALL	outsp
F0FC: C399F1  			JMP		outhl
              	
              	
              	;------------------
              	; Memory Dump routine
              	; Display Hex & ascii mem contents over specified range
              	;
              	
F0FF:         	dump:
              	
F0FF: CD40F1  	        CALL    rdhlde  ;Range
F102: CD96F1  	dump2:  CALL    crhl    ;New line
F105: 4E      	dump3:  MOV     C,M     ;Get byte
F106: CDA6F1  	        CALL    outhx   ;Print
F109: 23      	        INX     H       ;Pointer
F10A: 7D      	        MOV     A,L
F10B: E60F    	        ANI     0FH     ;Line end?
F10D: CA18F1  	        JZ      dump4   ;Yes, ascii
F110: E603    	        ANI     3       ;Space
F112: CCA1F1  	        CZ      outsp   ; 4 bytes
F115: C305F1  	        JMP     dump3   ;Next hex
F118: CDA1F1  	dump4:  CALL    outsp
F11B: D5      	        PUSH    D
F11C: 11F0FF  	        LXI     D,-10H  ;Reset line
F11F: 19      	        DAD     D
F120: D1      	        POP     D
F121: CD30F1  	dump5:  CALL    pasci   ;ascii dump
F124: CDBAF1  	        CALL    tstop   ;Done?
F127: 7D      	        MOV     A,L     ;No
F128: E60F    	        ANI     0FH     ;line end?
F12A: C221F1  	        JNZ     dump5   ;No
F12D: C302F1  	        JMP     dump2
              	
              	        ;display byte in ascii if possible, otherwise dot
              	
F130: 7E      	pasci:  MOV     A,M     ;Get byte
F131: FE7F    	        CPI     DEL     ;High bit on?
F133: D23BF1  	        JNC     pasc2   ;Yes
F136: FE20    	        CPI     ' '     ;Control char?
F138: D23DF1  	        JNC     pasc3   ;No
F13B: 3E2E    	pasc2:  MVI     A,'.'   ;Change to dot
F13D: C391F6  	pasc3:  JMP     outt    ;Send
              	
              	        ;get HL and DE from console, check that DE is larger
              	
F140: CD4BF1  	rdhlde: CALL    hhlde
F143: 7B      	rdhld2: MOV     A,E
F144: 95      	        SUB     L       ;E - L
F145: 7A      	        MOV     A,D
F146: 9C      	        SBB     H       ;D - H
F147: DA8EF1  	        JC      error   ;HL is bigger
F14A: C9      	        RET
              	
              	        ;input HL and DE, check that 2 addr are entered
              	
F14B: CD57F1  	hhlde:  CALL    readhl  ;HL
F14E: DA8EF1  	        JC      error   ;Only 1 addr
F151: EB      	        XCHG            ;Save in DE
F152: CD57F1  	        CALL    readhl  ;DE
F155: EB      	        XCHG            ;Put back
F156: C9      	        RET
              	
              	        ;input HL from console
              	
F157: D5      	readhl: PUSH    D
F158: C5      	        PUSH    B       ;Save regs
F159: 210000  	        LXI     H,0     ;Clear
F15C: CD52F6  	rdhl2:  CALL    getch   ;Get char
F15F: DA7BF1  	        JC      rdhl5   ;Line end
F162: CD7EF1  	        CALL    nib     ;To binary
F165: DA71F1  	        JC      rdhl4   ;Not hex
F168: 29      	        DAD     H       ;Times 2
F169: 29      	        DAD     H       ;Times 4
F16A: 29      	        DAD     H       ;Times 8
F16B: 29      	        DAD     H       ;Times 16
F16C: B5      	        ORA     L       ;Add new char
F16D: 6F      	        MOV     L,A
F16E: C35CF1  	        JMP     rdhl2   ;Next
              	
              	        ;check for blank at end
              	
F171: FEF7    	rdhl4:  CPI     APOS    ;Apostrophe
F173: CA7BF1  	        JZ      rdhl5   ;Ascii input
F176: FEF0    	        CPI     (' '-'0') AND 0FFH
F178: C28EF1  	        JNZ     error   ;N0
F17B: C1      	rdhl5:  POP     B
F17C: D1      	        POP     D       ;Restore
F17D: C9      	        RET
              	
              	        ;convert ascii chars to binary
              	
F17E: D630    	nib:    SUI     '0'     ;Ascii bias
F180: D8      	        RC              ;<0
F181: FE17    	        CPI     'F'-'0'+1
F183: 3F      	        CMC             ;Invert
F184: D8      	        RC              ;Error, >F
F185: FE0A    	        CPI     10
F187: 3F      	        CMC             ;Invert
F188: D0      	        RNC             ;Number 0-9
F189: D607    	        SUI     'A'-'9'-1
F18B: FE0A    	        CPI     10      ;Skip : to
F18D: C9      	        RET             ;Letter A-F
              	
              	        ;print ? on improper input
              	
F18E: 3E3F    	error:  MVI     A,'?'
F190: CD91F6  	        CALL    outt
F193: C33BF0  	        JMP     wrmst   ;Try again
              	
              	        ;start new line, give addr
              	
F196: CD3CF6  	crhl:   CALL    crlf    ;New line
F199: 4C      	outhl:  MOV     C,H
F19A: CDA6F1  	        CALL    outhx
F19D: 4D      	outll:  MOV     C,L
F19E: CDA6F1  	outhex: CALL    outhx
F1A1: 3E20    	outsp:  MVI     A,' '
F1A3: C391F6  	        JMP     outt
              	
              	        ;output a hex byte from C (ASCII to HEX converter)
              	
F1A6: 79      	outhx:  MOV     A,C
F1A7: 1F      	        RAR             ;Rotate
F1A8: 1F      	        RAR             ; 4 bits
F1A9: 1F      	        RAR             ; to
F1AA: 1F      	        RAR             ; the right
F1AB: CDAFF1  	        CALL    hex1    ;Upper char
F1AE: 79      	        MOV     A,C     ;Lower char
F1AF: E60F    	hex1:   ANI     0FH     ;Take 4 bits
F1B1: C690    	        ADI     90H
F1B3: 27      	        DAA             ;DAA trick
F1B4: CE40    	        ACI     40H
F1B6: 27      	        DAA
F1B7: C391F6  	        JMP     OUTT
              	
              	        ;check for end, HL minus DE, incr HL
              	
F1BA: 23      	tstop:  INX     H
F1BB: 7B      	        MOV     A,E
F1BC: 95      	        SUB     L       ;E - L
F1BD: 7A      	        MOV     A,D
F1BE: 9C      	        SBB     H       ;D - H
F1BF: D0      	        RNC             ;Not done
              	
F1C0: E1      	        POP     H       ;Raise stack
F1C1: C9      	        RET             ; -- Back
              	
              	;------------------
              	;Routine to go anywhere in memory
              	; Addr of WARM is on stack, so a RET will work for CALLS
              	
F1C2: E1      	go:     POP     H       ;Remove return addr for GO command
F1C3: CD57F1  	calls:  CALL    readhl  ;Get addr
F1C6: E9      	        PCHL            ;Go there
              	
              	;------------------
              	; Block Move
F1C7:         	block:
F1C7: CDDEF1  		CALL	hldebc	;3 ADDR
F1CA:         	movdn:
F1CA: CDD4F1  		CALL	movin	;MOVE/CHECK
F1CD: CDBAF1  		CALL	tstop	;DONE?
F1D0: 03      		INX		B		;NO
F1D1: C3CAF1  		JMP		movdn
F1D4:         	movin:
F1D4: 7E      		MOV	A,M			;BYTE
F1D5: 02      		STAX	B		;NEW LOCATION
F1D6: 0A      		LDAX	B		;CHECK
F1D7: BE      		CMP		M		;IS IT THERE?
F1D8: C8      		RZ				;YES
F1D9: 60      		MOV		H,B		;ERROR
F1DA: 69      		MOV		L,C		;INTO H,L
F1DB: C3F3F0  		JMP		errp	;SHOW BAD
              	
F1DE:         	hldebc:
F1DE: CDECF1  		CALL	hldeck	;RANGE
F1E1: DA8EF1  		JC		error	;NO BYTE
F1E4: E5      		PUSH	H
F1E5: CD57F1  		CALL	readhl	;3RD INPUT
F1E8: 44      		MOV	B,H			;MOVE TO...
F1E9: 4D      		MOV	C,L			;...B,C
F1EA: E1      		POP	H
F1EB: C9      		RET
              		;
              		; GET TWO ADDRESSES, CHECK THAT
              		; ADDITIONAL DATA IS INCLUDED
              		;
F1EC:         	hldeck:
F1EC: CD4BF1  		CALL	hhlde	;2 ADDR
F1EF: DA8EF1  		JC		error	; THAT'S ALL
F1F2: C343F1  		JMP		rdhld2	;CHECK
              	
              	
              	;------------------------------------------------
              	; MITS/MICROSOFT Boot Loader (MBL)
              	;  Loads MS BASIC via serial port (emulating paper tape)
              	;  Set sense switches as needed prior to execution
              	;------------------------------------------------
              	
              	IF SIO2
F1F5:         	mbl:
F1F5: CDECF5  			CALL	ilprt
F1F8: 0A0D4D42			db		lf,cr,'MBL: Set A10 & A11 up, all others down, start transfer...',lf,cr,00h
F1FC: 4C3A2053	
F200: 65742041	
F204: 31302026	
F208: 20413131	
F20C: 2075702C	
F210: 20616C6C	
F214: 206F7468	
F218: 65727320	
F21C: 646F776E	
F220: 2C207374	
F224: 61727420	
F228: 7472616E	
F22C: 73666572	
F230: 2E2E2E0A	
F234: 0D00    	
              	
F236: 2149F2  			LXI		H,mbl4		; point to source
F239: 110000  			LXI		D,0h		; point to destination
F23C: 0620    			MVI		B,32		; move 32 bytes from source to destination
F23E:         	mbl1:
F23E: 7E      			MOV		A,M			; move a byte
F23F: 12      			STAX	D			;
              	
F240: 23      			INX		H			; bump pointers
F241: 13      			INX		D			;
F242: 05      			DCR		B			;
              	
F243: CA0000  			JZ		0000h		; if done, jump to 0000h to run it!
              	
F246: C33EF2  			JMP		mbl1		; otherwise, process more data
              	
              	;-------------------
              	; MITS Boot Loader for 2SIO
              	
F249:         	mbl4:	; hex codes for MITS MBL (4K, 2SIO)
F249: 3E03D310			DB	3Eh,03h,0D3h,10h,3Eh,15h,0D3h,10h
F24D: 3E15D310	
F251: 21AE0F31			DB	21h,0AEh,0Fh,31h,1Ah,00h,0DBh,10h
F255: 1A00DB10	
F259: 0FD0DB11			DB	0Fh,0D0h,0DBh,11h,0BDh,0C8h,2Dh,77h
F25D: BDC82D77	
F261: C0E90B00			DB	0C0h,0E9h,0Bh,00h,00h,00h,00h,00h
F265: 00000000	
              	
              	
              	ENDIF
              	
              	;-----
              	IF SIOA
              	
              	mbl:
              			CALL	ilprt
              			db		lf,cr,'MBL: Set switch A14 up all others down, start transfer...',lf,cr,00h
              	
              			LXI		H,mbl4		; point to source
              			LXI		D,0h		; point to destination
              			MVI		B,24		; move 24 bytes from source to destination
              	mbl1:
              			MOV		A,M			; move a byte
              			STAX	D			;
              	
              			INX		H			; bump pointers
              			INX		D			;
              			DCR		B			;
              	
              			JZ		0000h		; if done, jump to 0000h to run it!
              	
              			JMP		mbl1		; otherwise, process more data
              	
              	
              	mbl4:	; hex codes for MITS MBL (4K, SIO-A)
              			DB	21H,0AEH,0FH,31H,13H,00H,0DBH,00H
              			DB	0E6H,20H,0C8H,0DBH,01H,0BDH,0C8H,2DH
              			DB	77H,0C0H,0E9H,03H,00H,00H,00H,00H
              	
              	ENDIF
              	
              	;-----
              	  IF SS1
              	
              	mbl:
              			CALL	ilprt
              			db		lf,cr,'Unsupported I/O card',lf,cr,00h
              			jmp		wrmst
              	
              	  ENDIF
              	
              	;------------------
              	; Block Move to Zero & Run
F269:         	bmzr:
F269: CD40F1  	    CALL    rdhlde  ;Get Range (test mem from HL to DE)
F26C: 0600    		MVI		B,0		; Zero BC (destination)
F26E: 0E00    		MVI		C,0		;
              	
F270:         	bmz:
F270: 7E      		MOV		A,M		;BYTE
F271: 02      		STAX	B		;NEW LOCATION
F272: 0A      		LDAX	B		;CHECK
F273: BE      		CMP		M		;IS IT THERE?
F274: CA7CF2  		JZ		gdz		;YES
F277: 60      		MOV		H,B		;ERROR
F278: 69      		MOV		L,C		;INTO H,L
F279: C368F6  		JMP		erm		;SHOW BAD
              	
F27C:         	gdz:
F27C: 23      		INX     H		; test if done
F27D: 7B      	    MOV     A,E
F27E: 95      	    SUB     L       ;E - L
F27F: 7A      	    MOV     A,D
F280: 9C      	    SBB     H       ;D - H
F281: DA0000  		JC		0		; If Done, jump to 0000h
              	
F284: 03      		INX		B		; Not done
F285: C370F2  		JMP		bmz		;
              	
              	
              	;------------------
              	;Test block of memory
              	
F288:         	mem:
F288: CD40F1  	        CALL    rdhlde  ;Get Range (test mem from HL to DE)
              	
F28B: CDECF5  	        CALL    ilprt
F28E: 0A0D4D65	        db      lf,cr,'Memory Test - Bad Bytes:',lf,cr,00h
F292: 6D6F7279	
F296: 20546573	
F29A: 74202D20	
F29E: 42616420	
F2A2: 42797465	
F2A6: 733A0A0D	
F2AA: 00      	
              	
              	
F2AB: 2B      	        DCX     H       ; adjust pointer for looping
F2AC: 23      	mloop:  INX     H       ;Point to next byte
F2AD: 7E      	        MOV     A,M     ;Get byte
F2AE: 2F      	        CMA             ;Complement
F2AF: 77      	        MOV     M,A     ;Put back complement
F2B0: BE      	        CMP     M       ;Same?
F2B1: C2F4F2  	        JNZ     badm    ;No - bad memory
F2B4: 2F      	        CMA             ;Orig byte
F2B5: 77      	        MOV     M,A     ;Restore it
              	
F2B6: 4E      	        MOV		C,M		; Save mem byte for bit test
              							;
F2B7: 3655    	        MVI		M, 55H	; Bit test pattern 55H
F2B9: 46      	        MOV		B,M		;
F2BA: 3E55    	        MVI		A, 55H	;
F2BC: B8      	        CMP		B		;
F2BD: C2F4F2  	        JNZ		badm	;
              							;
F2C0: 36AA    	        MVI		M, 0AAH	; Bit test pattern 0AAH
F2C2: 46      	        MOV		B,M		;
F2C3: 3EAA    	        MVI		A, 0AAH	;
F2C5: B8      	        CMP		B		;
F2C6: C2F4F2  	        JNZ		badm	;
              							;
F2C9: 71      			MOV		M,C		; Restore mem byte
              	
              	
F2CA: 7C      	mcont:  MOV     A,H     ; Compare HL to DE, at end?
F2CB: BA      	        CMP     D       ;
F2CC: C2ACF2  	        JNZ     mloop   ;
F2CF: 7D      	        MOV     A,L     ;
F2D0: BB      	        CMP     E       ;
F2D1: C2ACF2  	        JNZ     mloop   ;
              	
F2D4: CDECF5  			CALL	ilprt
F2D7: 0A0D4D65			db		lf,cr,'Memory Test Completed',lf,cr,00h
F2DB: 6D6F7279	
F2DF: 20546573	
F2E3: 7420436F	
F2E7: 6D706C65	
F2EB: 7465640A	
F2EF: 0D00    	
              	
F2F1: C33BF0  	        JMP     wrmst   ; at end
              	
              	
F2F4: CD99F1  	badm:   CALL    outhl   ; Display address of bad memory
              	
F2F7: C3CAF2  	        JMP     mcont   ; continue
              	
              	;---------------------
              	; XMODEM receive routine
              	;---------------------
              	; Implements basic XMODEM checksum receive function to allow loading larger
              	; files from PC with fewer errors.  Code modified from XMODEM v3.2 source
              	; by Keith Petersen
              	
F2FA:         	xmdm:
F2FA: CD57F1  	        CALL    readhl  ;set load location via readhl input routine
F2FD: 225600  			SHLD	dest	;save destination address
              	
F300: 3E00    			MVI		A,0		; Initialize sector number to zero
F302: 325300  			STA		SECTNO	;
              	
F305: CDECF5  			CALL	ilprt
F308: 0A0D5265			db		lf,cr,'Ready to receive file to memory...',lf,cr,0
F30C: 61647920	
F310: 746F2072	
F314: 65636569	
F318: 76652066	
F31C: 696C6520	
F320: 746F206D	
F324: 656D6F72	
F328: 792E2E2E	
F32C: 0A0D00  	
              	
F32F:         	RCVLP:
F32F: CD47F3  			CALL	RCVSECT	;GET A SECTOR
F332: DA41F3  			JC		RCVEOT	;GOT EOT?
F335: CD3CF4  			CALL	WRSECT	;WRITE THE SECTOR
F338: CD34F4  			CALL	INCRSNO	;BUMP SECTOR #
F33B: CDFDF3  			CALL	SENDACK	;ACK THE SECTOR
F33E: C32FF3  			JMP		RCVLP	;LOOP UNTIL EOF
              	;
              	;GOT EOT ON SECTOR - FLUSH BUFFERS, END
              	;
F341:         	RCVEOT:
              			;CALL	WRSECT	;WRITE THE LAST BLOCK
F341: CDFDF3  			CALL	SENDACK	;ACK THE SECTOR
              			;CALL	CLOSFIL	;CLOSE THE FILE
              			;JMP	EXIT		;ALL DONE
              	
F344: C33BF0  			JMP	wrmst
              	
              	
              	;**** xmodem SUBROUTINES
              	;
              	;---->	RCVSECT: RECEIVE A SECTOR
              	;
              	;RETURNS WITH CARRY SET IF EOT RECEIVED.
              	;
F347: AF      	RCVSECT: XRA	A		;GET 0
F348: 325400  			STA		ERRCT	;INIT ERROR COUNT
              	;
F34B: 060A    	RCVRPT:	MVI		B,10	;10 SEC TIMEOUT
F34D: CD4BF4  			CALL	RECV	;GET SOH/EOT
F350: DAA7F3  			JC		RCVSTOT	;TIMEOUT
F353: FE01    			CPI		SOH		;GET SOH?
F355: CAAAF3  			JZ		RCVSOH	;..YES
              	;
              	;EARLIER VERS. OF MODEM PROG SENT SOME NULLS -
              	;IGNORE THEM
              	;
F358: B7      			ORA		A		;00 FROM SPEED CHECK?
F359: CA4BF3  			JZ		RCVRPT	;YES, IGNORE IT
F35C: FE04    			CPI		EOT		;END OF TRANSFER?
F35E: 37      			STC				;RETURN WITH CARRY..
F35F: C8      			RZ				;..SET IF EOT
              	;
              	;DIDN'T GET SOH  OR EOT -
              	;
              	;DIDN'T GET VALID HEADER - PURGE THE LINE,
              	;THEN SEND NAK.
              	;
F360: 0601    	RCVSERR:	MVI	B,1	;WAIT FOR 1 SEC..
F362: CD4BF4  		CALL	RECV	;..WITH NO CHARS
F365: D260F3  		JNC	RCVSERR	;LOOP UNTIL SENDER DONE
F368: 3E15    		MVI	A,NAK	;SEND..
F36A: CD6EF4  		CALL	SEND	;..THE NAK
F36D: 3A5400  		LDA	ERRCT	;ABORT IF..
F370: 3C      		INR	A	;..WE HAVE REACHED..
F371: 325400  		STA	ERRCT	;..THE ERROR..
F374: FE0A    		CPI	ERRLIM	;..LIMIT?
F376: DA4BF3  		JC	RCVRPT	;..NO, TRY AGAIN
              	;
              	;10 ERRORS IN A ROW -
              	;
F379:         	RCVSABT:
              		;CALL	CLOSFIL	;KEEP WHATEVER WE GOT
              		;CALL	ERXIT
              	
F379: CDECF5  		CALL	ilprt
F37C: 2B2B554E		DB	'++UNABLE TO RECEIVE BLOCK '
F380: 41424C45	
F384: 20544F20	
F388: 52454345	
F38C: 49564520	
F390: 424C4F43	
F394: 4B20    	
F396: 2D204142		DB	'- ABORTING++',CR,0
F39A: 4F525449	
F39E: 4E472B2B	
F3A2: 0D00    	
              	
F3A4: C33BF0  		JMP		wrmst
              	;
              	;TIMEDOUT ON RECEIVE
              	;
F3A7:         	RCVSTOT:
F3A7: C360F3  		JMP	RCVSERR	;BUMP ERR CT, ETC.
              	;
              	;GOT SOH - GET BLOCK #, BLOCK # COMPLEMENTED
              	;
F3AA:         	RCVSOH:
F3AA: 0601    		MVI	B,1	;TIMEOUT = 1 SEC
F3AC: CD4BF4  		CALL	RECV	;GET SECTOR
F3AF: DAA7F3  		JC	RCVSTOT	;GOT TIMEOUT
F3B2: 57      		MOV	D,A	;D=BLK #
F3B3: 0601    		MVI	B,1	;TIMEOUT = 1 SEC
F3B5: CD4BF4  		CALL	RECV	;GET CMA'D SECT #
F3B8: DAA7F3  		JC	RCVSTOT	;TIMEOUT
F3BB: 2F      		CMA		;CALC COMPLEMENT
F3BC: BA      		CMP	D	;GOOD SECTOR #?
F3BD: CAC3F3  		JZ	RCVDATA	;YES, GET DATA
              	;
              	;GOT BAD SECTOR #
              	;
F3C0: C360F3  		JMP	RCVSERR	;BUMP ERROR CT.
              	;
F3C3:         	RCVDATA:
F3C3: 7A      		MOV	A,D	;GET SECTOR #
F3C4: 325200  		STA	RCVSNO	;SAVE IT to storage area
F3C7: 0E00    		MVI	C,0	;INIT CKSUM
F3C9: 218000  		LXI	H,DMABUF	;POINT TO BUFFER  <--- CPM DMA buffer @ 80H
              	;
F3CC:         	RCVCHR:
F3CC: 0601    		MVI	B,1	;1 SEC TIMEOUT
F3CE: CD4BF4  		CALL	RECV	;GET CHAR
F3D1: DAA7F3  		JC	RCVSTOT	;TIMEOUT
F3D4: 77      		MOV	M,A	;STORE CHAR
F3D5: 2C      		INR	L	;DONE?
F3D6: C2CCF3  		JNZ	RCVCHR	;NO, LOOP
              	;
              	;VERIFY CHECKSUM
              	;
F3D9: 51      		MOV	D,C	;SAVE CHECKSUM
F3DA: 0601    		MVI	B,1	;TIMEOUT LEN.
F3DC: CD4BF4  		CALL	RECV	;GET CHECKSUM
F3DF: DAA7F3  		JC	RCVSTOT	;TIMEOUT
F3E2: BA      		CMP	D	;CHECKSUM OK?
F3E3: C260F3  		JNZ	RCVSERR	;NO, ERROR
              	;
              	;GOT A SECTOR, IT'S A DUP IF = PREV,
              	;	OR OK IF = 1 + PREV SECTOR
              	;
F3E6: 3A5200  		LDA	RCVSNO	;GET RECEIVED
F3E9: 47      		MOV	B,A	;SAVE IT
F3EA: 3A5300  		LDA	SECTNO	;GET PREV
F3ED: B8      		CMP	B	;PREV REPEATED?
F3EE: CAF7F3  		JZ	RECVACK	;ACK TO CATCH UP
F3F1: 3C      		INR	A	;CALC NEXT SECTOR #
F3F2: B8      		CMP	B	;MATCH?
F3F3: C203F4  		JNZ	ABORT	;NO MATCH - STOP SENDER, EXIT
F3F6: C9      		RET		;CARRY OFF - NO ERRORS
              	;
              	;PREV SECT REPEATED, DUE TO THE LAST ACK
              	;BEING GARBAGED.  ACK IT SO SENDER WILL CATCH UP
              	;
F3F7:         	RECVACK:
F3F7: CDFDF3  		CALL	SENDACK	;SEND THE ACK,
F3FA: C347F3  		JMP	RCVSECT	;GET NEXT BLOCK
              	;
              	;SEND AN ACK FOR THE SECTOR
              	;
F3FD:         	SENDACK:
F3FD: 3E06    		MVI	A,ACK	;GET ACK
F3FF: CD6EF4  		CALL	SEND	;..AND SEND IT
F402: C9      		RET
              	;
              	
F403:         	ABORT:
              		;LXI	SP,STACK
              	;
F403:         	ABORTL:
F403: 0601    		MVI	B,1	;1 SEC. W/O CHARS.
F405: CD4BF4  		CALL	RECV
F408: D203F4  		JNC	ABORTL	;LOOP UNTIL SENDER DONE
F40B: 3E18    		MVI	A,CTRX	;CONTROL X
F40D: CD6EF4  		CALL	SEND	;STOP SENDING END
              	;
F410:         	ABORTW:
F410: 0601    		MVI	B,1	;1 SEC W/O CHARS.
F412: CD4BF4  		CALL	RECV
F415: D210F4  		JNC	ABORTW	;LOOP UNTIL SENDER DONE
F418: 3E20    		MVI	A,' '	;GET A SPACE...
F41A: CD6EF4  		CALL	SEND	;TO CLEAR OUT CONTROL X
              		;CALL	ERXIT	;EXIT WITH ABORT MSG
              		;DB	'XMODEM PROGRAM CANCELLED',lf,cr,'$'
F41D: CDECF5  		CALL	ilprt
F420: 0D584D4F		db	CR,'XMODEM CANCELLED',CR,'0'
F424: 44454D20	
F428: 43414E43	
F42C: 454C4C45	
F430: 440D30  	
F433: C9      		RET			; <--------exit point -------
              	
              	;
              	;---->	INCRSNO: INCREMENT SECTOR #
              	;
F434:         	INCRSNO:
F434: 3A5300  		LDA	SECTNO	;INCR..
F437: 3C      		INR	A	;..SECT..
F438: 325300  		STA	SECTNO	;..NUMBER
F43B: C9      		RET
              	;
              	
              	;
              	;---->	WRSECT: WRITE A SECTOR
              	;
F43C:         	WRSECT:
              	
F43C: 2A5600  		LHLD	dest		;load destination address to HL
F43F: EB      		XCHG				;put destination address in DE
F440: 218000  		LXI		H,DMABUF	;load CPM dma buffer address to HL
F443: CD7CF4  		CALL	MOVE128		;move 128 bytes to destination
F446: EB      		XCHG				; get updated dest addr in HL
F447: 225600  		SHLD	dest		; store it - update destination pointer
F44A: C9      		RET
              	
              	;
              	;---->	RECV: RECEIVE A CHARACTER
              	;
              	;TIMEOUT TIME IS IN B, IN SECONDS.
              	;
F44B:         	RECV:
F44B: D5      		PUSH	D	;SAVE
              	;
              		;IF	FASTCLK	;4MHZ?
              		;MOV	A,B	;GET TIME REQUEST
              		;ADD	A	;DOUBLE IT
              		;MOV	B,A	;NEW TIME IN B
              		;ENDIF
              	;
F44C:         	MSEC:
F44C: 1150C3  		LXI	D,50000	;1 SEC DCR COUNT
              	;
F44F:         	MWTI:
              	
F44F: DB10    	    IN      TTS		; IMSAI specific, check input status
F451: E601    	    ANI     TTYDA	; ""
F453: C265F4  	    JNZ		MCHAR	;got a char
              	
F456: 1D      		DCR	E	;COUNT..
F457: C24FF4  		JNZ	MWTI	;..DOWN..
F45A: 15      		DCR	D	;..FOR..
F45B: C24FF4  		JNZ	MWTI	;..TIMEOUT
F45E: 05      		DCR	B	;MORE SECONDS?
F45F: C24CF4  		JNZ	MSEC	;YES, WAIT
              	;
              	;MODEM TIMED OUT RECEIVING
              	;
F462: D1      		POP	D	;RESTORE D,E
F463: 37      		STC		;CARRY SHOWS TIMEOUT
F464: C9      		RET
              	;
              	;GOT CHAR FROM MODEM
              	;
F465:         	MCHAR:
F465: DB11    	    IN      TTI	; IMSAI specific, get input byte
F467: D1      		POP	D	;RESTORE DE
              	;
              	;CALC CHECKSUM
              	;
F468: F5      		PUSH	PSW	;SAVE THE CHAR
F469: 81      		ADD	C	;ADD TO CHECKSUM
F46A: 4F      		MOV	C,A	;SAVE CHECKSUM
F46B: F1      		POP	PSW	;RESTORE CHAR
F46C: B7      		ORA	A	;CARRY OFF: NO ERROR
F46D: C9      		RET		;FROM "RECV"
              	;
              	;
              	;---->	SEND: SEND A CHARACTER TO THE MODEM
              	;
F46E:         	SEND:
F46E: F5      		PUSH	PSW		;SAVE THE CHAR
F46F: 81      		ADD		C		;CALC CKSUM
F470: 4F      		MOV		C,A		;SAVE CKSUM
              	
F471:         	SENDW:
F471: DB10    		IN		TTS		; IMSAI specific, Check Console Output Status
F473: E602    	    ANI		TTYTR
F475: CA71F4  		JZ		SENDW	;..NO, WAIT
F478: F1      		POP		PSW		;GET CHAR
F479: D311    	    OUT		TTO     ; IMSAI specific, Send Data
F47B: C9      		RET				;FROM "SEND"
              	
              	;
              	;----->  MOVE 128 CHARACTERS
              	;
F47C: 0680    	MOVE128:MVI	B,128	;SET MOVE COUNT
              	;
              	;MOVE FROM (HL) TO (DE) LENGTH IN (B)
              	;
F47E:         	MOVE:
F47E: 7E      		MOV	A,M	;GET A CHAR
F47F: 12      		STAX	D	;STORE IT
F480: 23      		INX	H	;TO NEXT "FROM"
F481: 13      		INX	D	;TO NEXT "TO"
F482: 05      		DCR	B	;MORE?
F483: C27EF4  		JNZ	MOVE	;..YES, LOOP
F486: C9      		RET		;..NO, RETURN
              	;
              	; END XMODEM CODE
              	;------------------
              	
              	;-------------------------------------
              	; HELP SCREEN
              	;-------------------------------------
F487:         	help:
F487: CDECF5  	        CALL    ilprt
              	
F48A: 0A0D    	        db      lf,cr
F48C: 416C7461	        db		'Altair 8800 Monitor Commands:',lf,cr
F490: 69722038	
F494: 38303020	
F498: 4D6F6E69	
F49C: 746F7220	
F4A0: 436F6D6D	
F4A4: 616E6473	
F4A8: 3A0A0D  	
F4AB: 2D2D2D2D	        db		'------------------------------------------',lf,cr
F4AF: 2D2D2D2D	
F4B3: 2D2D2D2D	
F4B7: 2D2D2D2D	
F4BB: 2D2D2D2D	
F4BF: 2D2D2D2D	
F4C3: 2D2D2D2D	
F4C7: 2D2D2D2D	
F4CB: 2D2D2D2D	
F4CF: 2D2D2D2D	
F4D3: 2D2D0A0D	
F4D7: 20457820	        db      ' Ex y   - Examine memory x to y',lf,cr
F4DB: 79202020	
F4DF: 2D204578	
F4E3: 616D696E	
F4E7: 65206D65	
F4EB: 6D6F7279	
F4EF: 20782074	
F4F3: 6F20790A	
F4F7: 0D      	
F4F8: 20447820	        db      ' Dx     - Deposit data at address x',lf,cr
F4FC: 20202020	
F500: 2D204465	
F504: 706F7369	
F508: 74206461	
F50C: 74612061	
F510: 74206164	
F514: 64726573	
F518: 7320780A	
F51C: 0D      	
F51D: 20427820	        db		' Bx y z - Block move x-y to z',lf,cr
F521: 79207A20	
F525: 2D20426C	
F529: 6F636B20	
F52D: 6D6F7665	
F531: 20782D79	
F535: 20746F20	
F539: 7A0A0D  	
F53C: 204A7820	        db      ' Jx     - Jump to x',lf,cr
F540: 20202020	
F544: 2D204A75	
F548: 6D702074	
F54C: 6F20780A	
F550: 0D      	
F551: 204C2020	        db		' L      - MITS 4K BASIC Boot Loader',lf,cr
F555: 20202020	
F559: 2D204D49	
F55D: 54532034	
F561: 4B204241	
F565: 53494320	
F569: 426F6F74	
F56D: 204C6F61	
F571: 6465720A	
F575: 0D      	
F576: 204D7820	        db      ' Mx y   - Memory Test x-y',lf,cr
F57A: 79202020	
F57E: 2D204D65	
F582: 6D6F7279	
F586: 20546573	
F58A: 7420782D	
F58E: 790A0D  	
F591: 20587820	 		db		' Xx     - Xmodem File Receive to memory at x',lf,cr
F595: 20202020	
F599: 2D20586D	
F59D: 6F64656D	
F5A1: 2046696C	
F5A5: 65205265	
F5A9: 63656976	
F5AD: 6520746F	
F5B1: 206D656D	
F5B5: 6F727920	
F5B9: 61742078	
F5BD: 0A0D    	
F5BF: 205A7820	        db		' Zx y   - Block move x-y to 0000h & RUN',lf,cr
F5C3: 79202020	
F5C7: 2D20426C	
F5CB: 6F636B20	
F5CF: 6D6F7665	
F5D3: 20782D79	
F5D7: 20746F20	
F5DB: 30303030	
F5DF: 68202620	
F5E3: 52554E0A	
F5E7: 0D      	
F5E8: 00      	        db      00h
              	
F5E9: C33BF0  	        JMP     wrmst
              	
              	;--------------------------------------
              	;Monitor Command Subroutines
              	;--------------------------------------
              	
              	;------------------
              	;Inline Print
              	;
              	;THE CALL TO ILPRT IS FOLLOWED BY A MESSAGE,
              	;BINARY 0 AS THE END.
              	;
              	
F5EC: E3      	ilprt:  XTHL            ;SAVE HL, GET HL=MSG
F5ED: 7E      	ilplp:  MOV     A,M     ;GET CHAR
F5EE: B7      			ORA		A		;END OF MSG?
F5EF: CAF9F5  	        JZ      ilpret  ;..YES, RETURN
F5F2: CD91F6  	        CALL    outt    ;TYPE THE MSG
F5F5: 23      			INX		H		;TO NEXT CHAR
F5F6: C3EDF5  	        JMP     ilplp   ;LOOP
F5F9: E3      	ilpret: XTHL            ;RESTORE HL
F5FA: C9      		RET		;PAST MSG
              	
              	
              	;------------------
              	;Input line from console and store in buffer
              	;Ctl-X cancels line, ,BKSP erases last char, CR enters line
              	
F5FB:         	inpln:                          ;Input line from console and
F5FB: CDECF5  	        CALL    ilprt
F5FE: 0A0D3E00	        db      lf,cr,'>',00h      ; * PROMPT CHARACTER *
              	
F602: 216000  	inpl2:  LXI     H,IBUFF         ;Input buffer addr
F605: 225D00  	        SHLD    IBUFP
F608: 0E00    	        MVI     C,0             ;Init count to zero
              	
F60A: CD84F6  	inpli:  CALL    intt            ;Get char from console
              	
F60D: FE20    	        CPI     ' '             ;Control char?
F60F: DA2EF6  	        JC      inplc           ;Yes
              	
F612: FE7F    	        CPI     DEL             ;Delete char?
F614: CA46F6  	        JZ      inplb           ;Yes
              	
F617: FE5B    	        CPI     'Z'+1           ;Upper case?
F619: DA1EF6  	        JC      inpl3           ;Yes
F61C: E65F    	        ANI     5Fh             ;No - so make upper case
              	
              	
F61E: 77      	inpl3:  MOV     M,A             ;Into buffer
F61F: 3E10    	        MVI     A,IBL           ;Buffer size
F621: B9      	        CMP     C               ;Full?
F622: CA0AF6  	        JZ      inpli           ;Yes, loop
F625: 7E      	        MOV     A,M             ;Get char from buffer
F626: 23      	        INX     H               ;Incr pointer
F627: 0C      	        INR     C               ; and count
F628: CD91F6  	inple:  CALL    OUTT            ;Show char
F62B: C30AF6  	        JMP     inpli           ;Next char
              	
              	        ;Process control chars
              	
F62E: FE08    	inplc:  CPI     CTRH            ;Ctl H ?
F630: CA46F6  	        JZ      inplb           ;Yes
F633: FE0D    	        CPI     CR              ;Return?
F635: C20AF6  	        JNZ     inpli           ;No, ignore
              	
              	        ;End of input line
              	
F638: 79      	        MOV     A,C             ;Count
F639: 325F00  	        STA     IBUFC           ;Save it
              	
              	        ;CR LF routine
              	
F63C:         	crlf:
F63C: 3E0D    	        MVI     A,CR
F63E: CD91F6  	        CALL    outt            ;Send CR
F641: 3E0A    	        MVI     A,LF
F643: C391F6  	        JMP     outt            ;Send LF
              	
              	;        MVI     A,CR
              	;        JMP     outt
              	
              	        ;Delete prior char, if any
              	
F646: 79      	inplb:  MOV     A,C             ;Char count
F647: B7      	        ORA     A               ;Zero?
F648: CA0AF6  	        JZ      inpli           ;Yes
F64B: 2B      	        DCX     H               ;Back pointer
F64C: 0D      	        DCR     C               ; and count
              	
F64D: 3E08    	        MVI     A,CTRH
              	        ;;MVI     A,DEL
              	
F64F: C328F6  	        JMP     inple           ;Send ctrl H
              	
              	;------------------
              	;Get Character from Console Buffer
              	; Set Carry Bit if empty
              	
F652: E5      	getch:  PUSH    H               ;Save Regs
F653: 2A5D00  	        LHLD    IBUFP           ;Get Pointer
F656: 3A5F00  	        LDA     IBUFC           ; and Count
F659: D601    	        SUI     1               ;Decr with carry
F65B: DA66F6  	        JC      getc4           ;No more char
F65E: 325F00  	        STA     IBUFC           ;Save new count
F661: 7E      	        MOV     A,M             ;Get character
F662: 23      	        INX     H               ;Incr pointer
F663: 225D00  	        SHLD    IBUFP           ; and save
F666: E1      	getc4:  POP     H               ;Restore Regs
F667: C9      	        RET
              	
              	;-------------------
              	; Memory error message
F668:         	erm:
              	
F668: CDECF5  	        CALL    ilprt
F66B: 0A0D4D65	        db      lf,cr,'Memory Error at ',00h
F66F: 6D6F7279	
F673: 20457272	
F677: 6F722061	
F67B: 742000  	
F67E: CD99F1  			CALL	outhl
              	
F681: C33BF0  			JMP		wrmst
              	
              	
              	;------------------
              	; Simplified Core IO Routines
              	
              	;------------------
              	;Console Input
              	
F684:         	intt:
F684: CD99F6  	        CALL    instat          ;Check status
F687: DB11    	        IN      TTI             ;Get byte
F689: E67F    	        ANI     DEL
F68B: FE18    	        CPI     CTRX            ;Abort?
F68D: CA3BF0  	        JZ      wrmst           ;
F690: C9      	        RET
              	
              	;------------------
              	;Console Output
              	
F691:         	outt:
F691: F5      	        PUSH    PSW
F692: CDA1F6  	        CALL    outstat
F695: F1      	        POP     PSW
F696: D311    	        OUT     TTO             ;Send Data
F698: C9      	        RET
              	
              	
              	;------------------
              	;Check Console Input Status
              	
F699:         	instat:
F699: DB10    	        IN      TTS
F69B: E601    	        ANI     TTYDA
F69D: CA99F6  	        JZ      instat
F6A0: C9      	        RET
              	
              	;------------------
              	;Check Console Output Status
              	
F6A1:         	outstat:
F6A1: DB10    	        IN      TTS             ;CHECK FOR USER INPUT CTRL-X
F6A3: E601    	        ANI     TTYDA           ;
F6A5: CAB1F6  	        JZ      out2            ;
F6A8: DB11    	        IN      TTI             ;
F6AA: E67F    	        ANI     DEL             ;
F6AC: FE18    	        CPI     CTRX            ;
F6AE: CA3BF0  	        JZ      wrmst           ;
              	
F6B1: DB10    	out2:   IN      TTS             ;Check Console Output Statuas
F6B3: E602    	        ANI     TTYTR           ;
F6B5: CAA1F6  	        JZ      outstat         ;
F6B8: C9      	        RET
              	
              	
              	;==================
              			END
              	;==================
***ERROR*** No such file or directory: file = "/pub/Develop/Projects/zasm-4.0/Test/8080/original/Altair8800_Monitor." (fd108)


; +++ segments +++

#CODE          = $F000 = 61440,  size = $06B9 =  1721

; +++ global symbols +++

_8080_     = $0001 =     1          :1 (unused)
_asm8080_  = $0001 =     1          :1 (unused)
_casefold_ = $0001 =     1          :1 (unused)
_end       = $F6B9 = 63161          Altair8800_Monitor.asm:10 (unused)
_reqcolon_ = $0001 =     1          :1 (unused)
_size      = $06B9 =  1721          Altair8800_Monitor.asm:10 (unused)
abort      = $F403 = 62467          Altair8800_Monitor.asm:734
abortl     = $F403 = 62467          Altair8800_Monitor.asm:737
abortw     = $F410 = 62480          Altair8800_Monitor.asm:744
ack        = $0006 =     6          Altair8800_Monitor.asm:104
apos       = $00F7 =   247          Altair8800_Monitor.asm:98
badm       = $F2F4 = 62196          Altair8800_Monitor.asm:568
block      = $F1C7 = 61895          Altair8800_Monitor.asm:375
bmz        = $F270 = 62064          Altair8800_Monitor.asm:496
bmzr       = $F269 = 62057          Altair8800_Monitor.asm:491
calls      = $F1C3 = 61891          Altair8800_Monitor.asm:370 (unused)
chekm      = $F0EF = 61679          Altair8800_Monitor.asm:207
cldst      = $F000 = 61440          Altair8800_Monitor.asm:114 (unused)
cr         = $000D =    13          Altair8800_Monitor.asm:90
crhl       = $F196 = 61846          Altair8800_Monitor.asm:329
crlf       = $F63C = 63036          Altair8800_Monitor.asm:957
ctrh       = $0008 =     8          Altair8800_Monitor.asm:92
ctrq       = $0011 =    17          Altair8800_Monitor.asm:97 (unused)
ctrs       = $0013 =    19          Altair8800_Monitor.asm:96 (unused)
ctrx       = $0018 =    24          Altair8800_Monitor.asm:95
del        = $007F =   127          Altair8800_Monitor.asm:93
dest       = $0056 =    86          Altair8800_Monitor.asm:31
dmabuf     = $0080 =   128          Altair8800_Monitor.asm:109
dump       = $F0FF = 61695          Altair8800_Monitor.asm:226
dump2      = $F102 = 61698          Altair8800_Monitor.asm:229
dump3      = $F105 = 61701          Altair8800_Monitor.asm:230
dump4      = $F118 = 61720          Altair8800_Monitor.asm:239
dump5      = $F121 = 61729          Altair8800_Monitor.asm:244
enter      = $F078 = 61560          Altair8800_Monitor.asm:174
eof        = $001A =    26          Altair8800_Monitor.asm:106 (unused)
eot        = $0004 =     4          Altair8800_Monitor.asm:107
erm        = $F668 = 63080          Altair8800_Monitor.asm:997
err2       = $F0F6 = 61686          Altair8800_Monitor.asm:215 (unused)
errb       = $F0F4 = 61684          Altair8800_Monitor.asm:213 (unused)
errct      = $0054 =    84          Altair8800_Monitor.asm:30
errlim     = $000A =    10          Altair8800_Monitor.asm:108
error      = $F18E = 61838          Altair8800_Monitor.asm:323
errp       = $F0F3 = 61683          Altair8800_Monitor.asm:211
gdz        = $F27C = 62076          Altair8800_Monitor.asm:506
getc4      = $F666 = 63078          Altair8800_Monitor.asm:992
getch      = $F652 = 63058          Altair8800_Monitor.asm:983
go         = $F1C2 = 61890          Altair8800_Monitor.asm:369
help       = $F487 = 62599          Altair8800_Monitor.asm:868
hex1       = $F1AF = 61871          Altair8800_Monitor.asm:346
hhlde      = $F14B = 61771          Altair8800_Monitor.asm:273
hldebc     = $F1DE = 61918          Altair8800_Monitor.asm:392
hldeck     = $F1EC = 61932          Altair8800_Monitor.asm:405
ibl        = $0010 =    16          Altair8800_Monitor.asm:36
ibufc      = $005F =    95          Altair8800_Monitor.asm:34
ibuff      = $0060 =    96          Altair8800_Monitor.asm:35
ibufp      = $005D =    93          Altair8800_Monitor.asm:33
ilplp      = $F5ED = 62957          Altair8800_Monitor.asm:898
ilpret     = $F5F9 = 62969          Altair8800_Monitor.asm:904
ilprt      = $F5EC = 62956          Altair8800_Monitor.asm:897
incrsno    = $F434 = 62516          Altair8800_Monitor.asm:759
inpl2      = $F602 = 62978          Altair8800_Monitor.asm:916
inpl3      = $F61E = 63006          Altair8800_Monitor.asm:933
inplb      = $F646 = 63046          Altair8800_Monitor.asm:968
inplc      = $F62E = 63022          Altair8800_Monitor.asm:945
inple      = $F628 = 63016          Altair8800_Monitor.asm:940
inpli      = $F60A = 62986          Altair8800_Monitor.asm:920
inpln      = $F5FB = 62971          Altair8800_Monitor.asm:912
instat     = $F699 = 63129          Altair8800_Monitor.asm:1034
intt       = $F684 = 63108          Altair8800_Monitor.asm:1012
lf         = $000A =    10          Altair8800_Monitor.asm:91
load       = $F0BE = 61630          Altair8800_Monitor.asm:178 (unused)
load2      = $F0C1 = 61633          Altair8800_Monitor.asm:179
load3      = $F0E4 = 61668          Altair8800_Monitor.asm:195
load4      = $F0E1 = 61665          Altair8800_Monitor.asm:194
load6      = $F0E8 = 61672          Altair8800_Monitor.asm:200
mbl        = $F1F5 = 61941          Altair8800_Monitor.asm:418
mbl1       = $F23E = 62014          Altair8800_Monitor.asm:425
mbl4       = $F249 = 62025          Altair8800_Monitor.asm:440
mchar      = $F465 = 62565          Altair8800_Monitor.asm:817
mcont      = $F2CA = 62154          Altair8800_Monitor.asm:555
mem        = $F288 = 62088          Altair8800_Monitor.asm:521
mloop      = $F2AC = 62124          Altair8800_Monitor.asm:529
movdn      = $F1CA = 61898          Altair8800_Monitor.asm:377
move       = $F47E = 62590          Altair8800_Monitor.asm:853
move128    = $F47C = 62588          Altair8800_Monitor.asm:849
movin      = $F1D4 = 61908          Altair8800_Monitor.asm:382
msec       = $F44C = 62540          Altair8800_Monitor.asm:793
mwti       = $F44F = 62543          Altair8800_Monitor.asm:796
nak        = $0015 =    21          Altair8800_Monitor.asm:105
nib        = $F17E = 61822          Altair8800_Monitor.asm:309
nul        = $0000 =     0          Altair8800_Monitor.asm:89 (unused)
out2       = $F6B1 = 63153          Altair8800_Monitor.asm:1052
outhex     = $F19E = 61854          Altair8800_Monitor.asm:333
outhl      = $F199 = 61849          Altair8800_Monitor.asm:330
outhx      = $F1A6 = 61862          Altair8800_Monitor.asm:339
outll      = $F19D = 61853          Altair8800_Monitor.asm:332 (unused)
outsp      = $F1A1 = 61857          Altair8800_Monitor.asm:334
outstat    = $F6A1 = 63137          Altair8800_Monitor.asm:1043
outt       = $F691 = 63121          Altair8800_Monitor.asm:1023
pasc2      = $F13B = 61755          Altair8800_Monitor.asm:258
pasc3      = $F13D = 61757          Altair8800_Monitor.asm:259
pasci      = $F130 = 61744          Altair8800_Monitor.asm:253
rcvchr     = $F3CC = 62412          Altair8800_Monitor.asm:689
rcvdata    = $F3C3 = 62403          Altair8800_Monitor.asm:683
rcveot     = $F341 = 62273          Altair8800_Monitor.asm:599
rcvlp      = $F32F = 62255          Altair8800_Monitor.asm:589
rcvrpt     = $F34B = 62283          Altair8800_Monitor.asm:617
rcvsabt    = $F379 = 62329          Altair8800_Monitor.asm:650 (unused)
rcvsect    = $F347 = 62279          Altair8800_Monitor.asm:614
rcvserr    = $F360 = 62304          Altair8800_Monitor.asm:637
rcvsno     = $0052 =    82          Altair8800_Monitor.asm:28
rcvsoh     = $F3AA = 62378          Altair8800_Monitor.asm:667
rcvstot    = $F3A7 = 62375          Altair8800_Monitor.asm:662
rdhl2      = $F15C = 61788          Altair8800_Monitor.asm:285
rdhl4      = $F171 = 61809          Altair8800_Monitor.asm:299
rdhl5      = $F17B = 61819          Altair8800_Monitor.asm:303
rdhld2     = $F143 = 61763          Altair8800_Monitor.asm:264
rdhlde     = $F140 = 61760          Altair8800_Monitor.asm:263
readhl     = $F157 = 61783          Altair8800_Monitor.asm:282
recv       = $F44B = 62539          Altair8800_Monitor.asm:784
recvack    = $F3F7 = 62455          Altair8800_Monitor.asm:722
sectno     = $0053 =    83          Altair8800_Monitor.asm:29
send       = $F46E = 62574          Altair8800_Monitor.asm:833
sendack    = $F3FD = 62461          Altair8800_Monitor.asm:728
sendw      = $F471 = 62577          Altair8800_Monitor.asm:838
sio2       = $0001 =     1          Altair8800_Monitor.asm:17
sioa       = $0000 =     0          Altair8800_Monitor.asm:16
soh        = $0001 =     1          Altair8800_Monitor.asm:103
ss1        = $0000 =     0          Altair8800_Monitor.asm:18
stack      = $0050 =    80          Altair8800_Monitor.asm:23
tab        = $0009 =     9          Altair8800_Monitor.asm:94 (unused)
tstop      = $F1BA = 61882          Altair8800_Monitor.asm:355
tti        = $0011 =    17          Altair8800_Monitor.asm:54
tto        = $0011 =    17          Altair8800_Monitor.asm:55
tts        = $0010 =    16          Altair8800_Monitor.asm:53
ttyda      = $0001 =     1          Altair8800_Monitor.asm:56
ttytr      = $0002 =     2          Altair8800_Monitor.asm:57
wrmst      = $F03B = 61499          Altair8800_Monitor.asm:123
wrsect     = $F43C = 62524          Altair8800_Monitor.asm:769
xmdm       = $F2FA = 62202          Altair8800_Monitor.asm:579


total time: 0.0186 sec.
1 error
